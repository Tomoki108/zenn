---
title: "AtCoder Beginer Contest 351~391 D or E までの要点・解答（Go）"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["atcoder", "go"]
published: true
---

prev: [AtCoder Beginer Contest 301~350 D or E までの要点・解答（Go）](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc)

※ 個人的なメモ。コードは比較的読み易いと思います。
※ そのトピックにおいて典型的な問題の場合、問題タイトルの後ろにトピックを記載。

# 391

## [A - Lucky Direction](https://atcoder.jp/contests/abc391/tasks/abc391_a)

- 愚直

## [B - Seek Grid](https://atcoder.jp/contests/abc391/tasks/abc391_b)

- 全探索。グリッドの範囲外アクセスを予防するため、**必ず`c.IsValid(H, W)`する**。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc391/b/main.go
:::

## [C - Pigeonhole Query](https://atcoder.jp/contests/abc391/tasks/abc391_c)

- 鳩を巣から巣に移動させなければならないため、鳩の現在の巣を管理する必要がある。`var birdNestMap map[int]int`

- 複数鳩がいる巣を検知しないといけないため、巣ごとの匹数を管理する必要もある。`var nestBirdCount map[int]int`

- 複数鳩がいる巣の数を ans とし、ある巣の匹数が増減したとき、2->1 の変更が起きたら`ans--`、1->2 の変更が起きたら`ans++`とすればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc391/c/main.go
:::

## [D - Gravity](https://atcoder.jp/contests/abc391/tasks/abc391_d)

- ブロックが消えるのは、横一列揃った時。X 座標ごとの Y 座標のデータを作り、各 X 座標から一つづつ Y 座標を取り出し、全ての X 座標から一つづつ取り出せたら、それらの座標のブロックを全て削除できる。取り出せなかったら、もう削除できるブロックはない。

  - X 座標ごとの Y 座標のデータは**Ordered Set**でもいいし、普通のスライスでもいい。（入力を受け取ってソートしたら、あとは末尾から削除するだけだから。）
  - 全ての X 座標に最低一つの Y 座標がない場合は 1 列も削除できないことに注意。

- ブロックが消える時刻 T は、同じ回に消えるブロックの中で最も Y 座標が高いもののそれと同じ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc391/d/main.go
:::

## [E - Hierarchical Majority Vote](https://atcoder.jp/contests/abc391/tasks/abc391_e) / DP（ボトムアップ）

- 取りまとめられた票のデータを木構造として作っていった場合、一番下の階層から順にノード数は $3^n, 3^{n-1}, 3^{n-2}, ...3^{0}$ となる。総ノード数は**等比数列の和の公式**より $1* (3^{14} - 1) / (3-1) = 2391484$ となり、全列挙も全探索も可能。

- 木を作り、再帰的に結果を裏返す最小コストを求めればいい。既に目当ての結果ならコスト 0、そうでなく最下層でなければ下層に潜って戻り値をもとに判定、最下層なら既に目当ての結果ならコスト 0、そうでないならコスト 1 とすればいい。（**ボトムアップ**）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc391/e/main.go
:::

# 390

## [A - 12435](https://atcoder.jp/contests/abc390/tasks/abc390_a) / Sort

- As をコピーしてソートして、`sorted`を作成。
- `for i:=0; i<N-1; i++ {}`でループして、`As[i], As[i+1]`をスワップしたスライスが`sorted`と一致するかチェックする。（ループごとに As のコピーを作成して行う。）
- 類題：[350 C - Sort](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#c---sort-%2F-sort)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc390/a/main.go
:::

## [B - Geometric Sequence](https://atcoder.jp/contests/abc390/tasks/abc390_b) / 等比数列

- 項数 3 の等比数列`{a, b, c}`について、$a^{r*0}, a^{r*1}, a^{r*2}$ より、$a*c = b^2$ が成り立つ。これを index 0 ~ N-1 で検証すればいい。

- 隣り合う二つの比率を出して比較し続ける方法だと、小数になり精度の問題で WA になる可能性がある。**小数を整数で扱う方法を考える。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc390/b/main.go
:::

## [C - Paint to make a rectangle](https://atcoder.jp/contests/abc390/tasks/abc390_c)

- 黒マスのうち、最も上、下、左、右の座標を出し、左上-右下の範囲で黒マスおよび?マスのみしか存在しないことを検証すればいい。
  - 座標の列挙は 4 回ループしてそれぞれを見つけてもいいし、`min(), max()`を使えば 1 回のループで済む。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc390/c/main.go
:::

## [D - Stone XOR](https://atcoder.jp/contests/abc390/tasks/abc390_d) / XOR（排他的論理和）、グループ分け、DFS（全探索）

- XOR の性質は以下の様なものくらいしかない。これらを活用して複数のパターンを同一視するなどはできないため、**全探索**を考える。

```go
fmt.Println(a^b^c == c^b^a) // true. 可換。順番を入れ替えても結果が変わらない。
fmt.Println(a^0 == a)       // true. aと0のxorを取るとaになる。
fmt.Println(a^b^c^a == b^c) // true. aの逆元はaであり、同じ数字でxorをとると0になる。
```

- この問題は、As を N 個以下の（区別されない）グループに分け、グループ内の和同士で XOR を取る場合の答えのパターン数を出すということ。

  - このようなグループ分けのパターン数は **[ベル数](https://manabitimes.jp/math/892)** と呼ばれる。（[ベル数一覧](https://number-pedia.com/bell/)）。
  - 12 個の要素から 12 個以下の任意の数にグループ分けするパターンは 4213597 個であるため、**全探索**が可能である。

- **複雑な全探索なので再帰で書く。** ある要素は、すでにあるグループのいずれかに追加するか、新しいグループを作ってそこに入れるか。index 0~N-1 までそのような操作を再帰的に行い、index N に到達したらグループ分けのパターンをグローバル変数に追加して return。**詳細は実装参照。**
  - 今回はグループ内の総和だけ記録更新すれば済むのでそうしている。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc390/d/main.go
:::

## [E - Vitamin Balance](https://atcoder.jp/contests/abc390/tasks/abc390_e) / ナップサック問題、DP（テーブル）、二分探索

- **問題の簡単なバージョンを考える。**「カロリー X 以下になるように食べ物を食べた時の、ビタミン 1 の摂取量の最大は？」=> **ナップサック問題**。

  - `var dp1 [][]int // dp[i][j] i番目(1-indexed)までの食べ物を処理した時に、丁度jカロリーで得られる最大のビタミン1の最大摂取量`

- 各ビタミンについて DP で上記の問題を解くと、`dp[N][0~X]`に、最後までの食べ物を見て決めた時に、j カロリーでビタミン V が最大どれだけ摂取できるかわかる。

  - 各食べ物は１種類しかビタミンを含まないので、各 DP で重複して食べ物を選んでいることはない。

- ans は、`a+b+c <= X`となるように a, b, c を選び、`min(dp1[N][a], dp2[N][b], dp[N][c])`が最大になった時のその値。

  - その場合、`dp1[N][a] >= ans && dp2[N][b] >= ans && dp3[N][c] >= ans`を満たしていることにもなる。

- **最小値の最大化については、二分探索で解けることが多い**らしい。

- ans（候補） が大きくなっていった場合、単調に変化するものは何か？
  - `dp1[N][a], dp2[N][b], dp3[N][c] >= ans`である必要がある為、必然的に総カロリーが増える。（摂取ビタミンの下限が上がる。摂取ビタミンを増やすには、カロリーも増やす必要がある。）
  - 逆に言えば ans が小さくなるほど`X <= 総カロリー`が true になりやすいという**単調増加性**があるので、`DescIntSearch()`が使える。
  - 二分探索のコールバックの中で、各`dp[N][0~X]`から、値（摂取ビタミン）が ans 以上になる**最小の**添字（カロリー）を探す。（ループでもいいし更に二分探索でもいい。）
    - 最小のカロリーを選択するのが、`X <= 総カロリー`を目指す上で最適な選択。
    - そして`return calorie1 + calorie2 + calorie3 <= X`する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc390/e/main.go
:::

# 389

## [A - 9x9](https://atcoder.jp/contests/abc389/tasks/abc389_a)

- 愚直

## [B - tcaF](https://atcoder.jp/contests/abc389/tasks/abc389_b)

- サンプル 2 より、N = 20 で X が 2432902008176640000（**19 桁**）になる。よって N >= 21 で X の上限（19 桁）を超えることがわかる。なので、N=1~20 を**全探索**すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc389/b/main.go
:::

## [C - Snake Queue](https://atcoder.jp/contests/abc389/tasks/abc389_c) / 累積和 or Deque + 遅延評価

### 累積和

- 蛇の頭の座標は、それ以前の蛇の長さの総和になる。蛇の長さを**累積和**に記録し、何番目の蛇が先頭かを記録すれば、累積和の差で目当ての座標が求められる。

  ```go
  // k番目をidxにするため-1. 累積和配列は先頭の0の分長いので+1. idx kの蛇の座標はidx k-1の累積話に等しいので-1（左記と相殺）.
  ans := prefsum[startIdx+(k-1)] - prefSum[startIdx]
  ```

### Deque + 遅延評価

- **Deque**は、先頭/末尾の削除、追加、インデックスでの要素アクセス全てを O(1)で行えるデータ構造。詳細は[実装](https://github.com/Tomoki108/go-algo/blob/main/lib/deque/deque.go)を参照。

- `deque.PushBack()`で蛇の長さの累積和を記録していく。（**通常の累積和とは違い、都合により 0 始まりにはならないことに注意。**）

- 蛇が抜けるたびに`deque.PopFront()`で削除し、これまでに抜けた蛇の長さの和をその値で上書きする。（**遅延評価**用の値。）

- クエリ 3 では`deque.At(k-1)`でインデックスアクセスし、遅延評価用の値を引けば答えになる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc389/c/main.go
:::

## [D - Squares in Circle](https://atcoder.jp/contests/abc389/tasks/abc389_d) / 座標平面（円）、二分探索

- 円の**対称性**を利用し、**第一象限だけ考えて 4 倍できないか考える。**

- **小数は扱いづらいので、等倍にして無くす。**

- [ツール](https://www.geogebra.org/calculator?lang=ja)で作図する。
  :::details image
  ![image](/images/ABC/389/d.png)
  :::

- 第一象限について、右上の座標までの距離が半径 R 以下なら円に含まれることがわかる。

  - maxY, maxX が R-1 であることが分かる。
  - 各 Y に対して、ギリギリの X を**二分探索** できそう。`DescIntSearch(R-1, 1)`
  - Y を上から試し、minX を直前のギリギリの X で更新すれば範囲が狭まり効率化する。範囲が広いのは最初の二分探索のみなので、$O(\log R)$になる。

- **「座標を 2 で等倍していること」、「中心のブロックを最後に足すこと」、「`R=2 // 1*2`の時は上記とは別に処理した方がいいこと」に注意する。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc389/d/main.go
:::

# 388

## [A - ?UPC](https://atcoder.jp/contests/abc388/tasks/abc388_a)

- 愚直

## [B - Heavy Snake](https://atcoder.jp/contests/abc388/tasks/abc388_b)

- 愚直に全探索

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc388/b/main.go
:::

## [C - Various Kagamimochi](https://atcoder.jp/contests/abc388/tasks/abc388_c)

- 餅ごとに二分探索して、下に置いて鏡餅にできる組み合わせの数を求めて足し上げる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc388/c/main.go
:::

## [D - Coming of Age Celebration](https://atcoder.jp/contests/abc388/tasks/abc388_d) / imos 法

- N 人の所持石をそれぞれ求める必要があるので、N のループは必要。つまり制約より、前の人からいくつ石をもらうのか、後ろの何人にを渡すのかを高速に求める必要がある。

- 前から処理し、後ろのデータを更新していけば、各人のイテレートについて前の何人から石をもらうのかは考えなくていい。後ろの何人に石を渡すのかの判定と、石を渡した後のデータ更新を高速化できればいい。

  - 前者は簡単。`min(所持数, 後ろの人数)`

- **「配列の部分区間の、等しい更新処理」を高速に行う手法**として、**imos 法**が存在する。range update of difference array、差分配列への区間更新とも言う。

  - **差分配列**（`index i`まで累積和を取ることで、`index i`の値を求められる配列）を事前に作成しておく。
  - `[index i, j]`の区間の値に`+x`する更新をしたいとして、差分配列の `index i`に`+x`し、`index j+1`に`-x`する。こうすると累積和で値を復元する際に、適切な値が復元される。
  - つまり計算量が`O(k) // k: 更新区間の長さ`から、`O(2)`になる。下準備（差分配列の作成）と値の復元（累積和の取得）にそれぞれ`O(n)`かかるが、何度も区間更新を行う場合大幅に有利。

---

- 遅延評価＋**Ordered Multi Set**で解く方法をずっと考えていたが、**tree set では二分探索ができるが、条件に合致するノードの数は高速に求められない。（言語やライブラリによらない。）終端までイテレーターを動かして列挙する方法しか無理。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc388/d/main.go
:::

## [E - Simultaneous Kagamimochi](https://atcoder.jp/contests/abc388/tasks/abc388_e) / 二分探索

- 『K 個 の鏡餅を作るとき、先頭 K 個と末尾 K 個の餅を使うとしてかまいません（上に乗せられている餅が先頭 K 個と異なる場合、先頭 K 個の餅が上になるように入れ替えることができます。末尾 K 個も同様です）。』

- K が小さいほど K 個の鏡餅は成立しやすく、一定以上大きくなると成立しなくなる。K を 0~N/2 で**二分探索**し、K 回ループして 全てで 1:2 以上 の比率が成立するか判定すればいい。
  - $O(N/2 * \log N/2)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc388/e/main.go
:::

# 387

## [A - Happy New Year 2025](https://atcoder.jp/contests/abc387/tasks/abc387_a)

- 愚直。答えは最大でも 8 桁にしかならないので、オーバーフローはしない。
  - $(2 * 10^3 + 2 * 10^3)^2 = (4 * 10^3)^2 = 16 * 10^6$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc387/a/main.go
:::

## [B - 9x9 Sum](https://atcoder.jp/contests/abc387/tasks/abc387_b)

- 愚直。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc387/b/main.go
:::

## [C - Snake Numbers](https://atcoder.jp/contests/abc387/tasks/abc387_c) / 整数問題（いい数の個数）、桁 DP（メモ化再帰）

- **L 以上 R 以下の条件を満たす整数の個数を求めたいなら、「引数以下の、条件を満たす整数の個数を返す関数」を実装し、`f(R) - f(L-1)`すればいい。**

- 条件を満たす整数の個数を求めたい場合、**桁 DP（メモ化再帰）** が使える。

  - **何を再帰的に数えればいいのか考える。（テーブルをイメージするのは違う。）**
  - |R|桁目まで確定した R 以下の数について、１を返す。|R|-1 桁目まで確定した R 以下の数について、再帰呼び出しの戻り値の合計を返す。...。これをするための**再帰関数を実装する。**
  - 桁 DP を実現するための再帰関数では、**pos（left indexed の桁数）、strict（上限を気にして次の桁を列挙する必要があるか）を最低限受け取る** ことになる。後は問題に応じた保持すべき状態を受け取る。

    - **`strict == 1` になるのは、現在埋まっている桁が全て上限の数のそれと一致している時。**
    - 今回は追加で、`firstNum int // 最初に登場したゼロでは無い数字 || ゼロ`も受け取る。

  - **途中の計算結果をメモ化し、条件を満たす整数を全列挙するまで再帰呼び出しをする必要をなくす。メモは多重スライスに格納してもいいし、状態からキーを生成してマップに格納してもいい。**

    - 前者はスライスの初期化が面倒。**また前者の場合、メモ用の多重スライスのインデックスで状態を表現できるよう、bool の状態（strict など）も int で管理する。**

  - **桁 DP の計算量は、`O(取りうる状態の数)`。**
    - 今回の場合：$O(pos * firstNum * strict) = O(18 * 9 * 2) = O(18^2)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc387/c/main.go
:::

## [D - Snaky Walk](https://atcoder.jp/contests/abc387/tasks/abc387_d) / 多始点 BFS

- **最短経路**を求める問題なので**BFS**。

  - 縦移動の後は横移動しかできない（逆も然り）ので、キューアイテムに最後どちらで移動したかを記録する。
  - 隣接をとるときに、最後どちらで移動したかで上下を取るか左右を取るかスイッチする。
  - 訪問済みノードについて、縦移動で訪問済みでも横移動なら再訪する価値がある。なので、boolean ではなく int で記録する。（未、縦、横、両方。）

- 縦始まり、横始まりで 2 回 BFS をしてもいいが、最初から縦始まりと横始まりをキューに積んでおいて**多始点 BFS**としてやると効率的。

  - BFS の最大計算量はノード数。各ノードに縦と横移動で 2 回訪問する可能性があるので、今回は O(200 万)。
  - BFS を 2 回やる方法でも O(400 万)なので十分間に合う。

- **BFS で visited を記録するのは、キューににノードを積んだ直後！ノードを取り出した後ではない！**

  - 後者のタイミングだと記録前の訪問済みノードがキューに積まれてしまい非効率。

- 類題：[351 D - Grid and Magnet](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---grid-and-magnet-%2F-dfs%EF%BC%88%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%EF%BC%89%E3%80%81%E9%80%A3%E7%B5%90%E6%88%90%E5%88%86)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc387/d/main.go
:::

# 386

## [A - Full House 2](https://atcoder.jp/contests/abc386/tasks/abc386_a)

- 愚直。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc386/a/main.go
:::

## [B - Calculator](https://atcoder.jp/contests/abc386/tasks/abc386_b) / ランレングス圧縮

- 0 が K 個連続するときに、コストを`+ 2/K + 2%K`したいので、**ランレングス圧縮**が使える。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc386/b/main.go
:::

## [C - Operate 1](https://atcoder.jp/contests/abc386/tasks/abc386_c)

- 操作 1 は`|S|-|T| = 0`の時、操作 2 は `|S|-|T| = 1`の時、操作 3 は `|S|-|T| = -1`の時に試す価値がある。長さの差分がそれ以外の時は一致させることは不可能。あとはそれぞれの場合を処理。

  - インデックスのズレを記録しながら、長さの短い方を基準にイテレート。

- `|S|-|T| = 1`、`|S|-|T| = -1`のケースは、値を反転すれば同一のケースとして見做せてコード量が減らせる。

- 類題：[358 D - Souvenirs](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---souvenirs)、[376 C - Prepare Another Box](https://zenn.dev/shinonome81/articles/b1de75b0849b32#c---prepare-another-box)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc386/c/main.go
:::

## [D - Diagonal Separation](https://atcoder.jp/contests/abc386/tasks/abc386_d) / グリッド（応用）

- 制約よりグリッドの全探索は無理で、M でループすることが分かる。

- 左上が黒で、右下が白になるように塗り分けられるかどうかということ。つまり、任意のマスが黒で確定している時、それより左上には白は存在してはいけない。逆も然り。

- グリッドを**規則的に**塗ることを考えるので、**入力値（確定マス）ついて、行や列の順に処理した方がいいかどうか検討する。**

- **入力値をソート**して下の行から処理し、最も右にある黒の W を記録、更新。それより左にある白が出現したら`No`で終了。
  - ただし、入力値が白マス、黒マスの順になっていてタイミングの問題で矛盾を検出できないことがあるので、同じ行なら黒を優先するようソートする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc386/d/main.go
:::

---

- **コンテスト中の反省（D）**

  - 行ごとに最も右の黒（左の白）を記録し、列ごとに最も下の黒（上の白）を記録し、各確定マスが矛盾してないかを調べる方針を最初とった。

    - この方針だと、確定黒マスで挟まれたマスも黒マスで確定することから、ある確定マスの処理中にそのマスと同一行、同一列以外の記録スライスも更新しなければいけないことがある。

    - **このようなデータの更新は、いかなるデータ構造（Slice, Map, Ordered Set, Heap, etc...）を持ってしても効率化不可能。方針自体が間違っていることを認識すべき。**

  - 二進数でマスの状態を管理する方法を少し考えたが、白黒空で三種類の状態があるのでそぐわないしトリッキーすぎる。もっと早く考えを切るべき。

# 385

## [A - Equally](https://atcoder.jp/contests/abc385/tasks/abc385_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc385/a/main.go
:::

## [B - Santa Claus 1](https://atcoder.jp/contests/abc385/tasks/abc385_b)

- 愚直
- **grid（二重スライス）に h, w の座標でアクセスする時、`grid[h-1][w-1]`としてインデックスをマイナス 1 するのを忘れない！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc385/b/main.go
:::

## [C - Illuminate Buildings](https://atcoder.jp/contests/abc385/tasks/abc385_c) / 等差数列

- **方針がすぐ思いつかない時は、問題の簡単な部分問題を考える。**

  - 公差 1 の等差数列の最長を求めるには？=> Hi~Hn をループすればいい。
  - 公差 2 の等差数列の最長を求めるには？=> Hi~Hn を 1 個飛ばしでループすればいい。index0 始まりと index1 始まりの 2 回やる。（交差 N も同様）

- 計算量：

  - $O(\sum_{dist=1}^{N-1} N/dist * dist) \simeq O(N^2)$
  - 公差 dist に対して、N/dist の要素をチェックするループを、0~dist-1 インデックス始まりでやる必要がある。結局これは N^2 になる。

- 最長の等差数列を記録する方法：

  - `map[height]count`ではなく、現在続いている等差数列の長さと、今までの最長を保持すれば良いだけ。

- **map は遅いので、複数使っているなら数を減らせないか考える。map ではなくてスライスで済まないか考える。スライスではなくて特定の値の保持で済まないか考える。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc385/c/main.go
:::

## [D - Santa Claus 2](https://atcoder.jp/contests/abc385/tasks/abc385_d) / 二分探索、Ordered Set

- 家の、x 座標ごとの y 座標リスト、y 座標ごとの x 座標リストを持っておけば、サンタの垂直な移動、水平な移動についてそれぞれのデータから**二分探索**によってヒットする家（の数）を見つけることができる。

  - from 以上の二分探索、to より大きいの二分探索を行えばいい。二つの線分や区間の重なりを見つけることに等しい。

- 問題は、家を重複してカウントしてはいけないこと。

  - `var housXYMap, housYXMap map[int][]int`で家を、`var visited map[[2]int]bool`で訪問済みを管理するシンプルな方法だと、二分探索で見つけた区間の要素を列挙し、訪問済みマップに照会、記録するコストが高すぎる。
  - `var housXYMap, housYXMap map[int][]int`で家を管理し、訪問済みの座標を消す場合、垂直の移動で housXYMap から見つけた家を、housYXMap からも消すコストが高すぎる。
  - **スライスから特定の要素を消すコストは高い(二分探索できても、要素を消した後の再構築が O(N)かかる)**

- 家の、x 座標ごとの y 座標リスト、y 座標ごとの x 座標リストに**Ordered Set**を使えば、要素の発見や消去を高速に行える。（どちらも$O(\log N)$）

  - Ordered Set は**平衡二分木**（なんらかの方法で木の高さを均一に保つように制御する二分木）で実装することができる。
  - 構造よりノードを辿ることで**二分探索**ができるため、要素の発見、削除、追加が全て$O(\log N)$で行える。
  - c++の`std::set`がこれ。（`std::multiSet`という要素の重複を許すバージョンもある。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc385/d/main.go
:::

---

- コンテスト中の反省
  - **グリッドの座標と、グリッドのスライスのインデックスは 1 ズレている！**
  - **スライスの初期化時に、レングスを 0 にするのを忘れない！**
  - **オーバーフローが心配になったら、制約からちゃんとマックスの桁数を確認する。**
    - **go の int64 は、`2^63 - 1`、`10^18`まで扱える。**

# 384

## [A - aaaadaa](https://atcoder.jp/contests/abc384/tasks/abc384_a)

- 愚直

## [B - ARC Division](https://atcoder.jp/contests/abc384/tasks/abc384_b)

- 愚直

## [C - Perfect Standings](https://atcoder.jp/contests/abc384/tasks/abc384_c) / 組み合わせ（ビット全探索 or 再帰）、辞書順ソート

- 配列の**部分列**とは、元の配列からいくつかの要素を順番を保ったまま選んで作られる新しい配列。組み合わせの数は$nCr$である。（n:配列の長さ、r:部分列の長さ）

- 配列の**連続部分列**とは、元の配列からいくつかの連続する要素を順番を保ったまま選んで作られる新しい配列。組み合わせの数は$n-r+1$である。（n:配列の長さ、r:部分列の長さ）

- 部分列の列挙は、**ビット全探索**または**再帰関数**の実装で行える。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc384/c/main.go
:::

## [D - Repeated Sequence](https://atcoder.jp/contests/abc384/tasks/abc384_d) / 無限数列、尺取法 or 円環 + 累積和

- 規則的な周期をもつ無限数列の、和が S となる区間を求めたい。和が $S\bmod 一周期分の和$ (以降 remainder と呼ぶ)となる区間を見つければ良い。

- ただし、一周期分の区間を探索するのでは足りない。`[N-1, N, 1, 2]`のような区間があり得るから。

### 解法 1 尺取法

- **二周期分の数列を用意し、そこを尺取法で探索することで全ての区間を探索することができる。**

### 解法 2 円環の性質 + 累積和

- **円環における A to B の距離が x である時、B to A の距離は全周-x である。**

- 一周期分の**累積和**を配列に記録する。配列を左から探索し、それ以前の累積和に以下と一致する値がないかを調べれば良い。

  - $現在の累積和 - remainder$
  - $現在の累積和 - (一周期分の和 - remainder)$

- 類題: [367 D - Pedometer](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---pedometer-%2F-%E5%86%86%E7%92%B0%E3%80%81%E7%B4%AF%E7%A9%8D%E5%92%8C%E3%80%81%E5%90%88%E5%90%8C%E5%BC%8F)、[346 B - Piano](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#b---piano-%2F-%E7%84%A1%E9%99%90%E6%95%B0%E5%88%97%E3%80%81%E5%86%86%E7%92%B0)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc384/d/main.go
:::

## [E - Takahashi is Slime 2](https://atcoder.jp/contests/abc384/tasks/abc384_e) / 優先度付きキュー（ヒープ）

- 倒すことのできる範囲にいる最弱のスライムを倒すことが最善なので、隣接マスのスライムの強さを**優先度付きキュー（min ヒープ）**に入れていく。

- ヒープから取り出した強さが、現在の強さの X 分の 1 未満だったら現在の強さに加算し、更にその隣接ますのスライムの強さもキューに入れる。

- `currentStrength/x > strength`を判定するときに、少数を考えなくて良くするために`currentStrength > strength*x`とすると**オーバーフローする**。
  - `if currentStrength%x == 0 { currentStrength/x > strength } else { currentStrength/x >= strength }`とする。
  - **解放の方針が立ったら、オーバーフローの可能性がないかを確認する癖をつける。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc384/e/main.go
:::

# 383

## [A - Humidifier 1](https://atcoder.jp/contests/abc383/tasks/abc383_a)

- 水量を減らす時にマイナスの数字にしない様に注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc383/a/main.go
:::

## [B - Humidifier 2](https://atcoder.jp/contests/abc383/tasks/abc383_b) / 全探索

- グリッドサイズが 10\*10 と極小なので、**全探索で解くべき**。DFS や BFS より確実にシンプルになる。

- ある配列からの二つの要素の組み合わせは、以下で列挙できる。

  ```go
  for i := 0; i < lne(sl); i++ {
    for j := i+1; j < lne(sl); j++ {
      fmt.Print(sl[i], sl[j])
    }
  }
  ```

- 該当範囲を重複してカウントしないための工夫が必要。
  - 全探索なら、セルがいずれかの加湿器からの**マンハッタン距離**以内かを同時に判定すればいい。
  - DFS、BFS ならカウント済み範囲をグリッド状のデータで保持すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc383/b/main.go
:::

## [C - Humidifier 3](https://atcoder.jp/contests/abc383/tasks/abc383_c) / 多始点 BFS or BFS + メモ化

- max で、グリッドサイズ、始点ノードの数、移動距離が 10^6 なので、全探索は間に合わない。

- 始点ノードから一定距離の条件を満たすノードの探索なので、BFS か DFS。再帰よりキューの方が直感的に書けるので **BFS** が優勢か。

- **BFS または DFS だとしても、移動距離の長さ、始点ノードの多さからなんらかの工夫をしないと間に合わない。**

### 多始点 BFS

- 複数の始点を持つ BFS においては、最初に全ての始点をキューに入れて探索をすれば、visited を共有することができ効率的な探索ができる。これを**多始点 BFS**という。（DFS ではこれはできない。）

### BFS + メモ化（※ 多始点 BFS の方が簡単なのでそっちでいい）

- ある始点ノードからの探索において別の始点ノードに到達した場合、そこから先は探索しなくていい。その始点からの BFS に内包されている範囲だから。

- これを拡張すると、別の始点からの探索で訪問済みのノードにある始点からの探索で到達した時に、残り移動回数がより少ない状態で到達していた場合そこからはもう探索しなくて良い。このデータを**メモ化**すれば効率化可能。
  - （メモは visited の役割も兼ねることが可能。visited を別のデータで保持してアクセスする実装だと TLE になった。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc383/c/main.go
:::

## [D - 9 Divisors](https://atcoder.jp/contests/abc383/tasks/abc383_d) / 整数問題（いい数の個数）、素因数分解、巨大な数

- [解説](https://atcoder.jp/contests/abc383/editorial/11508)

- **約数の個数の性質**

  - $p_1^{r_1}*p_2^{r_2}*...*p_k^{r_k}$に因数分解される整数の約数の個数は、$(r_1+1)(r_2+1)...(r_k+1)$個である。

- 素因数分解には素数が必要なので、あらかじめ任意の数以下の素数を列挙できるライブラリを用意しておく。

- 条件にあてはまる数の素因数分解に含まれる素数は、$\sqrt{N}$以下である。（もっと小さいが。）

  - **素数の列挙は計算コストが重いので、条件を狭めておく必要がある。**

- **巨大な数の操作は`int`, `int64`だとオーバーフローする可能性があるので、`math.Big`を使うか、ルートにして扱うことを考える。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc383/d/main.go
:::

# 382

## [A - Daily Cookie](https://atcoder.jp/contests/abc382/tasks/abc382_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc382/a/main.go
:::

## [B - Daily Cookie 2](https://atcoder.jp/contests/abc382/tasks/abc382_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc382/b/main.go
:::

## [C - Kaiten Sushi](https://atcoder.jp/contests/abc382/tasks/abc382_c) / 二分探索

- $N*M$ が 20 万の 2 乗なので、計算の効率化が必要。寿司ごとに誰が食べるかは判定しなくてはならないので、M（寿司） ではなく N（人）のループを無くしたい。
- ある数字以下の数字（美味しさ以下の美食度）を見つける必要があるので、**二分探索**が使えそう。
  - 美食度の並びについて、**単調減少**を満たすようにできないか？
  - k 番目の人の美食度が、それまでの人の美食度の中で minimum ではない場合、その人は何も食べられない。
  - これを利用して美食度の並びに対し、それまでの minimum でない値は、minimum に書き換える操作を行い、二分探索が使えるようにする。

:::details code
ちょっと違う変な周りくどいやり方をしていた。
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc382/c/main.go
:::

## [D - Keep Distance](https://atcoder.jp/contests/abc382/tasks/abc382_d) / DFS（数列）

- パターンの列挙
- **存在しうるパターンが木構造で表現できるので、パターンの列挙は DFS で可能**
- DFS の一段目はちょっと特殊なので、そこだけ再帰関数の外に出してもいい。
- 再帰関数 \* Go のスライスだと予期せぬ影響が起きかねないので、スライスを引数に渡すときは`make()`や `copy()`でコピーを作って渡した方が良い。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc382/d/main.go
:::

# 381

## [A - 11/22 String](https://atcoder.jp/contests/abc381/tasks/abc381_a)

- 愚直
- **問題文で、数式が連続する複数行に書かれているとき、一部が重なっていて読み間違えることがあるので注意！**
- 条件が箇条書きで書かれている時、**条件のチェックはその数だけ必要！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/381/A/main.go
:::

## [B - 1122 String](https://atcoder.jp/contests/abc381/tasks/abc381_b)

- 文字種のカウントの条件と、同じ文字種の連続の条件を別々にチェック

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/381/B/main.go
:::

## [C - 11/22 Substring](https://atcoder.jp/contests/abc381/tasks/abc381_c)

- 特定の文字種の連続を考えたいので**ランレングス圧縮**。
- 条件を満たす区間の最長を求めるので**尺取法**も使えそうだが、**区間が条件を満たさなくなった時に左端を動かしても満たすようにできないので、使えない。**

:::details code
Substring の最長の文字列を求めるのに、スライスで保持して後で比較するのではなく、現在の最長を記録・更新する方がパフォーマンス良かった。
https://github.com/Tomoki108/go-algo/blob/main/ABC/381/C/main.go
:::

## [D - 1122 Substring](https://atcoder.jp/contests/abc381/tasks/abc381_d) / 尺取法

- 条件を満たす区間の最長を求めるので**尺取法**が使えそう。以下の性質から、利用可能なことがわかる。
  - 空配列も条件を満たすので、区間が条件を満たさなくなった時に左端を動かして満たすようにできる。
  - ある区間が条件を満たすかどうかは、含まれている要素の種類の記録と、追加した２つの要素が同じかどうかの比較から簡単に判定できる。
- **区間をどのように伸長すべきか考える。** 1122 String は 2 連続する異なる文字種から構成されるので、2 づつ伸長する。
- 偶数インデックス始まりの区間は偶数インデックス始まりの区間にしか変化できず、奇数についても同じ。なので**インデックス 0 から始めるチェックとインデックス 1 から始めるチェックを２段階でやる。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/381/D/main.go
:::

# 380

## [A - 123233](https://atcoder.jp/contests/abc380/tasks/abc380_a)

- 文字列のカウント

:::details code
文字列として入力を受け取って、split にしてスライスにした方が良かった。
https://github.com/Tomoki108/go-algo/blob/main/ABC/380/A/main.go
:::

## [B - Hurdle Parsing](https://atcoder.jp/contests/abc380/tasks/abc380_b)

- 愚直
- 特定の文字列の連続を考えたいので、**ランレングス圧縮**でも良かった

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/380/B/main.go
:::

## [C - Move Segment](https://atcoder.jp/contests/abc380/tasks/abc380_c) / ランレングス圧縮

- 特定の文字列の連続を考えたいので、**ランレングス圧縮**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/380/C/main.go
:::

## [D - Strange Mirroring](https://atcoder.jp/contests/abc380/tasks/abc380_d) / 二進数（ポップカウント）、回文

- S が複数文字だと考えづらいので、1 文字の場合を考える。（後で、その考えを応用するために S が何セットあるのかで考える。）
- 桁数が倍々になっていくので、**2 進数**が使えないか考える。そして**ポップカウント**や**ビット演算**が使えないかどうか考える。
- 桁数の二進数表記の最も左側の１が右から何桁目にあるのかで何回倍にしたのかが分かるようにしたいので、最初のセットを 0 セット目として考える。**2 進数で数字を管理する場合、最初の数字は 0 とおいた方が良いことが多い。**
- 桁数の二進数表記から、一番左の 1 を消すと反転の元となった桁数になる。よって何回反転前の桁数にいくと一番最初の 0 桁目になるのかが、**ポップカウント**で求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/380/D/main.go
:::

## [E - 1D Bucket Tool](https://atcoder.jp/contests/abc380/tasks/abc380_e) / Union Find

- 隣接するマスの色が同じになったら、以降はそれらは一つのグループになり色が同期する。グループの管理なので**Union Find**。

  - 厳密には、隣接する"グループ"の色が同じになったらそれらがマージされる。よってグループの色、右端、左端のインデックスを別で管理する必要がある。
    - `var colors,ls, rs []int // rootNodeIdx -> color, r_idx, l_idx`
    - （マージで吸収されたグループルート i の`colors[i], ls[i]`, `rs[i]`は、削除の印をつける更新などをしなくても以降参照されないので問題ない。）

- またクエリ 2 で特定の色のカウントを出力する必要があるので、色ごとのカウントも保持しておく。

  - `var colorsCount map[int]int`

- クエリでループし、色ごとのカウントを増減させる。隣り合うグループとのマージ判定、マージを行い、それに伴うグループの色、右端、左端のインデックスを更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc380/e/main.go
:::

# 379

## [A - Cyclic](https://atcoder.jp/contests/abc379/tasks/abc379_a)

- 整数の特定の桁の数を取り出す

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/379/A/main.go
:::

## [B - Strawberries](https://atcoder.jp/contests/abc379/tasks/abc379_b)

- 計算量少ないので愚直
- **問題文の X(large x), x(small x), 0(zero), O(large o), o(small o)が見分けづらいので注意！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/379/B/main.go
:::

## [C - Sowing Stones](https://atcoder.jp/contests/abc379/tasks/abc379_c)

- **入力値がソートされていそうでソートされていないことがあるので注意。入力例のみ偶々ソートされていることもある。**
- **数列の和の公式** $(A_i+A_n)*N/2$
  - ループせずに和が求められる
- 条件が成立することのチェック、求めたい値を求めることを分けて考える。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/379/C/main.go
:::

## [D - Home Garden](https://atcoder.jp/contests/abc379/tasks/abc379_d) / 遅延評価

- **遅延評価**

- **二分探索**
  - 二分探索は**単調非減少性**を満たすようにソートされていないと使えない。（`condition(arr[i]) == true なら condition(arr[i+1]) == true`を満たす。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/379/D/main.go
:::

## [E - Sum of All Substrings](https://atcoder.jp/contests/abc379/tasks/abc379_e) / シグマ、巨大な数

- 明らかに INT_MAX を超える数が出てくるが、**多倍長整数**を使うと TLE する。

  - **桁数 N の A と B を演算するとして、加算減算は $O(N)$、乗算徐算は $O(N^2)$　かかる。**

- 扱う数字を INT_MAX 以下に抑える方法として、答えの 1~最終桁を独立して求めて、最後に出力して繋げる方法がある。
  - **筆算の様に考える。**
  - 一桁目の数字は、足し算に使われる数の 1 桁目の和による。2 桁目の数字は、左記の和の繰り上げ分と、足し算に使われる数の二桁目の和による。...。

```
ex, 3 7 9

      3
      7
      9
    3 7
    7 9
+ 3 7 9
--------
 3 17 44
     514
```

- 足し算に使われる数の k 桁目の和を高速に求められればいい。以下の例から、 N 桁目の数字の和から順に 1 桁目の数字の和を求めていける。`var digitSum []int // N桁目の数の和, N-1桁目の数の和, ... 1桁目の数の和`

  - $1桁目の数字の和 = 3*1 + 7*2 + 9*3$
  - $2桁目の数字の和 = 3*1 + 7*2$
  - $3桁目の数字の和 = 3*1$

- あとは`digitSum`を反転してループして、**繰り上げ分を上の桁に渡していけばいい。**

  - `digitSum[i+1] += digitSum[i] / 10;	digitSum[i] %= 10;`

- この時、最終的な桁数は N 以上になるので `digitSum` の length（=最終的な答えの桁数）をどうするのかという問題がある。
  - 最も大きくなる`digitSum[i]`は、1 桁目の和の`digitSum[0]`
    - $10 * (1 + N)*N/2 \simeq 10*N^2 \simeq 10^{11}$
      - 簡素化のために最大の数字として 9 ではなく 10 を使用、N の最大値に 10^5 を使用。
      - これから`digitSum[i]`が**オーバーフロー**しないことも分かる。
    - これが N 個あるとして、$10^{11} * 10^5 = 10^{16} = 17桁$。つまり、N 桁目から 17 回程度繰り上がるだけ。十分な数 の 0 をバッファとして `digitSum` に append しておく。最後に余分なゼロはトリムする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc379/e/main.go
:::

# 378

## [A - Pairing](https://atcoder.jp/contests/abc378/tasks/abc378_a)

- 何ペア作れるか = ペアになりうる要素の数 / 2

:::details code
変なやり方で解いてた：
https://github.com/Tomoki108/go-algo/blob/main/ABC/378/A/main.go
:::

## [B - Garbage Collection](https://atcoder.jp/contests/abc378/tasks/abc378_b)

- 割り算、余り、場合分け

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/378/B/main.go
:::

## [C - Repeating](https://atcoder.jp/contests/abc378/tasks/abc378_c)

- メモ化？（後で比較に使う要素をあらかじめ記録）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/378/C/main.go
:::

## [D - Count Simple Paths](https://atcoder.jp/contests/abc378/tasks/abc378_d) / DFS（グリッド）

- **グリッド**
- **DFS**
  - 「探索済みノードを記録するマップ（グローバル変数）」「探索の深さ（グローバル変数）」「探索を行う再帰関数」で行う。
  - 「探索を行う再帰関数」では開始ノード、現時点の探索の深さを引数に取る。隣接ノードでループをし、その中で再帰する。関数が呼び出し元に戻るときに、探索済みノードのマップをリセットする。
- グリッド内の条件を満たす経路の**個数**を求める問題なので DFS。
  - BFS と比べて、キューを使わずに死路を早く切れるのでメモリが少なく済み、再帰処理で簡潔にかける。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/378/D/main.go
:::

# 377

## [A - Rearranging ABC](https://atcoder.jp/contests/abc377/tasks/abc377_a)

- 文字列並び替え
- 文字列 A を同じ文字数の B に並び替えられるかどうかは、B に含まれる各文字種のカウントと、A に含まれる各文字種のカウントが一致しているかどうか。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/377/A/main.go
:::

## [B - Avoid Rook Attack](https://atcoder.jp/contests/abc377/tasks/abc377_b)

- **グリッド**
- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/377/B/main.go
:::

## [C - Avoid Knight Attack](https://atcoder.jp/contests/abc377/tasks/abc377_c)

- **グリッド**
- グリッドサイズが大きいので、セルではなくより数が少ない駒の位置でループを回す

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/377/C/main.go
:::

## [D - Many Segments 2](https://atcoder.jp/contests/abc377/tasks/abc377_d)

- 区間が登場する問題だが、**尺取法は使えない。** 有効な区間を見つけたときに、**左端を動かすことでも新たに有効な区間を見つけられる可能性があるため。**
- **2 つの数字の組み合わせの個数を考える問題だが、1 つの数字を固定し、それに対して何通りのペアが考えられるか（0 通りでも OK）を考えるのが筋がいい。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/377/D/main.go
:::

# 376

## [A - Candy Button](https://atcoder.jp/contests/abc376/tasks/abc376_a)

- 愚直

## [B - Hands on Ring (Easy)](https://atcoder.jp/contests/abc376/tasks/abc376_b) / 円環

- **円環**
- 1 と N が隣合う所が含まれる範囲だと都合が悪いので、回転させて含まれない範囲にする
- 始点と終点を入れ替えても問題ないなら 始点 < 終点 になるように入れ替える（考えやすくなる。パターンも減る。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/376/B/main.go
:::

## [C - Prepare Another Box](https://atcoder.jp/contests/abc376/tasks/abc376_c)

- 二つの配列を同時にイテレート。特定のタイミング以降インデックスがズレるのに注意。

- [類題：358 D - Souvenirs](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---souvenirs)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/376/C/main.go
:::

## [D - Cycle](https://atcoder.jp/contests/abc376/tasks/abc376_d) / BFS（有向グラフ）

- **BFS**
  - 「探索済みノードを記録するマップ」「次にどのノードを起点に隣接を探索すべきかを記録するキュー」を使う。
- 単純有向グラフ（自己ループなし、同じ方向の辺の重複なし）
  - `edges := make(mmap[int][]int) // 各頂点からどの頂点へ辺が伸びているか`
- ある頂点を通る閉路を見つけるには、その頂点から始めて、その頂点へ向く辺が伸びている頂点に到達するまで探索する。**最短距離**の閉路の距離を求める問題なので BFS。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/376/D/main.go
:::

## [E - Max × Sum](https://atcoder.jp/contests/abc376/tasks/abc376_e) / ヒープ

- A の**最大値という概念が出てくるので、As をソートすると良さそう。**

  - この時`type AB struct {int, int}`のペアを作った後に ABs を A の値で昇順ソートすると、maxA がある値（`ABs[i].A`）であるときに`ABs[i]`以降の`ABs[j].A, B`が使えないことがわかる。`maxA == ABs[i].A`の前提が崩れるため。

- **maxA を固定し、順に試す**ことを考える。
  - 使える B の中で、K 個の合計が最小となる B の組み合わせのを考えたい。使える B が A を試すごとに増えていき、その中の最小の K 個の合計を出したい。これは**最大ヒープ**を使えば実現できる。
  - A を昇順に試し、使える B をヒープに足していく。ヒープのサイズが K 以下なら continue、K より大きいなら最も大きな B を`PopI()`で捨てる。ヒープ内の合計を記録しておき、`PushI()`, `PopI()`の時に更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc376/e/main.go
:::

# 375

## [A - Seats](https://atcoder.jp/contests/abc375/tasks/abc375_a)

- 全探索

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/375/A/main.go
:::

## [B - Traveling Takahashi Problem](https://atcoder.jp/contests/abc375/tasks/abc375_b)

- 愚直に計算
- べき乗の計算は`math.Pow()`でやるとズレるので、2 乗程度なら掛け算でやる

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/375/B/main.go
:::

## [C - Spiral Rotation](https://atcoder.jp/contests/abc375/tasks/abc375_c) / グリッドの回転

- 正方形グリッドの**回転**
- 正方形グリッドの周のレイヤー
  - 今回の問題では、一番外側のレイヤーのセルは一回 90° 回転、二番目のレイヤーのセルは二回 90° 回転、...。ということになる。
- 問題のタイトルがヒント

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/375/C/main.go
:::

:::details 補足

**※ h, w は 0-indexed**

### 正方形グリッドの回転

- 座標(h, w)は、一辺 N の正方形グリッドを 90 度回転させると(w, N-h-1)に移動する。

![image](/images/ABC/375/375_C.png)

### 正方形グリッドの周のレイヤー

- 一辺 N の正方形グリッドの一番外側の周のマスを 1 周目、二番目に外側の周のマスを 2 周目、...とした時に、マス目(h, w)が何周目かは `min(h+1, w+1, N-h, N-w)`となる。
  - 左下から右上に対角線を引くと左側のエリアのマスについては、`min(h+1, w+1)`周目となる。
  - 右側のエリアは左側のエリアの線対象な位置のマスと同じ週目になるので、`min(N-h, N-w)`周目となる。
  - 対角線が通っているマスはどちらでも同じ。
  - 注：以下画像は h, w が 1-indexed。

![image](/images/ABC/375/IMG_4988.png)

:::

## [D - ABA](https://atcoder.jp/contests/abc375/tasks/abc375_d) / メモ化

- **メモ化**
- N が巨大なので計算量を O(N)にする工夫

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/375/D/main.go
:::

# 374

## [A - Takahashi san 2](https://atcoder.jp/contests/abc374/tasks/abc374_a)

- `strings.HasSuffix()`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc374/a/main.go
:::

## [B - Unvarnished Report](https://atcoder.jp/contests/abc374/tasks/abc374_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc374/b/main.go
:::

## [C - Separated Lunch](https://atcoder.jp/contests/abc374/tasks/abc374_c) / ビット全探索

- N 個の部署が、A、B いずれかのグループに属するので、パターンは $2^N$。起きうるパターンが $2^N$ で N が現実的な範囲のため、**ビット全探索**。
- `for i := 0; i < 1<<N; i++` でループし、各桁が 1 かどうかで各部署のグループ分けを決めれば全パターン試せる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc374/c/main.go
:::

## [D - Laser Marking](https://atcoder.jp/contests/abc374/tasks/abc374_d) / 全探索、DFS（順列）、ビット全探索

- パターン数は、線の順列パターン \* 各線をどちらから始めるか：$O(N! * 2^N)$

  - Max：$O(6! * 2^6) = O(46080)$
  - 十分に少ないので、**全探索**できる。

- 順列のパターン（木構造になっている）は、**DFS**で列挙できる。
- 各線をどちらか始めるかは、**ビット全探索**で列挙できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc374/d/main.go
:::

# 373

## [A - September](https://atcoder.jp/contests/abc373/tasks/abc373_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc373/a/main.go
:::

## [B - 1D Keyboard](https://atcoder.jp/contests/abc373/tasks/abc373_b)

- 問題文をよく読む（キー配列が S で固定なのか AtoZ 固定なのか、最初逆で認識していた。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc373/b/main.go
:::

## [C - Max Ai+Bj](https://atcoder.jp/contests/abc373/tasks/abc373_c)

- ソート

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc373/c/main.go
:::

## [D - Hidden Weights](https://atcoder.jp/contests/abc373/tasks/abc373_d) / BFS or DFS（有向グラフ）

- ある２点とその辺について、辺の向きに関わらず一方の点の値が分かっていれば他方の点の値が分かる。

  - $toX - fromX = weight$ から $fromX - toX = -weight$ が成り立つため。
  - `var weights map[int][][2]int`のように重みを記録し、from => to だけではなく to => from の重みも記録する。**有向グラフであることに囚われすぎない。**

- あとは**DFS**でも**BFS**でも列挙可能。

- **map の初期化、要素へのアクセスより、スライスの初期化、要素へのアクセスの方が大分高速。**

- **サンプルが複数あるときは、それぞれが重要な示唆を持つ可能性があるので、できる限りそれぞれ図を書く。**

  - 今回も孤立ノードや、どこからも辺が向いていないノードのパターンを教えてくれていた。

- **問題タイトルがヒント**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc373/d/main.go
:::

# 372

## [A - delete .](https://atcoder.jp/contests/abc372/tasks/abc372_a)

- 愚直

## [B - 3^A](https://atcoder.jp/contests/abc372/tasks/abc372_b) / 整数問題（いい数を見つける）、N 進数 or 貪欲法

- 2 進数以外の N 進数ではビット演算が使えないものの、**実装で N 進数表記を使ったり、考察パートで N 進数の考えを使ったりすることがある。**

- M を 3 進数表記すると、3 の乗数の足し算で M を表現していることになる。

- 後は 3 進数の桁を 0 桁目からループしていき、桁の数字の数だけ桁数 k を ans 配列に追加していけば、答えになる。

- あるいは、M に対して 3 の 10 乗（制約上のマックスの乗数）を可能な限り引く、3 の 9 乗を可能な限り引く...という様にして解いても良い。（**貪欲法**）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc372/b/main.go
:::

## [C - Count ABC Again](https://atcoder.jp/contests/abc372/tasks/abc372_c)

- 全探索は$N * Q = 4^{10}$なので間に合わない。Q 個のクエリを順に処理することは確定なので、N のループをなくす。

- 「ABC 部分文字列がある場所をマップに保存しておいて、クエリ処理時の探索に使う」でもいいし、「ABC 部分文字列の数を保存しておいて、クエリ処理時に毎回影響を受ける範囲を探索する」でもいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc372/c/main.go
:::

## [D - Buildings](https://atcoder.jp/contests/abc372/tasks/abc372_d) / スタック

- **探索すべきものの条件について、直感的な概念に言い換えることができることも多い。**　今回は、ビル i に対するビル j は、ビル i の前方に見えるビル。

- **前からの処理が難しそうなら、後ろからの処理を考える。**

- ビル i に対するビル j の高さの配列を考える。これは単調増加である。

- 後ろから処理していき、ビル i に対してビル i+1~ビル n で単調増加な配列を作ることを考える。データに対しビル i+1 を追加していき、その際事前にビル i+1 より低いビルを削除していけばいい。

- 最後に追加したデータから取り出して削除するということなので、**スタック**が使える。**スライスからデータを削除するコストは$O(len(sl))$** なので、スライスは使わない。削除回数は最大 N なので、$O(N)$で処理できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc372/d/main.go
:::

## [E - K-th Largest Connected Components](https://atcoder.jp/contests/abc372/tasks/abc372_e) / Union Find、ヒープ

- 連結成分を高速に判定する必要があるので、**Union Find**を使う。また、各連結成分に属する頂点番号を大きい順に保持したい。

- ソートを保ったまま高速に要素の追加ができるデータ構造として**Oredered Set**や**ヒープ**がある。

  - ここで、制約より K の上限が 10 でありとても小さいことに注目する。つまり連結成分ごとのノードは、大きいものから順に 10 個までしか保持しなくていい。
  - 要素の削除が $O(log N)$ かかる Set より、$O(1)$ で済むヒープが適切。

- 実装
  - Union Find、ルートごとの頂点の最小ヒープ（頂点を捨てる時は最も小さい頂点番号のものを捨てたいため）`var rootNodes []IntHeap`を作る。
  - クエリ 1 では頂点同士を`Union()`する。ルートでは無くなる頂点が発生するので、そちらのヒープから生き残ったルートのヒープに要素を移動させる。その後ヒープの要素が 10 以下になるまで要素を捨てる。
  - クエリ 2 では指定頂点のルートを判定し、そちらのヒープから K 個目に大きい頂点番号が出るまで順に`PopI()`する。（最小ヒープのためやりにくいが頑張ればできる。）その後入れ直す。
  - $O(Q)$ // Union Find の操作やヒープの操作は軽いので雑に無視。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc372/e/main.go
:::

# 371

## [A - Jiro](https://atcoder.jp/contests/abc371/tasks/abc371_a)

- 大小関係、愚直

- 頭だけで考えると絶対混乱するので、紙に書いて整理する（パターン：$2^3$）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc371/a/main.go
:::

## [B - Taro](https://atcoder.jp/contests/abc371/tasks/abc371_b)

- 愚直

## [C - Make Isomorphic](https://atcoder.jp/contests/abc371/tasks/abc371_c) / 無向グラフ、順列、全探索

- **無向グラフ A、B が同型とは、** A の頂点 1, ... N に対し、B の頂点 1, ...N を任意の順番で一対一対応させ、Ai - Aj 間の辺の有無と Bi' - Bj'間の辺の有無が全て一致している対応が存在するということ。

  - 頂点数は同じである必要がある。
  - 頂点の対応のパターンは、頂点の**順列**（N!）で列挙できる。

- **無向グラフをデータとして保存するときは、Ai - Aj と Aj - Ai を両方記録する。片方しか記録せず、後で計算量節約できるかもなどと考えるとおかしなことになる。（今回なった。）**

  ```go
  var graph map[int][]int
  a, b := read2Ints(r)
  graph[a] = append(graph[a], b)
  graph[b] = append(graph[b], a)
  ```

- 計算量：グラフ G の頂点とグラフ H の頂点の対応 _ 6 頂点 _ 隣接頂点の diff：$O(6! * 6 * 5) =  O(21600)$
  - **全探索**可能

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc371/c/main.go
:::

## [D - 1D Country](https://atcoder.jp/contests/abc371/tasks/abc371_d) / 累積和、二分探索

- 区間[L, R]の人口 = 「R 以前の R に最も近い村までの人口**累積和**」-「L より前の村までの人口**累積和**

- 「R 以前の R に最も近い村」「L より前の村」は**二分探索**で見つけられる。

  - 前者は累積和のスライスを逆順にしたものを用意し探索できる。

- 二分探索の条件や、結果を元にした場合分けをしっかり考える。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc371/d/main.go
:::

## [E - I Hate Sigma Problems](https://atcoder.jp/contests/abc371/tasks/abc371_e) / シグマ、区間問題

- そのままの式では TLE になるため、**別の方向からのシグマの式にすることを考える。**

- 登場するすべての数字について、それが登場する区間の個数を数えられればそれが答えになる。（結果的にすべての区間について、登場する）

  - $\sum_{x} countSec(x)$
  - **N 個の要素の部分区間の取り方は、$_{N+1} C_2$**
    - 先頭の前と末尾の後ろと各要素の間に、二つ仕切りを置くことに等しい。

- 「ある数字 x が**1 個以上**登場する区間」は数えるのが困難なため、**余事象**の x が 1 個も登場しない区間を考える。

- ` var numIndexes map[int][]int`を作成しておけば、`index[i]+1 ~ index[i+1]-1`の区間が x が全く登場しない区間ということになる。
  - 最初のインデックスの手前、最後のインデックスの奥のセクションを考えたいので、prevIdx を-1 で初期化し、あらかじめ indexes に N を append しておくと上手くいく。

---

- **累積和**や**差分配列**ではこの手の問題は解けない。
  - 『一般に「累積和」「差分配列」でうまくいくのは、“区間に対する和(または差)が線形的に分割できる”タイプの量です。たとえば「区間の要素の総和」など。「異なる値の種類数」は「単にどこかの部分区間を足して、どこかの部分区間を引けば答えが出る」という形にはなりません。』

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc371/e/main.go
:::

# 370

## [A - Raise Both Hands](https://atcoder.jp/contests/abc370/tasks/abc370_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc370/a/main.go
:::

## [B - Binary Alchemy](https://atcoder.jp/contests/abc370/tasks/abc370_b)

- 愚直、命名をちゃんとやると混乱しない

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc370/b/main.go
:::

## [C - Word Ladder](https://atcoder.jp/contests/abc370/tasks/abc370_c)

- 文字の辞書順
  - 文字は辞書順で比較可能：`"a" < "b" // true`
  - アルファベットはこの様にイテレート可能(今回は使ってないが)：
    ```go
    // 'a' の文字コード: 97, 'z' の文字コード: 122
    for ch := 'a'; ch <= 'z'; ch++ {
      fmt.Println(string(ch))
    }
    ```
- 必要な変更を列挙。辞書順を早める変更と、遅める変更に分ける。先に前者を適用する。そして後者について、元の文字列の後ろの方から変更した方が辞書順の悪化が少なく済むので、逆順にソートしてから適用する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc370/c/main.go
:::

## [D - Cross Explosion](https://atcoder.jp/contests/abc370/tasks/abc370_d) / メモ化

- $max(H*W)=4*10^5$より、正方形グリッドで考えると 600\*600 程度。一度のクエリに対し、最悪縦横全てで 1200 確認する必要がある。クエリは 20 万個なので、$O(2400万)$となり**全探索**で間に合いそうだが...

- 40 万 \* 1 の様なグリッドで、20 万回同じ箇所を爆破する様な場合を考えると、計算量は数列の和の公式より$(1+20万)*20万/2 = 約20億$となり、間に合わない。

- **メモ化**を利用し、ある座標から上下左右を探索したときに、どこまで空マスが続いたかを記録し、次回以降の同じ座標の探索時に利用する。

- **（後半の）問題の計算量があまりに少なそうに思えたら、エッジケースで計算量が増大しないか考える。誤答のペナルティは重い。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc370/d/main.go
:::

# 369

## [A - 369](https://atcoder.jp/contests/abc369/tasks/abc369_a)

- A, B, x の配置と、`A == B` と `A != B` である場合の場合分けを考えて、コードに落とし込む。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc369/a/main.go
:::

## [B - Piano 3](https://atcoder.jp/contests/abc369/tasks/abc369_b)

- 右手と左手の位置を記録しながら、コストを足していく。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc369/b/main.go
:::

## [C - Count Arithmetic Subarrays](https://atcoder.jp/contests/abc369/tasks/abc369_c)

- 有効な区間の数を求める問題とも言えるが、有効な区間から左端を動かすことでも新たな有効区間を見つけることができるので、**尺取法**は使えない。

- left, right を記録していき、探索する。右端を increment するループ。

  ```go
  left := 0
  right := 0
  ans := 1
  for right = 1; right < N; right++ {}
  ```

- 探索で等差数列の長さが順調に伸びていく場合を考えると、長さが伸びる度に組み合わせが現在の範囲の長さ分増えることが分かる。**図を書くと分かる。**

- **重要なのは右端を伸ばして、等差数列が破綻した時に左端と右端をどこの位置にするのかということ。** 左端を右端-1 のところに移動させ、長さ 1 の状態から 1 伸びた場合の様にすればいい。あとはうまくコードに落とし込むだけ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc369/c/main.go
:::

## [D - Bonus EXP](https://atcoder.jp/contests/abc369/tasks/abc369_d) / DP（テーブル）

- 全てのモンスターの倒す倒さないのパターンは$2^N$なので、全探索は無理。

- 1 体目のモンスターまで処理した時の最大経験値を記録、それを元に 2 体目のモンスターまで処理した時の最大経験値を計算し記録...ということができないか？この様な考え方が**DP（動的計画法）**。

- k 体目のモンスターを処理する時の経験値の変動は、そのモンスターが偶数体目の討伐対象か、奇数対目の討伐対象かによる。(倒す倒さないの選択もあるが。)これは、k-1 対目まで処理した時点で、偶数体討伐済みか奇数体討伐済みかと言い換えることもできる。

- 以下の DP テーブルを作成することで問題が解ける。**値から次の列の値を求めるために、どんな状態を記録する必要があるかを考え、DP テーブルの設計をする必要がある。**　この設計が DP で一番難しい。

  - 縦：偶数体討伐済み or 奇数対討伐積み
  - 横：何体目まで処理したか
  - セルの値：その状態での最大経験値

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc369/d/main.go
:::

# 368

## [A - Cut](https://atcoder.jp/contests/abc368/tasks/abc368_a)

- **スライスの操作**

  ```go
  //「index x-1まで」「x番目まで」
  // xにはlen(sl)まで渡すことが可能！
  // sl[0] ~ sl[x-1],
  sl[:x]

  //「index xから」「x+1番目から」
  // sl[x] ~ sl[len(sl)-1]
  sl[x:]
  ```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc368/a/main.go
:::

## [B - Decrease 2 max elements](https://atcoder.jp/contests/abc368/tasks/abc368_b)

- 数列の長さ N、要素の上限値 Ai が 100 なので、**全探索可能**。変に効率化を考えずに愚直にやる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc368/b/main.go
:::

## [C - Triple Attack](https://atcoder.jp/contests/abc368/tasks/abc368_c) / 割り算

- 敵の数 N の大きさ、体力 Hi の大きさから、愚直に一回ずつ攻撃する方法だと間に合わない。

- 3 回ごとに 5 ダメージを与えられる。

  - $体力/5$ で、何回攻撃する必要があるかが求まる。
  - $商 * 5 + (余りに対して必要な攻撃回数)$

- 重要なのは余りに対して必要な攻撃回数を求めることで、「その敵に対する最初の攻撃が通算何回目の攻撃か」「余りがいくつか」によって変わってくる。
  - **分岐が多いので、switch case で書くと分かりやすく書ける。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc368/c/main.go
:::

## [D - Minimum Steiner Tree](https://atcoder.jp/contests/abc368/tasks/abc368_d) / 木、DFS（ノードカウント）

- [解説](https://www.youtube.com/watch?v=n1QdxjxIf2o&t=2740s)

- **木**とは、「閉路」の無い「単純連結無向グラフ」のことである。

  - 「単純」とは、自己ループや多重辺がないこと。
  - 「連結」とは、 任意のノード２点に対して１つ以上の経路が存在すること。
  - 「閉路」が無いことから、**任意のノード２点に対して経路が必ず 1 つだけ存在する。（木の性質）**
  - **頂点数 N の木の辺の数は、N-1 である。**
  - 頂点の隣接ノード数のことを **「頂点の次数」** という。
  - **木は、任意の頂点をルートノードとする階層構造として捉えることができる。**
  - 木構造における **「葉」** とは、子ノードを持たない木構造の最も末端に位置するノードのこと。
  - 木構造も、通常の隣接リストに格納できる。

- 任意の指定された頂点をルートとし、葉の階層から順に指定されていないノード、次数が 1 のノードを削除していくと、指定のノードが全て含まれた最小の**部分木**になる。なぜなら、指定されたノードと、ルートと指定されたノードを繋ぐために必要なノードしか残らないから。

- 上記の方法は木を変形させながら探索せねばならず難しいので、別の方法を考える。

  - 要は、自身のノード以下に指定のノードが存在しないノードは削除可能。
  - 任意の指定された頂点からの DFS で、葉に到達したら return。その過程で`var numOfPicked map[int]int // そのノード以下の階層に、指定された頂点がいくつ含まれているか`を埋めていき、最後にマップのゼロ以外の要素をカウントすれば答えとなる。

- 類題：[333 D - Erase Leaves](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#d---erase-leaves-%2F-%E6%9C%A8%E3%80%81dfs%EF%BC%88%E3%83%8E%E3%83%BC%E3%83%89%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%EF%BC%89%E3%80%81%E7%B4%AF%E7%A9%8D%E5%92%8C)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc368/d/main.go
:::

# 367

## [A - Shout Everyday](https://atcoder.jp/contests/abc367/tasks/abc367_a)

- 数直線を書いて場合分け

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc367/a/main.go
:::

## [B - Cut .0](https://atcoder.jp/contests/abc367/tasks/abc367_b)

- 数字を文字列として受け取る

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc367/b/main.go
:::

## [C - Enumerate Sequences](https://atcoder.jp/contests/abc367/tasks/abc367_c) / DFS（数列）

- 長さ N であり、i 番目の要素が`[1, ..., Ri]`のいずれかである数列を列挙し、その数列に対して総和が K の倍数であるかどうかをチェックすればいい。

- 上記の数列のパターンはグラフ構造で表せるため、**DFS**で列挙可能。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc367/c/main.go
:::

## [D - Pedometer](https://atcoder.jp/contests/abc367/tasks/abc367_d) / 円環、累積和、合同式

### 円環

- **1, 2, ...N, 1 という円環がある時、1~N の数直線で、全ての区間の距離を列挙することができる。**

- 円周の距離を`C`とすると、地点 a から b までの距離 x と、地点 b から a までの距離 y（a < b）の関係は、$y = C - x$ となる。

- 1~N の数直線で任意の地点 a から b までの距離を列挙でき、その$C-x$を取れば地点 b から a の距離を列挙できる。

### 累積和

- 数直線上から２点間の距離を素早く出すために、距離の**累積和**が使える。

### 合同式

- x - y が M の倍数になるのはどんな場合か？

  - **$x \equiv y \mod M$の時である。**
  - $(M*i + a) - (M*j + a) = M(i-j)$ となり、M の倍数であることが保証される。

- よって、累積和の数直線上を順に探索していき、現在の累積和より前の累積和で、mod M で合同なものがいくつあるのかを数えて答えに足していけばいい。

  - `var m map[int]int // key: 0 ~ M-1, value: count` に記録していく。

- 上記は、累積和の数直線上を通常通り探索する場合の話。逆側の経路の場合はどうなる？

  - $y = C - x$である。$y \equiv 0 \mod M$ である y を見つけたい。
  - => $x \equiv C \mod M$
  - => $rightSum - leftSum \equiv C \mod M$
  - => $rightSum - C \equiv leftSum \mod M$ である leftSum を見つければいい。

- **go の%演算と、数学上の moduro 演算は、割られる数が負の時に結果が違うので注意！** [参照](https://github.com/Tomoki108/go-algo/blob/main/lib/math/math.go)

- [類題]: [384 D - Repeated Sequence](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---repeated-sequence-%2F-%E7%84%A1%E9%99%90%E6%95%B0%E5%88%97%E3%80%81%E5%B0%BA%E5%8F%96%E6%B3%95-or-%E5%86%86%E7%92%B0-%2B-%E7%B4%AF%E7%A9%8D%E5%92%8C)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc367/d/main.go
:::

# 366

## [A - Election 2](https://atcoder.jp/contests/abc366/tasks/abc366_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc366/a/main.go
:::

## [B - Vertical Writing](https://atcoder.jp/contests/abc366/tasks/abc366_b)

- 文字列の数、最大文字数ともに 100 と小さいため、辺に工夫せず**全探索**でやるべき。

- 二重スライスに縦にアクセスする。

- 文字列末尾のトリムは`strings.TrimRight(s, "*")`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc366/b/main.go
:::

## [C - Balls and Bag Query](https://atcoder.jp/contests/abc366/tasks/abc366_c)

- マップ使うだけ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc366/c/main.go
:::

## [D - Cuboid Sum Query](https://atcoder.jp/contests/abc366/tasks/abc366_d) / 三次元累積和、包除原理

- 立方体のブロックに数字が入っていて、指定の範囲の数字の合計を出す問題。

- 3 次元累積和を記録し解く。元々の数字を 3 次元配列（各次元に 0 埋めされた余剰を作っておく）入れ、それを各次元でイテレートし、`cube[x][y][z] += c[x-1][y][z]`と処理していくことで 3 次元累積和が完成する。

- 累積和から特定の範囲を出すときは、範囲を含む一番大きな累積和から、引くべきところを引き、重複して引いたところを足すことで求められる。

- 集合の和を求める時に使う**包除原理**を使う。
  - $∣A∪B∣=∣A∣+∣B∣−∣A∩B∣$
  - $∣A∪B∪C∣=∣A∣+∣B∣+∣C∣−∣A∩B∣−∣B∩C∣−∣C∩A∣+∣A∩B∩C∣$
  - **「各集合を足す　=> 2 つの集合の交差を"引く" => 3 つの集合の交差を"加える" => 4 つの集合の交差を"引く" => ... 」数が集合の種類数 N になるまでこれを繰り返せばいい。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc366/d/main.go
:::

# 365

## [A - Leap Year](https://atcoder.jp/contests/abc365/tasks/abc365_a)

- 愚直に上から条件を評価

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc365/a/main.go
:::

## [B - Second Best](https://atcoder.jp/contests/abc365/tasks/abc365_b)

- ソート後も元のインデックスを保持するために、インデックスと値を持った構造体にした上でそのスライスをソート。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc365/b/main.go
:::

## [C - Transportation Expenses](https://atcoder.jp/contests/abc365/tasks/abc365_c)　/ 二分探索(応用)、累積和

- 答えが infinite になる時はどんな時か？全ての交通費が実費精算されるので、実費の総和が M 以下なら補助上限を infinite にできることになる。

- x はどんなものを試せばいい？**求めたい値が漠然としている時は、上限と下限を考える。**

  - **上限**は、制約より M である。（一人の交通費が M 円で、他の人が全員 0 円の時実際 x = M となる。）
  - **下限**は、M/N である。全員に支給しなければならないときに、総和が M 円となり予算を使い切れる。支給しなければならない人間が減った場合、x は M/N より大きくなるので、M/N が下限。（支給人数が N より増えることもない。）

- x について、N/N から M までの数字を試せばいい。これらの数字は**単調増加性**を満たす。（x が増えるほど、交通費補助額の総和が増える。）なので、**二分探索が使える**。

  - 計算量は $O(\log M) = O(\log 2 * 10^{14}) \approx O(\log 2^{43}) \approx O(43)$ なので、間に合いそう。

- $交通費補助額の総和 = 実費精算の範囲 + x * 実費がx以上の人数$

  - 実費の配列の**累積和**を作成しておき、「x 以上」で実費の配列を二分探索すれば、$O(logN)$で x ごとの交通費補助額の総和を求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc365/c/main.go
:::

## [D - AtCoder Janken 3](https://atcoder.jp/contests/abc365/tasks/abc365_d) / DP（テーブル）

- 相手が同じ手を連続で出した時だけ win と tie を交互にすればよく、それ以外は勝ち続ければいい？
  - 相手の同じ手の連続に対して、win から入るか tie から入るかのパターンがある。
  - SSP の様なパターンの場合、win から入ると win, tie, tie の一勝で、tie から入ると tie, win, win の二勝になる。
- **現在の勝利数の最大化が、前回の選択に依存している。このことから、DP**が使えそう。

- テーブル設計

  - 横：何回勝負したか
  - 縦：[0]その回を win [1]その回を tie
  - セル：最大の通算勝利回数

- **状況変数（win の場合に最後に出した手、tie の場合に最後に出した手）を更新するのは、現在の列のセルに値を全て入れてから！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc365/d/main.go
:::

## [E - Xor Sigma Problem](https://atcoder.jp/contests/abc365/tasks/abc365_e) / XOR（排他的論理和）

- ある区間の排他的論理和を求めるためには、**累積 XOR**が累積和と同様に使える。（区間の累積和を求めるときには、二つの値でさらに累積和をとる。）

- 区間の列挙は $O(N^2)$ かかるので不可能。**XOR の問題は、桁ごとに分けると良いことが多い。** XOR 演算は桁ごとに独立なので。また、制約より桁の上限数もわかる。

- i 桁目について、i 桁目のビットが立っている値と立っていない値の XOR をとると、答えの i 桁目は 1 になる。

- 累積 XOR から二つの値を選ぶことは区間（`(l, r]`）を選ぶことに等しい。桁数でループし、i 桁目が立っている値の数を数える。`poppedCnt * N-poppedCnt`が XOR で i 桁目のビットが立つ区間の数であり、その分だけ総和に`1<<2`を足せばいい。

- 最後に、問題の制約上長さ 1 の区間( $区間内のXOR=A_i$ )が許されていないため、$A_1$~$A_N$ を総和から引く。
  - 一つ前のステップで、これらの値の二進数表現の立っているビットが、総和に加算されている。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc365/e/main.go
:::

# 364

## [A - Glutton Takahashi](https://atcoder.jp/contests/abc364/tasks/abc364_a)

- 条件によってループが終了しても、最後のイテレートなら成功になる。
  - 「甘い料理を 2 つ連続で食べると気持ち悪くなってしまい、"その後"料理が食べられなくなってしまいます」

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc364/a/main.go
:::

## [B - Grid Walk](https://atcoder.jp/contests/abc364/tasks/abc364_b)

- グリッドのライブラリを活用するだけ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc364/b/main.go
:::

## [C - Minimum Glutton](https://atcoder.jp/contests/abc364/tasks/abc364_c) / 累積和

- 甘さの降順ソート、しょっぱさの降順ソートを作り、そこから**累積和**を作る。
- 各累積和に対して、それぞれの限度以上になる地点を**二分探索**する。
- 上記のインデックスの小さい方が、いずれかの限度を超すための最小の要素数となり答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc364/c/main.go
:::

## [D - K-th Nearest](https://atcoder.jp/contests/abc364/tasks/abc364_d) / 二分探索(応用)

- **入力値がソートされている保証がないのでソートする**（a_i の配列）
- 条件を満たす距離を求める問題。ソート可能な数直線上の座標などが存在するし、**二分探索が使えないだろうか？**
- 距離の下限は 0 であり、上限は`max(abs(b_j-as[0]), abs(b_j-as[len(as)-1]))`
- **距離が増加するのに伴って単調増加するものはないか？** => 基点から距離以内に存在する座標の数が単調増加。
- 基点、距離からその範囲の座標の数を返す関数を実装し、それを二分探索の条件関数として渡せばいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc364/d/main.go
:::

# 363

## [A - Piling Up](https://atcoder.jp/contests/abc363/tasks/abc363_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc363/a/main.go
:::

## [B - Japanese Cursed Doll](https://atcoder.jp/contests/abc363/tasks/abc363_b)

- 命名ちゃんとすると混乱しない

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc363/b/main.go
:::

## [C - Avoid K Palindrome 2](https://atcoder.jp/contests/abc363/tasks/abc363_c) / 順列、回文

- 文字列の並び替え全パターンの探索が必要。$O(10!) \approx 360万$

- 与えられた順列を次の辞書順の順列にならび変えるアルゴリズムは高速。

  - DFS で全列挙する実装は、同様の計算量だがスライスを何度も操作やコピーする関係上遅い。

- 長さ N の文字列に長さ K の任意の回文が含まれるかの判定の計算量は、以下のとおりで、全探索と組み合わせても十分高速
  - $O((N-K+1) * K) = O((10-5+1)*5) = O(20)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc363/c/main.go
:::

## [D - Palindromic Number](https://atcoder.jp/contests/abc363/tasks/abc363_d) / 回文

- 回文数は、一桁の場合は 10 通り。N 桁の場合は、N 桁目から(N+1)/2 桁目まで（左半分）のパターン数通り。（右半分は左半分を転写するだけなので。）
- 回文数の総数が N を超えるまで、桁数を増やしながら回文数の総数を足していく。そうすると、N 番目の回文数が、何桁の回文数の何番目かがわかる。あとは上手くコードを書く。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc363/d/main.go
:::

# 362

## [A - Buy a Pen](https://atcoder.jp/contests/abc362/tasks/abc362_a)

- 色（string）、価格を持った構造体のスライスを作り、ソートしてループ

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc362/a/main.go
:::

## [B - Right Triangle](https://atcoder.jp/contests/abc362/tasks/abc362_b)

- ピタゴラスの定理が成り立つ時、その三角形は直角三角形である。

- 辺の長さ（ルート）の比較は小数点の精度の問題で正しくできない時があるので、辺の長さの二乗を比較する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc362/b/main.go
:::

## [C - Sum = 0](https://atcoder.jp/contests/abc362/tasks/abc362_c) / 貪欲法

- 答えの配列を、各要素の下限で初期化する。

- sum が 0 になるまで、各要素について順に、`min(要素の上限, 0 - 現在の総和)`だけプラスしていく。（**貪欲法**）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc362/c/main.go
:::

## [D - Shortest Path 3](https://atcoder.jp/contests/abc362/tasks/abc362_d) / ダイクストラ法、優先度付きキュー（ヒープ）

- [解説](https://www.youtube.com/watch?v=AsTnBXWeqsE&t=4378s)

- **ダイクストラ法**を使って、重み付き経路における２点間の最短経路を求めることができる。

  - 始点から任意の点に到達する最小コストを考える。始点のコストは 0 で**確定**。
  - 始点から隣接するノードのコストを記録する。
  - コストが記録されており確定されていないもののうち、**最小のコストのノードのコストを確定させる**。
  - そしてそのノードの隣接ノードのコストを調べ、記録する。（すでに記録済みのノードに、より少ないコストで到達できる場合は上書きする。）
  - 二つ前の手順に戻る。全てのノード（あるいはゴールとなるノード）のコストが確定するまで繰り返す。

- ダイクストラ法は、**優先度付きキュー（ヒープ）** で実装できる。

  - **優先度付きキュー**とは、優先度の高いものから取り出されるキューである。
  - 優先度付きキューは、**ヒープ**というデータ構造で実装できる
  - ヒープは、キー順序性を満たす完全二分木である。

- 類題: [D - Super Takahashi Bros.](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#d---super-takahashi-bros.-%2F-%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95%E3%80%81%E5%84%AA%E5%85%88%E5%BA%A6%E4%BB%98%E3%81%8D%E3%82%AD%E3%83%A5%E3%83%BC%EF%BC%88%E3%83%92%E3%83%BC%E3%83%97%EF%BC%89)

:::details 二分木とは
各ノードが最大で 2 つの子ノードを持つ木構造のことです。この特性から、「二分木」という名前がつけられています。

### 特徴

- ノード（節）:

  - 各ノードは 1 つのデータ要素を持ちます。
  - 親ノード（Parent）: 自分より上の階層のノード。
  - 子ノード（Child）: 自分より下の階層のノード。左の子ノード（Left Child）と右の子ノード（Right Child）があります。

- ルート（根）:

  - 木構造の最上部に位置するノードです。
  - 二分木には 1 つだけルートがあります。

- リーフ（葉）ノード:

  - 子ノードを持たないノードです。

- 高さ:
  - ルートからリーフノードまでの最長パスの長さ。

:::

:::details 完全二分木とは
完全二分木は、以下の条件を満たす二分木のことを指します：

- 最も深い階層より浅いレベルのノードは、全て埋まっている。
- 最も深い階層のノードが左から順番に埋まっている。

:::

:::details ヒープとは
ヒープは、以下の特性を持つデータ構造です（ソートされた配列もヒープと言うことができます）：

- キー順序性を満たす:

  - 各ノードの値は、その子ノード、左にあるノードの値よりも大きいまたは小さい。
    - 最大ヒープ: 親ノードの値が子ノードの値以上、兄弟ノード（同じ親の子ノード）において左のノードが右のノードの値以上。
    - 最小ヒープ: 親ノードの値が子ノードの値以下、兄弟ノード（同じ親の子ノード）において左のノードが右のノードの値以下。
    - 同じ階層の親が違う兄弟の比較については、左から右へ値が単調増加/減少する保証はない。

- 形状が完全二分木である

- 要素の Push 時、Pop 時の両方でソートが行われるため、両方の計算量は $O(N*logN)$である。
  :::

- 確定済みノード、各ノードの到達コストをそれぞれマップで記録。`{始点ノード, コスト0}`を優先度付きキュー（コストが少ない物を優先）に入れ、探索開始。キューから要素を取り出すときに、そのノードを確定させる。隣接ノードのコストを調べ、キューに入れていく。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc362/d/main.go
:::

# 361

## [A - Insert](https://atcoder.jp/contests/abc361/tasks/abc361_a)

- オリジナルを K 番目まで copy した配列に、X を append。そしてオリジナルの K+1 番目以降を apennd

- **`copy(dest, src)`するときに、dest はコピーしたい範囲と同様の length, size を両方持つこと**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc361/a/main.go
:::

## [B - Intersection of Cuboids](https://atcoder.jp/contests/abc361/tasks/abc361_b)

- 二つの立方体が重なっているのは、x 軸、y 軸、z 軸の範囲がいずれも重なっている時。

- any 軸の範囲が重なっている時はどう言う時か？**ある事象のための条件を考える時、考えづらかったらその逆のための条件を考える。**

- 「範囲[a, b]と[c, d]が、長さが 1 以上の共通部分を持たないとき」はどんな条件か？
  - `d <= a || b <= c`の時である。（一方の上限が他方の下限以下である時。）
  - その条件の否定が、求めたい条件である。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc361/b/main.go
:::

## [C - Make Them Narrow](https://atcoder.jp/contests/abc361/tasks/abc361_c)

- `(B の最大値) − (B の最小値) としてありうる最小値`を考えたいので、消して意味のある要素は、ソート後の配列の両端から、合計 N 個。

- 前から x 個、後ろから y 個消すとする。そのパターンは、K 個の直列に並んだ石の、どこに仕切りに置くのか（0 個になる側が出ても OK）と同じで、K+1 パターン。

- K は$2*10^5$なので、**全探索**可能。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc361/c/main.go
:::

## [D - Go Stone Puzzle](https://atcoder.jp/contests/abc361/tasks/abc361_d) / BFS（応用）

- **$2≤N≤14$と言う N の小ささに注目する。盤面のパターンが列挙できるのでは？現在のパターンから行ける次のパターンは限られているので、DFS や BFS が使えるのでは？**

- **最短手数**を求める問題なので、**BFS**。

- 実際の盤面のパターンは、最悪で$2^{14} * 15 = 16384$。（15 は空の連続 2 マスをどこに置くのか。）

- BFS の計算量は、16384 より悪くならない。同じ盤面を二回経由する意味はないので、他のすべての盤面を経由してゴールに辿り着く場合に 16384 になる。（実際にそのようなパターンはあり得ないため、実際の最悪はもっと少ないが、その証明や計算は難しいためしなくていい。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc361/d/main.go
:::

# 360

## [A - A Healthy Breakfast](https://atcoder.jp/contests/abc360/tasks/abc360_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc360/a/main.go
:::

## [B - Vertical Reading](https://atcoder.jp/contests/abc360/tasks/abc360_b) / 全探索

- $1≤c≤w<∣S∣$、$1≤∣T∣≤∣S∣≤100$ より、c と w の組み合わせは$100^2$を超えない。**絶対に全探索でやる。スマートな方法とか考え始めない。**

- w（チャンクサイズ）でループ。スライスをチャンクに分割して、可能な縦読みを全て試す。

- または、w と c を二重ループで全探索し、その場合の文字列を計算し、それが T と一致するか判定。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc360/b/main.go
:::

## [C - Move It](https://atcoder.jp/contests/abc360/tasks/abc360_c) / 優先度付きキュー（ヒープ）

- 箱に入っている荷物を、軽さによる **優先度付きキュー（ヒープ）** で管理する。

- `map[箱]優先度付きキュー`で全体を管理。マップでループして、すべてのキューから要素 1 になるまで取り出しを行い、コストを足していく。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc360/c/main.go
:::

## [D - Ghost Ants](https://atcoder.jp/contests/abc360/tasks/abc360_d) / 二分探索（応用）

- **少し面倒だが、それでも図を書く**

  - 最初 start - end の区間で表現する方法を選んでしまったが、始点のみを管理する方法が解放としてもシンプルになりよかった。
  - **考慮する要素が少なくなるよう、なるべくシンプルな方法で表現すると良いかも？**

- 交差することができるのは、forward の蟻と backward の蟻。かつ距離が 2T より多く離れていない場合。

- forward、backward の蟻をソートし、前者でループ。自身より前にいる backward の蟻を **二分探索** で見つけ、そこからさらに一定の距離以上離れていない蟻を二分探索で見つける。

### 二分探索 tips

#### スライスから「ある条件に合う要素」を二分探索した場合

**=> ある条件に合う要素の数は、スライスの長さ引く結果のインデックスになる。**

```go
sl := []int{1, 2, 3, 4, 5}

// 4以上の要素の数が知りたいとする。
idx := sort.Search(len(sl), func (i int) bool {
  return sl[i] >= 4
})


// 最後の要素だけヒットしたとする。その場合該当する要素数は1。len(sl) - idx (=len(sl)-1)も1になる。
// 最後から二つの要素だけヒットしたとしても、同様に考えて引き算の結果が要素数と一致する。
ans := len(sl) - idx

fmt.Printf("answer is %d", ans)
```

#### スライスから「ある条件に合わない要素」を二分探索した場合

条件そのものを使うと、スライスが単調増加性を満たさない場合に上記の探索をすることになる。

**=> ある条件に合う要素の数は、結果のインデックスと同じになる。**

```go
sl := []int{1, 2, 3, 4, 5}

// 4以下の要素の数が知りたいとする。
// **4以下という条件では、対象のスライスは単調増加性を満たさないので、4より大きいという条件で二分探索することになる。**
idx := sort.Search(len(sl), func (i int) bool {
  return sl[i] > 4
})

// 答えがidxと同じになるのは、以下の直感的な式を変形すると結局 ans := idxになるから。
// numOfNotMatched := len(sl) - idx
// ans := len(sl) - notMatched
ans := idx

fmt.Printf("answer is %d", ans)
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc360/d/main.go
:::

# 359

## [A - Count Takahashi](https://atcoder.jp/contests/abc359/tasks/abc359_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc359/a/main.go
:::

## [B - Couples](https://atcoder.jp/contests/abc359/tasks/abc359_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc359/b/main.go
:::

## [C - Tile Distance 2](https://atcoder.jp/contests/abc359/tasks/abc359_c) / 座標平面

- **図を書いて実験する。手書きが難しいものは、スクショしてそれをペイントする。**

- タイルから別のタイルに行く時にコストがかかる。タイルのどちら側にいて、別のタイルのどちら側に行くかは関係しない。

  - よって、座標を、タイルの左側に統一する。（元々左側ならそれを、右側ならそのタイルの左側の座標に変換する。）
  - **同一と見做せるものは、どちらかに統合して考える。パターン数や、問題の複雑さを減らせる。**

- 図を書くとわかるが、始点から波紋状にコストが増えていくことがわかる。

- そして、 `yDelta >= xDelta`の範囲ではコストが`yDelta`であり、そうではない範囲ではコストが`xDelta+yDelta/2`であることが分かる。

:::details 図
![image](/images/ABC/359/359_C.png)
:::

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc359/c/main.go
:::

## [D - Avoid K Palindrome](https://atcoder.jp/contests/abc359/tasks/abc359_d) / DP（テーブル）、DFS、回文

- ある`?`が`A`になれるか`B`になれるか、その両方になれるのか、（回文が成立してしまい）どちらにもなれないのかは、そのインデックス i の**直前の i-1 ~ i-K 文字目の状態に依存すする。** このことから、**DP**が使えそう。

- DP テーブルの設計

  - 列：何文字目（index i）を考えているか
  - 行：i-1 ~ i-K 文字目の文字列
  - セル：その状況に到達しうるパターン数
    - セルの値はどうする？最終的に求めたいのは、良い文字列の合計数。int になりそう。その状況に到達しうるパターン数にすれば、**最終列の合計を取れば答えになる。最終列を見れば知りたい答えがわかるように、セルの値を設計する。**
    - 列 i から列 i+1 に遷移するときに、セルの値を引き継いで足せばいい。複数のセルからあるセルに遷移した場合、その状態に到達しうるパターン数の合計になる。
  - `var table []map[string]int`

- 最初の index 0 ~ K-1 文字目のパターンはどう列挙すればいい？（DP テーブルの実質の 1 列目）

  - その文字列の中に含まれる`?`を A、B どちらかにするかで枝分かれする構造なので、**DFS**で列挙できる。（再帰の前のスライスのコピーを忘れずに。）

- あとは列挙した 0 ~ K-1 文字目のパターンをテーブルに挿入し、その列の参照から始まるループを回し、ループ内で次の行を埋めればいい。（N-1 列目を参照するループで終わり。）

- 類題：[312 D - Count Bracket Sequences](http://localhost:8000/articles/3e1c0c8a9c00fc#d---count-bracket-sequences-%2F-dp%EF%BC%88%E3%83%A1%E3%83%A2%E5%8C%96%E5%86%8D%E5%B8%B0%EF%BC%89)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc359/d/main.go
:::

# 358

## [A - Welcome to AtCoder Land](https://atcoder.jp/contests/abc358/tasks/abc358_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc358/a/main.go
:::

## [B - Ticket Counter](https://atcoder.jp/contests/abc358/tasks/abc358_b)

- **順番待ちの列が出てくるからと言って、queue を使うとは限らない。**

- 待ち時間は、その直前の人が終わった時間プラス処理時間 A になる。つまり、直近の人が終わった時間を記録しながら前から順に処理していけばいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc358/b/main.go
:::

## [C - Popcorn](https://atcoder.jp/contests/abc358/tasks/abc358_c) / 全探索（順列）、二進数（論理和）、貪欲法

- 売り場の数 N が 10 なので、売り場の順列パターン数は 10!(=約 360 万)なので、**全探索**可能。

- 順列に対して、貪欲に上からできる限りポップコーンの種類を買っていき、何個の売り場を回ったらコンプリート可能か見ていけばいい。（**貪欲法**）

- どの種類のポップコーンを売っているかの情報は、二進数で表現できる。複数の売り場の二進数の**論理和**を取れば、集められるポップコーンの種類数の和が求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc358/c/main.go
:::

## [D - Souvenirs](https://atcoder.jp/contests/abc358/tasks/abc358_d)

- 二つのスライスをソートして、両方を最初から見ていけばいい。

- 各 B にどの A を当てがうかを調べたいので、B でループする。対応するインデックスの A をみて、マッチすればそれを当てがう。そうでなければマッチするものが見つかるまでループ内部でループし、A のインデックスをどれだけ進めたのかを記録する。

- **インデックスがスライスのレングス内に収まっているかチェックするのを忘れない！**

- [類題：376 Prepare Another Box](https://zenn.dev/shinonome81/articles/b1de75b0849b32#c---prepare-another-box)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc358/d/main.go
:::

# 357

## [A - Sanitize Hands](https://atcoder.jp/contests/abc357/tasks/abc357_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc357/a/main.go
:::

## [B - Uppercase and Lowercase](https://atcoder.jp/contests/abc357/tasks/abc357_b)

- 愚直
- 小文字判定：`'a' <= rune(S) && rune(S) <= 'z'`
- 大文字判定：`'A' <= rune(S) && rune(S) <= 'Z'`
- `strings.ToUpper(S)`, `strings.ToLower(S)`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc357/b/main.go
:::

## [C - Sierpinski carpet](https://atcoder.jp/contests/abc357/tasks/abc357_c) / グリッド(応用)、再帰

- 可能ならグリッドを 9 つの部分グリッドに分け、真ん中を白で塗りつぶす。それ以外を同様の処理に回す。ということのため、**再帰関数**を実装する。

- 指定サイズの黒で塗りつぶされた string pointer のグリッドを用意し、再帰関数に渡す。

- **go 1.22 より前だと、for 行で宣言される変数は最初のイテレートでメモリが確保され、以降は値のみ更新される仕様であることに注意する。**

  - [ref](https://go.dev/doc/go1.22)

- **ポインタ変数の「値」を変更したいときは、`*ptrVariable = "foo"`のようにする。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc357/c/main.go
:::

## [D - 88888888](https://atcoder.jp/contests/abc357/tasks/abc357_d) / 等比数列、合同式

### 等比数列

- $V_N$は、初項$N$、公差$10^K (KはNの桁数)$の**等比数列**であることが分かる。

  - $V_5 = 555 = 5*10^0 + 5*10^1 + 5*10^2$
  - $V_{10} = 10101010101010101010 = 10*(10^2)^0 + 10*(10^2)^1 + ... 10*(10^2)^9$

- **等比数列の和** $S$は、初項を$a$、公差を$r$、項数を$n$とすると以下になる。($S*r - S$の式を立てることで求まる)
  - $S = (a*r^n - a) / (r - 1) = a(r^n -1) / (r-1)$

### 合同式

- **合同式において、足し算、引き算、掛け算における任意の項を合同な数に置き換えても、結果は変わらない。**
  (乗数計算においても、基数を合同な数に置き換えて良い。指数はダメ。)

- よって以下が成り立つ。

```go
var isSame bool
isSame = (A+B)%M == (A%M+B%M)%M // true
isSame = (A-B)%M == (A%M-B%M)%M // true
isSame = (A*B)%M == (A%M*B%M)%M // true

// (A+B)%M == (A%M+B%M) のようなものは成り立たないことに注意。（「合同式」ではなく「等式」になっているので）
```

- **逆元**という概念があり、$a$の逆元は$a^{-1}$と表記される（**$1/a$を意味しない**）。$a*a^{-1} \equiv 1 \pmod M$となる数のことである。

- a の逆元は、法 m と a が互いに素（最大公約数が 1）の場合のみ存在する。a の逆元は**フェルマーの小定理**または**ユークリッドの拡張互除法**で求められる。
  - フェルマーの小定理：$mが素数でGCD(a, m) = 1ならば、a^{m-1} \equiv 1 \pmod m$
    - $a * a^{m-2} \equiv 1 \pmod m$となるため、$a^{m-2}$が a の逆元。
  - ユークリッドの拡張互除法: $GCD(a, m) = 1ならば、a*x + m*y = 1となるx, yが求められる$
    - $a*x + m*y \equiv 1 \pmod m$より、$a*x \equiv 1 \pmod m$。よって x が a の逆元。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc357/d/main.go
:::

# 356

## [A - Subsegment Reverse ](https://atcoder.jp/contests/abc356/tasks/abc356_a)

- あるスライスの区間[L,R]を別のスライスで置き換えたい場合、以下のようにすればできる。
  ```go
  replaced := append(original[:L], change...)
  replaced = append(replaced, original[R+1:]...)
  ```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc356/a/main.go
:::

## [B - Nutrients](https://atcoder.jp/contests/abc356/tasks/abc356_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc356/b/main.go
:::

## [C - Keys](https://atcoder.jp/contests/abc356/tasks/abc356_c) / ビット全探索、二進数（論理積）

- **ややこしそうな問題文は、解釈を間違えないように気をつける。**

  - 「N 個の鍵の中に 正しい K 個の鍵の組み合わせが存在し、その組み合わせの鍵をドアに刺せば（追加で他の鍵を刺していても）開く」**ということではない。**
  - 「N 個の鍵の中に いくつかの正しい鍵が存在し、K 個以上の正しい鍵をドアに刺せば開く」**ということ。** 鍵の番号は関係ない。

- 標準入力の一行に複数の型のデータが入っていて面倒だが、愚直にハンドリングする。

- 2^N は最大でも 2^15 のため全探索できそう。各番号の鍵が正しいか正しくないかは二進数で表現できるので、**ビット全探索**する。

- 各テストについても、どの鍵を使ったかを二進数で表現できる。各番号の鍵が正しいか正しくないかのパターンの二進数との**論理積**を取ると、使っていてかつ正しい鍵の本数が分かる。
  - 正しい鍵を K 本以上使っているならドアが開くべきで、K 本未満ならドアが開かないべき。各テストがこれと矛盾しないかチェックし、テストで矛盾が生じるパターンはありえないパターンとして除外できる。
  - 論理積は、int, int64, uint64 などどんな型でも取れる。（同じ型同士で。型変換して揃えても問題ない。）
  - 演算子は`&`：`conjunction := A & B`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc356/c/main.go
:::

## [D - Masked Popcount](https://atcoder.jp/contests/abc356/tasks/abc356_d) / 二進数（数え上げ）

- 0~N のループは重すぎてできない。**二進数は桁ごとの処理にするといいことが多い**ので、桁ごとの処理のループを作ってやる。
  $\sum_{K=0}^{N} popcount(K \& M)$
  $\sum_{K=0}^{N} \sum_{j=1}^{60} isBitPop(K \& M, j)$　// 制約より、K & M は最大 60 桁。

- **連続するシグマの位置は入れ書いても良い。二つ目のシグマ以降のループをなくせれば、60 ループで済むようになる。**
  $\sum_{j=1}^{60} \sum_{K=0}^{N} isBitPop(K \& M, j)$

- $isBitPop(K \& M, j) = true$となり得るのは、M の j 桁目が 1 の場合のみ。

- **二進数の j 桁目（一番右を一桁目とする）のビットは、^j の周期を持ち、周期の前半が 0 で後半が 1 である。**

- この性質を利用すると、各桁について以下の式で立っているビットの数え上げができる。
  - `0~Nまでの間に何周期存在するか * 周期/2 + 余りが周期/2を超えていればその分`
  - 1 ではなく 0 始まりであることに注意。

```
// 二進数を最初から列挙
00000
00001
00010
00011
00100
00101
00110
00111
01386
01001
01010
01011
01100
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc356/d/main.go
:::

# 355

## [A - Who Ate the Cake?](https://atcoder.jp/contests/abc355/tasks/abc355_a)

- マップ、愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc355/a/main.go
:::

## [B - Piano 2](https://atcoder.jp/contests/abc355/tasks/abc355_b)

- マップ、愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc355/b/main.go
:::

## [C - Bingo 2](https://atcoder.jp/contests/abc355/tasks/abc355_c) / ビンゴ

- N*N グリッドに 1, 2, ...N と番号を順に埋めていく場合、マス目の値は`N*rowIdx+colIdx+1`となる。

- 逆にマス目の値から行と列を知りたい時は、以下のようになる。

  - 行：`num / N`
  - 列：`num % N`

- マスが対角線上にあるかどうかを知りたいときは、以下のようになる。
  - 左上から右下：`rowIdx == colIdx`
  - 右上から左下：`rowIdx + colIdx == N-1`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc355/c/main.go
:::

## [D - Intersecting Intervals](https://atcoder.jp/contests/abc355/tasks/abc355_d) / 区間、二分探索（応用）or 余事象

### 解法 1 二分探索

- **数直線上に区間が並んでいるので、二分探索が使えそう。**

- 区間をソートし、左側の区間から順に、それより右側の区間で始点が現在の区間の終点以前にある区間を探せないか。
  - 区間スライスと始点スライスを作り、昇順にソートする（始点が同じなら終点が左の方を優先）
  - 区間スライスでループし、始点スライスを`stars := starts[1:]`で現在の区間を削る。
  - `starts[i] > currentSeg.r`で二分探索し、現在の区間の終点以前にある始点の数を調べる。（[二分探索-tips](#二分探索-tips)）

### 解法 2 余事象、重ならない区間の性質

- 区間の組み合わせの数は`N*N-1/2`なので、全探索無理。**余事象**である重ならない区間の数が分かれば、`N*N-1/2`からその数を引けば答えになる。

- **A の右端 < B の左端　となる区間 A,B は重ならない。逆も然り。**

- つまり、ある左端の座標の前に、幾つ右端の座標があるかを数えて足し上げていけばいい。x 座標、種類（右端 or 左端）を持った構造体のスライスを作りソートし、ループすればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc355/d/main.go
:::

# 354

## [A - Exponential Plant](https://atcoder.jp/contests/abc354/tasks/abc354_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc354/a/main.go
:::

## [B - AtCoder Janken 2](https://atcoder.jp/contests/abc354/tasks/abc354_b)

- 辞書順ソート

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc354/b/main.go
:::

## [C - AtCoder Magics](https://atcoder.jp/contests/abc354/tasks/abc354_c)

- **問題文の言い換え。**「コストが増えたなら、攻撃力も増えなければならない」（or 「攻撃力が減るのなら、コストも減らなければならない」）
  - **言い換えを思いつくまでは、実装をガチャガチャ試すのは悪手。**
  - コストの昇順で入力値をソートし、攻撃力の閾値を記録しながらループで有効なカードをチェックしていけばいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc354/c/main.go
:::

## [D - AtCoder Wallpaper](https://atcoder.jp/contests/abc354/tasks/abc354_d) / 座標平面、面積、包除原理

### 座標平面 tips

#### x, y 座標が正になるように、入力値に下駄を履かせる。

- 今回の場合、`+10^9` すれば制約より座標が必ず正になる。
  - 今回の場合、座標平面が 4\*2 の周期で同じ模様をしているので、x 座標に 4 の倍数、y 座標に 2 の倍数を足しても同じ模様の範囲になる。（4 の倍数判定は、下 2 桁が 4 の倍数かどうか。）

### 面積を求める時に「右上座標-原点」の面積を出し、包除原理で求めたい範囲を求める。

- 「任意の座標-原点」の面積を求める関数を実装すればいい。
- 「(A, B) (C, D)」の面積は、`f(C, D) - f(C, B) - (A, C) + f(A, B)`

### 解法

:::details 図
![image](/images/ABC/354/354_d.png)
:::

- 4\*2 のブロック（黒い部分は全体の 1/2）がいくつ入っているかをみたい。

  - `ans := x/4 * y/2 * 1/2 * 2`

- 縦方向の余り

  - `if y%2 == 1: ans += 1 * 1/2 * 2`

- 横方向の余り

  - x 方向の周期は４なので、余りは 3 パターン
  - 余りが１以上なら周期の最初から１行目を足し、２以上なら最初から２行目を足し、３なら最初から３行目を足せばいい。
  - 右上の１行についても、x 方向の周期は４なので、`y%2 == 1`なら上記のそれぞれの行について足しておく。

- **go の int の割り算は結果が切り捨てなので、気を付ける！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc354/d/main.go
:::

# 353

## [A - Buildings](https://atcoder.jp/contests/abc353/tasks/abc353_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc353/a/main.go
:::

## [B - AtCoder Amusement Park](https://atcoder.jp/contests/abc353/tasks/abc353_b)

- 座っている人数を記録しつつグループ毎にループ。K と同じになるか、越えるか、未満かで分岐。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc353/b/main.go
:::

## [C - Sigma Problem](https://atcoder.jp/contests/abc353/tasks/abc353_c) / 合同式、二分探索

- **式変形を考える。**

  - $\sum_{i=1}^{N-1}\sum_{j=i+1}^{N} f(A_i, A_j)$
  - $(A_1 + A_2) \mod M + (A_1 + A_3) \mod M + (A_2 + A_3) \mod M$ // N=3 の場合

- **$\mod M$が分配できるのは、合同式の場合のみ。等式ではできない。**

- $\mod M$がなかった場合、$\sum_{i=1}^{N} A_i * (N-1)$で答えが求められる。
  - **$(a + b) \mod M$とは、a+b が M を超えていれば、引けなくなるまで M を引くということ。**
  - ソートした As でループし、$A * (N-1)$分総和を増加させる。
  - `As[idx:]`から**二分探索**で$A + A_j <= M$になる A の数を調べ、その分だけ M を引く。（制約より、$A_i + A_j < 2M$）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc353/c/main.go
:::

## [D - Another Sigma Problem](https://atcoder.jp/contests/abc353/tasks/abc353_d) / 合同式、累積和

- **式変形を考える。**

  - $\sum_{i=1}^{N-1}\sum_{j=i+1}^{N} f(A_i, A_j)$
  - $(A_1 * 10^{|A_2|} + A_2) + (A_1 * 10^{|A_3|} + A_3) + (A_2 * 10^{|A_3|} + A_3)$ // N=3 の場合
  - $10^{|A_3|} * (A_1 + A_2) + A_3 * 2 + 10^{|A_2|}* (A_1) + A_2 * 1$
  - $\sum_{i=1}^{N} 10^{|A_i|} * prefSum[i-1] + A_i * (i-1)$

- **オーバーフローしないように適切に式に`%M` をつけておく。誤答ペナルティ勿体無い。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc353/d/main.go
:::

# 352

## [A - AtCoder Line](https://atcoder.jp/contests/abc352/tasks/abc352_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc352/a/main.go
:::

## [B - Typing](https://atcoder.jp/contests/abc352/tasks/abc352_b)

- インデックスのズレを記録しながら見つけたい文字列の方でループし、もう一方の文字列を idx+diff で参照。
- 相方が見つかるまでループの中でさらにループし、diff をインクリメント。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc352/b/main.go
:::

## [C - Standing On The Shoulders](https://atcoder.jp/contests/abc352/tasks/abc352_c)

- 最後の巨人のみ、A ではなく B の値で総 Height が加算される。B-A の値で昇順ソートし、最後の要素だけ B で加算する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc352/c/main.go
:::

## [D - Permutation Subsequence](https://atcoder.jp/contests/abc352/tasks/abc352_d) / Ordered Set

- Ps について、元々の番号を保持したまま数字順にソートする。その後、index0 から K 個ずつの数字を見ていき、最大番号-最小番号を計算し minAns を比較、更新する。

- ループ毎に番号が一つ削除、追加される。また、現在の K 個の番号から最大値と最小値を取得する必要がある。**これは、Ordered Set で高速に行える。全て O(log N)。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc352/d/main.go
:::

# 351

## [A - The bottom of the ninth](https://atcoder.jp/contests/abc351/tasks/abc351_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc351/a/main.go
:::

## [B - Spot the Difference](https://atcoder.jp/contests/abc351/tasks/abc351_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc351/b/main.go
:::

## [C - Merge the balls](https://atcoder.jp/contests/abc351/tasks/abc351_c)　/ スタック、巨大な数

- ボールを列に追加していき、最後に追加したボールを（から）参照する必要があるので**スタック**が活用できる。

- ボールのサイズは$2^N (N = 2*10^5)$なので、愚直にサイズを記録するとオーバーフローする。**乗数が出てきて、指数が巨大ならオーバーフローを回避することを考える。**

- もともとあるボールのサイズは 2 の乗数で、合体してできるボールのサイズは $2^x + 2^x = 2(2^{x+1})$ なので、2 の乗数のサイズしか考えなくていい。なので指数のみ記録すればよく、オーバーフローを回避できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc351/c/main.go
:::

## [D - Grid and Magnet](https://atcoder.jp/contests/abc351/tasks/abc351_d)　/ DFS（グリッド）、連結成分

- **連結成分**とは、グラフにおいて経路で繋がれた頂点の集合である。

- 今回の問題においては、ある開始頂点から到達できる別の頂点について、自由度は開始頂点以下である。

  - 磁石の隣接頂点では身動きできないため自由度１だが、それ以外の点については開始頂点と到達できる範囲が全く同じであるため。

- よって、**DFS**で探索を行うとして、探索済みの頂点は別の DFS の開始頂点とする必要はない。

  - **別の連結成分に属する別の開始頂点からの DFS では、過去に探索済みの頂点には必然的に訪れることはない。**
  - ただし今回の場合、連結成分の境目である磁石の隣接マスのみ再訪の可能性がある。

- 訪問済みデータを管理する必要がある。（開始頂点の訪問済みスキップ、各 DFS での訪問済み管理。）
  - ただし、グリッドが 1000\*1000 のため、二つ目の訪問済みデータを毎回初期化していると TLE になる。そこで、一つのデータを使い回すことを考える。
  - 連結成分の境目の磁石隣接マスには、各 DFS で再訪しても良いため、工夫が必要。
  - **`var visited [][]int`とし、各 DFS で（１以上の）異なる数字を入れたなら、全 DFS を通して訪問/未訪問か、今回の DFS で訪問/未訪問かを識別することができる。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc351/d/main.go
:::
