---
title: "Goã§æ›¸ã‹ã‚ŒãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ··æ²Œã¨ã—ãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’æ”¹å–„ã—ãŸè©±"
emoji: "ğŸ·"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Go"]
publication_name: "castingone_dev"
published: true
---

ã“ã‚“ã«ã¡ã¯ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã®æ°¸ç”°ã§ã™ã€‚ä»Šå›ã¯ã€Go ã§æ›¸ã‹ã‚Œã¦ã„ã‚‹ CastingONE ã®ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ”¹å–„ã«å–ã‚Šçµ„ã‚“ã è©±ã—ã‚’ã—ã¾ã™ã€‚

éæ¨å¥¨ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä½¿ã£ã¦ã„ãŸã‚Šã€ã‚¨ãƒ©ãƒ¼ã«ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãŒã¤ã„ã¦ã„ãªã„ã“ã¨ãŒã‚ã‚‹ãªã©ã€å…ƒã€…æ··æ²Œã¨ã—ãŸçŠ¶æ³ã§ã—ãŸã€‚åŒã˜ã‚ˆã†ãªçŠ¶æ³ã‚’æŠ±ãˆã¦ã„ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã‚ã‚‹ã‹ã¨æ€ã†ã®ã§ã€ä½•ã‚‰ã‹å‚è€ƒã«ãªã‚Œã°å¹¸ã„ã§ã™ã€‚

# Before

- ã‚¨ãƒ©ãƒ¼ã«ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ã¤ã‘ã‚‹ãŸã‚ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã—ã¦ [github.com/pkg/errors](https://github.com/pkg/errors) ã¨ [golang.org/x/xerrors](https://pkg.go.dev/golang.org/x/xerrors) ã®äºŒã¤ãŒå°å…¥ã•ã‚Œã¦ãŠã‚Šã€æ··åœ¨ã—ã¦ã„ã‚‹ã€‚ã—ã‹ã‚‚ä¸¡æ–¹ç¾åœ¨ã¯éæ¨å¥¨ã€‚[^1]

- æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®`errors.New()`ã¨`fmt.Errorf()`é–¢æ•°ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ç®‡æ‰€ãŒã‚ã‚Šã€ãã‚Œã‚‰ã‚’èµ·ç‚¹ã¨ã™ã‚‹ã‚¨ãƒ©ãƒ¼ã«ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãŒã¤ã„ã¦ã„ãªã„ã“ã¨ãŒã‚ã‚‹ã€‚

# After

- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¡Œã†éš›ã«ã¯å¿…ãšç‹¬è‡ªã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸(`pkg/errors`ã®ãƒ©ãƒƒãƒ‘ãƒ¼)ã‚’ä½¿ã†ã‚ˆã†ã«ã—ã€ãã‚Œä»¥å¤–ã®æ–¹æ³•ã§ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¡Œã†ã¨ github actions ã§è­¦å‘ŠãŒå‡ºã‚‹ã‚ˆã†ã«ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¨ãƒ©ãƒ¼ã«å¿…ãšã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãŒã¤ãã‚ˆã†ã«ã—ãŸã€‚

- ä»Šå¾Œã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã«ã¤ã„ã¦ä¹—ã‚Šæ›ãˆãŸã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã£ãŸã‚Šæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®æ‹¡å¼µãŒèµ·ããŸã¨ãã«ã€ãƒ©ãƒƒãƒ‘ãƒ¼ã ã‘ä¿®æ­£ã™ã‚Œã°æ¸ˆã‚€ã‚ˆã†ã«ãªã£ãŸã€‚

# æ”¹å–„ã®æ‰‹é †

1. `x/xerrors`ã®åˆ©ç”¨ç®‡æ‰€ã‚’`errors.New()`ã¨`fmt.Errorf()`é–¢æ•°ã«ç½®æ›ã—ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¾å­˜é–¢ä¿‚ã‹ã‚‰`x/xerrors`ã‚’å‰Šé™¤ã™ã‚‹ã€‚

2. `pkg/errors`ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹ã€‚

3. AST ã‚’ç”¨ã„ã¦`pkg/errors`ã®é–¢æ•°ã¨`errors.New()`ã€`fmt.Errorf()`ã‚’ãƒ©ãƒƒãƒ‘ãƒ¼ã®é–¢æ•°ã«ç½®ãæ›ãˆã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè£…ã—ã€å®Ÿè¡Œã™ã‚‹ã€‚

4. `pkg/errors`ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆåŠã³`errors.New()`ã¨`fmt.Errorf()`ã®åˆ©ç”¨ã«è­¦å‘Šã‚’å‡ºã™ãŸã‚ã® github actions ã‚’å®Ÿè£…ã—å°å…¥ã™ã‚‹ã€‚

## 1.`x/xerrors`ã®é™¤å»

`x/xerrors`ã¯ã€Go 1.13 ã§æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å°å…¥ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼å‡¦ç†æ©Ÿèƒ½ã®ãƒ™ãƒ¼ã‚¹ã¨ãªã£ãŸãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã§ã™ã€‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒé€²ã‚“ã ç¾åœ¨ã‚‚ä½¿ã£ã¦ã„ã‚‹ã®ã¯ãŠã‹ã—ã„ã®ã§ã€åˆ©ç”¨ç®‡æ‰€ã‚’æ¨™æº–ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®`errors.New()`ã¨`fmt.Errorf()`ã«ç½®æ›ã—ã¾ã™ã€‚

ä¸€æ—¦ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãŒã¤ã‹ãªããªã£ã¦ã—ã¾ã„ã¾ã™ãŒã€å¾Œã®æ‰‹é †ã«ã‚ˆã£ã¦å†åº¦ã¤ãã“ã¨ã«ãªã‚Šã¾ã™ã€‚

## 2.`pkg/errors`ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã®å®Ÿè£…

åŸºæœ¬çš„ã«ã¯`pkg/errors`ã®é–¢æ•°ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚`pkg/errors.Errorf()`ã®ã¿ãã®ã¾ã¾ã§ã¯`fmt.Errorf()`ã¨äº’æ›æ€§ãŒãªã„ãŸã‚ã€å°‘ã—å·¥å¤«ã—ã¦ã„ã¾ã™ã€‚

:::details code

```go
package error

import (
	"fmt"
	pkgerrors "github.com/pkg/errors"
)

// msgã‹ã‚‰ãƒˆãƒ¬ãƒ¼ã‚¹ä»˜ãerrorã‚’ç”Ÿæˆã™ã‚‹
func New(msg string) error {
    return pkgerrors.New(msg)
}

// formatæ–‡ã‹ã‚‰ãƒˆãƒ¬ãƒ¼ã‚¹ä»˜ãerrorã‚’ç”Ÿæˆã™ã‚‹
func Errorf(format string, args ...interface{}) error {
    // pkgerrors.Errorf()ã¯%wã«å¯¾å¿œã—ã¦ã„ãªã„ãŸã‚ã€ç›´æ¥wrapã›ãšä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ã‚ã‚‹ã€‚
    err := fmt.Errorf(format, args...)
    return pkgerrors.WithStack(err)
}

// errorã«ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ã¤ã‘ã‚‹
func WithStack(err error) error {
    return pkgerrors.WithStack(err)
}

// errã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’msgã§ãƒ©ãƒƒãƒ—ã—ã€ãƒˆãƒ¬ãƒ¼ã‚¹ã‚‚ä»˜ä¸ã™ã‚‹
func Wrap(err error, msg string) error {
    return pkgerrors.Wrap(err, msg)
}

// errã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡ã§ãƒ©ãƒƒãƒ—ã—ã€ãƒˆãƒ¬ãƒ¼ã‚¹ã‚‚ä»˜ä¸ã™ã‚‹
func Wrapf(err error, format string, args ...interface{}) error {
    return pkgerrors.Wrapf(err, format, args...)
}

// errã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’msgã§ãƒ©ãƒƒãƒ—ã™ã‚‹. ãƒˆãƒ¬ãƒ¼ã‚¹ã¯ä»˜ä¸ã—ãªã„
func WithMessage(err error, message string) error {
    return pkgerrors.WithMessage(err, message)
}

// errã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡ã§ãƒ©ãƒƒãƒ—ã™ã‚‹. ãƒˆãƒ¬ãƒ¼ã‚¹ã¯ä»˜ä¸ã—ãªã„
func WithMessagef(err error, format string, args ...interface{}) error {
    return pkgerrors.WithMessagef(err, message)
}
```

:::

## 3. AST ã‚’ç”¨ã„ã¦`pkg/errors`ã®é–¢æ•°ã¨`errors.New()`ã€`fmt.Errorf()`ã‚’ãƒ©ãƒƒãƒ‘ãƒ¼ã®é–¢æ•°ã«ç½®ãæ›ãˆã‚‹

ç½®ãæ›ãˆãƒ„ãƒ¼ãƒ«ã®ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

ã“ã‚Œã§ã¯å¯¾å¿œã—ãã‚Œãªã„ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šæ‰‹å‹•ã§ç½®ãæ›ãˆãŸå ´æ‰€ãŒã‚ã£ãŸã‚Šã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå›ºæœ‰ã®äº‹æƒ…[^2]ã‚‚è€ƒæ…®ã—ã¦ã„ã‚‹ã®ã§ã€ã‚ãã¾ã§å‚è€ƒç¨‹åº¦ã«ãªã‚Šã¾ã™ã€‚

:::details code

```go
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	replacementPkg   = "github.com/CastingONE/castingone/go/pkg/error" // ç½®ãæ›ãˆå¾Œã®é–¢æ•°ã®å±ã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
	replacementAlias = "pkgerror"                                      // å›ºå®šã™ã‚‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹å
)

func main() {
	rootDir := "../../../../go" // å†å¸°çš„ã«æ¢ç´¢ã™ã‚‹ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª

	// å†å¸°çš„ã«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ­©ã„ã¦Goãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿®æ­£ã™ã‚‹
	err := filepath.WalkDir(rootDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Goãƒ•ã‚¡ã‚¤ãƒ«ã ã‘ã‚’å¯¾è±¡ã¨ã™ã‚‹
		if !d.IsDir() && strings.HasSuffix(path, ".go") {
			fmt.Printf("Processing file: %s\n", path)
			if err := processFile(path); err != nil {
				return fmt.Errorf("failed to process file %s: %w", path, err)
			}
		}
		return nil
	})

	if err != nil {
		log.Fatalf("Error walking the path: %v\n", err)
	}
	fmt.Println("å…¨ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸã€‚")
}

// Goãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿®æ­£ã™ã‚‹å‡¦ç†
func processFile(filePath string) error {
	fset := token.NewFileSet()

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‘ãƒ¼ã‚¹
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse file: %w", err)
	}

	// ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ãƒãƒƒãƒ”ãƒ³ã‚°
	importMap := make(map[string]string)
	importExists := false
	var importDecl *ast.GenDecl // ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã®ä½ç½®ã‚’ç‰¹å®šã™ã‚‹ãŸã‚ã®å¤‰æ•°
	replaceOccurred := false    // ç½®ãæ›ãˆãŒè¡Œã‚ã‚ŒãŸã‹ã©ã†ã‹ã‚’è¿½è·¡ã™ã‚‹ãƒ•ãƒ©ã‚°

	for _, decl := range file.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.IMPORT {
			importDecl = genDecl
			for _, spec := range genDecl.Specs {
				if importSpec, ok := spec.(*ast.ImportSpec); ok {
					pkgPath := strings.Trim(importSpec.Path.Value, "\"")
					alias := ""
					if importSpec.Name != nil {
						alias = importSpec.Name.Name
					} else {
						// ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã‚’æ¨å®š
						parts := strings.Split(pkgPath, "/")
						alias = parts[len(parts)-1]
					}

					importMap[alias] = pkgPath

					// ã™ã§ã«ç½®ãæ›ãˆå¯¾è±¡ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’"pkgerror"ã«å¤‰æ›´
					if pkgPath == replacementPkg {
						importSpec.Name = ast.NewIdent(replacementAlias)
						importExists = true
					}
				}
			}
		}
	}

	// é–¢æ•°å‘¼ã³å‡ºã—ã®ç½®ãæ›ãˆ
	ast.Inspect(file, func(n ast.Node) bool {
		if callExpr, ok := n.(*ast.CallExpr); ok {
			if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
				if ident, ok := selExpr.X.(*ast.Ident); ok {
					pkgPath, exists := importMap[ident.Name]

					// "github.com/pkg/errors"ã®é–¢æ•°ç½®ãæ›ãˆ
					if exists && pkgPath == "github.com/pkg/errors" {
						ident.Name = replacementAlias
						replaceOccurred = true
					}

					// "errors.New()"ã®ç½®ãæ›ãˆ
					if exists && pkgPath == "errors" && selExpr.Sel.Name == "New" {
						ident.Name = replacementAlias
						replaceOccurred = true
					}

					// "fmt.Errorf()"ã®ç½®ãæ›ãˆ
					if exists && pkgPath == "fmt" && selExpr.Sel.Name == "Errorf" {
						ident.Name = replacementAlias
						replaceOccurred = true
					}
				}
			}
		}
		return true
	})

	// ç½®ãæ›ãˆãŒè¡Œã‚ã‚ŒãŸå ´åˆã«ã®ã¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’è¿½åŠ 
	if replaceOccurred && !importExists {
		newImport := &ast.ImportSpec{
			Name: ast.NewIdent(replacementAlias),
			Path: &ast.BasicLit{
				Value: fmt.Sprintf("\"%s\"", replacementPkg),
			},
		}

		// ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚‹å ´åˆã¯ãã®ä½ç½®ã«è¿½åŠ ã€ãªã„å ´åˆã¯æ–°ã—ãä½œæˆ
		if importDecl != nil {
			importDecl.Specs = append(importDecl.Specs, newImport)
		} else {
			// æ–°ã—ãã‚¤ãƒ³ãƒãƒ¼ãƒˆå®£è¨€ã‚’ä½œæˆ
			newGenDecl := &ast.GenDecl{
				Tok:   token.IMPORT,
				Specs: []ast.Spec{newImport},
			}
			// æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’æœ€åˆã«è¿½åŠ 
			file.Decls = append([]ast.Decl{newGenDecl}, file.Decls...)
		}
	}

	// ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’ãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã‚€
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, file); err != nil {
		return fmt.Errorf("failed to format file: %w", err)
	}

	// ç½®ãæ›ãˆå¾Œã®å†…å®¹ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãæˆ»ã™
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}
```

:::

## 4. `pkg/errors`ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆåŠã³`errors.New()`ã¨`fmt.Errorf()`ã®åˆ©ç”¨ã«è­¦å‘Šã‚’å‡ºã™ãŸã‚ã® github actions

PR ã§ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã§ã€å·®åˆ†ã®ã‚ã‚‹ Go ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŠ½å‡ºã—ã€Go ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å‘¼ã³å‡ºã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚

ãƒ«ãƒ¼ãƒ«ã«é•åã—ã¦ã„ã‚‹å ´åˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒ Fail ã—ã€ä»¥ä¸‹ã®ã‚³ãƒ¡ãƒ³ãƒˆãŒ PR ã«æŠ•ç¨¿ã•ã‚Œã¾ã™ã€‚

![pr_comment](/images/202411_error/pr_comment.png)

:::details code

```yml
name: Go Error Handling Check
on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write

jobs:
  check-go-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"

      - name: Get changed files
        id: changes
        run: |
          git fetch origin ${{ github.event.pull_request.base.sha }} --depth=1
          changed_files=$(git diff --name-only ${{ github.event.pull_request.base.sha }} -- '*.go')

          # $changed_filesã«å«ã¾ã‚Œã‚‹ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹
          changed_files=$(echo $changed_files | sed 's/\//\\\//g')
          echo "changed_files=${changed_files}" >> $GITHUB_ENV

      - name: Run Go program for rule checks
        id: check-rules
        run: |
          go build -o error_handling_check ops/tools/developers-tool/error_handling_check/main.go

          failed_files=""
          for file in $changed_files; do
            # $fileã«å«ã¾ã‚Œã‚‹ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’å…ƒã«æˆ»ã™
            file=$(echo $file | sed 's/\\\//\//g')

            # ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†Goãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å‘¼ã³å‡ºã—
            exit_code=0
            ./error_handling_check "$file" || exit_code=$?
            if [ $exit_code -eq 1 ]; then
              if [ "$failed_files" = "" ]; then
                failed_files="$file"
              else
                failed_files="$failed_files $file"
              fi
            fi
          done

          echo "failed_files=$failed_files" >> $GITHUB_OUTPUT
          echo "failed_files=$failed_files" >> $GITHUB_ENV

      - name: Post comment if there are failed files
        if: ${{ steps.check-rules.outputs.failed_files != '' }}
        uses: actions/github-script@v6
        with:
          script: |
            const failedFiles = process.env.failed_files.split(' ');
            const commentBody = `:warning: ä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã€github.com/pkg/errorsã®importã€ã¾ãŸã¯errors.New()ã€fmt.Errorf()ã®å‘¼ã³å‡ºã—ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚github.com/CastingONE/castingone/go/pkg/errorã‚’ä»£ã‚ã‚Šã«ä½¿ã„ã¾ã—ã‚‡ã†ã€‚\n\n${failedFiles.map(f => `- ${f}`).join('\n')}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            })

            core.setFailed("Some files failed the check.");
```

```go
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

const (
	checkFailedExitCode = 1
	otherErrorExitCode  = 2
)

// ãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒªã‚¹ãƒˆ
var excludedFiles = []string{
	"go/pkg/error/error.go",
	"go/pkg/logger/stacktrace.go",
	"go/pkg/test/test.go",
}

var excludedDirs = []string{
	"ops",
	"go/pkg/dbtype/model",
	"go/console/interface/graph/generated",
	"go/console/interface/graph/model",
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go <file-path>")
		os.Exit(otherErrorExitCode)
	}

	filePath := os.Args[1]
	if shouldSkipCheck(filePath) {
		fmt.Printf("Skipping check for %s\n", filePath)
		os.Exit(0)
	}

	checkFailed, err := checkFileForErrors(filePath)
	if err != nil {
		fmt.Println("Error:", err)
		os.Exit(otherErrorExitCode)
	}

	if checkFailed {
		os.Exit(checkFailedExitCode)
	}

	fmt.Println("No issues found.")
	os.Exit(0)
}

func shouldSkipCheck(filePath string) bool {
	// ãƒ•ã‚¡ã‚¤ãƒ«åãŒexcludedFilesãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
	for _, f := range excludedFiles {
		if filePath == f {
			return true
		}
	}

	// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåãŒexcludedDirsãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
	for _, dir := range excludedDirs {
		if strings.HasPrefix(filePath, dir) {
			return true
		}
	}

	return false
}

func checkFileForErrors(filePath string) (bool, error) {
	// Goãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è§£æ
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.AllErrors)
	if err != nil {
		return false, fmt.Errorf("could not parse file %s: %w", filePath, err)
	}

	var issues []string

	// ASTã‚’èµ°æŸ»ã—ã¦æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚„é–¢æ•°å‘¼ã³å‡ºã—ã‚’æ¤œå‡º
	ast.Inspect(node, func(n ast.Node) bool {
		// ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
		if imp, ok := n.(*ast.ImportSpec); ok {
			if imp.Path.Value == `"github.com/pkg/errors"` {
				pos := fset.Position(imp.Pos())
				issues = append(issues, fmt.Sprintf("Line %d: found import of 'github.com/pkg/errors'", pos.Line))
			}
		}

		// é–¢æ•°å‘¼ã³å‡ºã—ã‚’ãƒã‚§ãƒƒã‚¯
		if call, ok := n.(*ast.CallExpr); ok {
			if fun, ok := call.Fun.(*ast.SelectorExpr); ok {
				// errors.New() ã®ãƒã‚§ãƒƒã‚¯
				if pkg, ok := fun.X.(*ast.Ident); ok && pkg.Name == "errors" && fun.Sel.Name == "New" {
					pos := fset.Position(call.Pos())
					issues = append(issues, fmt.Sprintf("Line %d: found call to 'errors.New()'", pos.Line))
				}
				// fmt.Errorf() ã®ãƒã‚§ãƒƒã‚¯
				if pkg, ok := fun.X.(*ast.Ident); ok && pkg.Name == "fmt" && fun.Sel.Name == "Errorf" {
					pos := fset.Position(call.Pos())
					issues = append(issues, fmt.Sprintf("Line %d: found call to 'fmt.Errorf()'", pos.Line))
				}
			}
		}

		return true
	})

	// å•é¡ŒãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
	if len(issues) > 0 {
		fmt.Printf("file %s has the following issues:\n%s\n", filePath, joinIssues(issues))
		return true, nil
	}

	return false, nil
}

// è¤‡æ•°ã®ã‚¨ãƒ©ãƒ¼ã‚’ä¸€ã¤ã®æ–‡å­—åˆ—ã«çµåˆ
func joinIssues(issues []string) string {
	return " - " + stringJoin(issues, "\n - ")
}

func stringJoin(strs []string, sep string) string {
	result := ""
	for i, str := range strs {
		if i > 0 {
			result += sep
		}
		result += str
	}
	return result
}
```

:::

# å­¦ã³

- `pkg/errors`ã«ã¤ã„ã¦ã€ä½•ã¨ãªãä½¿ã£ã¦ã„ãŸå„é–¢æ•°ã®é•ã„ã‚„ã€æ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ä¹–é›¢ã—ã¦ãã¦ã—ã¾ã£ã¦ã„ã‚‹ã“ã¨ãŒåˆ†ã‹ã‚Šã¾ã—ãŸã€‚ï¼ˆæœ¬å½“ã«ä»Šæ›´ãªã‚“ã§ã™ãŒ...ï¼‰

- å˜ãªã‚‹ç½®æ›ã§ã¯é›£ã—ã„åºƒç¯„å›²ã®ä¿®æ­£ã«ã¤ã„ã¦ã€AST ã‚’ç”¨ã„ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ä¿®æ­£ã™ã‚‹ã¨ã„ã†çµŒé¨“ãŒã§ãã¾ã—ãŸã€‚ï¼ˆãƒ—ãƒ­ã‚°ãƒ©ãƒ è‡ªä½“ã¯ Chat GPT ã«ã‹ãªã‚Šé ¼ã‚Šã¾ã—ãŸãŒ...ï¼‰

[^1]: `pkg/errors`ã‚„`x/xerrors`ãŒèª•ç”Ÿã—ãŸèƒŒæ™¯ã€ãªãœç¾åœ¨ã¯éæ¨å¥¨ãªã®ã‹ç­‰ã€…ã«ã¤ã„ã¦ã¯è¤‡é›‘ãªæ­´å²ãŒã‚ã‚‹ã‚ã‘ã§ã™ãŒã€ã“ã“ã§ã¯è§¦ã‚Œã¾ã›ã‚“ã€‚
[^2]: ãƒ©ãƒƒãƒ‘ãƒ¼ã¯`github.com/CastingONE/castingone/go/pkg/error`ã¨ã„ã†ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«é…ç½®ã—ã¦ã„ã‚‹ã®ã§ã™ãŒã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸è‡ªä½“ã¯ä»¥å‰ã‹ã‚‰å­˜åœ¨ã—ã¦ãŠã‚Šã€ã•ã¾ã–ã¾ãªå ´æ‰€ã§å‚ç…§ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ãã®ãŸã‚ã€ç½®ãæ›ãˆã‚’è¡Œã£ãŸå¾Œã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’è¿½åŠ ã™ã¹ãã‚±ãƒ¼ã‚¹ã¨è¿½åŠ ã™ã¹ãã§ã¯ãªã„ã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã¾ã—ãŸã€‚
