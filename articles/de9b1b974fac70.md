---
title: "混沌としたGoのエラーハンドリングを改善する"
emoji: "🐷"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
publication_name: "castingone_dev"
published: true
---

こんにちは、バックエンドエンジニアの永田です。

今回は CastingONE のバックエンドにおける Go のエラーハンドリングの改善に取り組んだことについてお話しします。

元々、非推奨のパッケージを使っていたり、エラーに必ずしもスタックトレースがついておらずデバグに苦労するという問題があり、混沌とした状況でした。

同じような状況を抱えているプロジェクトもあるかと思うので、自分のした取り組みが何らか参考になれば幸いです。

## 現在の状況の整理

- エラーにスタックトレースをつけるためのパッケージとして [github.com/pkg/errors](https://github.com/pkg/errors) と [golang.org/x/xerrors](https://pkg.go.dev/golang.org/x/xerrors) の二つが導入されており、混在している。しかも両方現在は非推奨。

- 標準パッケージの `errors.New()` と `fmt.Errorf()` 関数を利用している箇所があり、それらを起点とするエラーにスタックトレースがついていないことがある。

※ github.com/pkg/errors や golang.org/x/xerrors が誕生した背景やなぜ現在は非推奨なのか等々についてはご承知のとおり複雑な背景や歴史があるわけですが、ここでは触れません。

## 改善の手順

1. golang.org/x/xerrors の利用箇所を `errors.New()` と `fmt.Errorf()` 関数に置換し、プロジェクトの依存関係から golang.org/x/xerrors を削除する。

2. github.com/pkg/errors のラッパーを実装する。

3. AST を用いて github.com/pkg/errors の利用箇所及び `errors.New()` と `fmt.Errorf()` 関数をラッパーの関数に置き換えるプログラムを実装し、実行する。

4. github.com/pkg/errors のインポート及び `errors.New()` と `fmt.Errorf()`関数の利用に警告を出すための github actions を実装し、運用する。

前述の既存の問題に対して、上記の手順を踏むことで改善を図りました。結果、以下の効果が得られました。

- golang.org/x/xerrors と github.com/pkg/errors が混在していて、しかもどちらも非推奨でありモヤモヤするという問題が解決する。

- 今後スタックトレースについて、乗り換えたいパッケージが見つかったり標準エラーパッケージの拡張が起きたときに、ラッパーだけ修正すれば済むようになる。

改善の手順について、以下にそれぞれ補足していきます。

### 1. golang.org/x/xerrors の除去

xerrors は README にもあるように、それ以前のバージョンから Go 1.13 以降のバージョンのエラーの仕様変更に対する橋渡し的なパッケージです。バージョンがさらに進んだ現在においても使っているのはおかしいので、除去します。

利用箇所を標準パッケージの `errors.New()` と `fmt.Errorf()`　に置換することでスタックトレースがつかなくなってしまいますが、後の手順を行えば再度つくので気にしなくて大丈夫です。

### 2. github.com/pkg/errors のラッパーの実装

:::details code

```go
package error

// New returns an error with the supplied message.
// New also records the stack trace at the point it was called.
func New(msg string) error {
    return pkgerrors.New(msg)
}

// Errorf formats according to a format specifier and returns the string
// as a value that satisfies error.
// Errorf also records the stack trace at the point it was called.
func Errorf(format string, args ...interface{}) error {
    // pkgerrors.Errorf()は%wに対応していないため、直接wrapせず以下のようにしてある。
    err := fmt.Errorf(format, args...)
    return pkgerrors.WithStack(err)
}

// WithStack annotates err with a stack trace at the point WithStack was called.
// If err is nil, WithStack returns nil.
func WithStack(err error) error {
    return pkgerrors.WithStack(err)
}

// Wrap returns an error annotating err with a stack trace
// at the point Wrap is called, and the supplied message.
// If err is nil, Wrap returns nil.
func Wrap(err error, message string) error {
    return pkgerrors.Wrap(err, message)
}

// Wrapf returns an error annotating err with a stack trace
// at the point Wrapf is called, and the format specifier.
// If err is nil, Wrapf returns nil.
func Wrapf(err error, format string, args ...interface{}) error {
    return pkgerrors.Wrapf(err, format, args...)
}

// WithMessage annotates err with a new message.
// If err is nil, WithMessage returns nil.
func WithMessage(err error, message string) error {
    return pkgerrors.WithMessage(err, message)
}

// WithMessagef annotates err with the format specifier.
// If err is nil, WithMessagef returns nil.
func WithMessagef(err error, format string, args ...interface{}) error {
    return pkgerrors.WithMessagef(err, message)
}
```

:::
