---
title: "混沌としたGoのエラーハンドリングを改善する"
emoji: "🐷"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Go"]
publication_name: "castingone_dev"
published: true
---

こんにちは、バックエンドエンジニアの永田です。今回は CastingONE のバックエンドにおいて、Go のエラーハンドリングの改善に取り組んだ話しをします。

非推奨のパッケージを使っていたり、エラーにスタックトレースがついていないことがあるなど、元々混沌とした状況でした。同じような状況を抱えているプロジェクトもあるかと思うので、何らか参考になれば幸いです。

## Before

- エラーにスタックトレースをつけるためのパッケージとして [github.com/pkg/errors](https://github.com/pkg/errors) と [golang.org/x/xerrors](https://pkg.go.dev/golang.org/x/xerrors) の二つが導入されており、混在している。しかも両方現在は非推奨。[^1]

- 標準パッケージの`errors.New()`と`fmt.Errorf()`関数を利用している箇所があり、それらを起点とするエラーにスタックトレースがついていないことがある。

## After

- エラーハンドリングを行う際には必ず独自のパッケージ(`pkg/errors`のラッパー)を使うようにし、それ以外の方法でエラーハンドリングを行うと github actions で警告が出るようにした。これにより、エラーに必ずスタックトレースがつくようにした。

- 今後スタックトレースについて乗り換えたいパッケージが見つかったり標準エラーパッケージの拡張が起きたときに、ラッパーだけ修正すれば済むようになった。

## 改善の手順

1. `x/xerrors`の利用箇所を`errors.New()`と`fmt.Errorf()`関数に置換し、プロジェクトの依存関係から`x/xerrors`を削除する。

2. `pkg/errors`のラッパーを実装する。

3. AST を用いて`pkg/errors`と`errors.New()`、`fmt.Errorf()`をラッパーの関数に置き換えるプログラムを実装し、実行する。

4. `pkg/errors`のインポート及び`errors.New()`と`fmt.Errorf()`の利用に警告を出すための github actions を実装し導入する。

### 1.`x/xerrors`の除去

`x/xerrors`は、Go 1.13 で標準ライブラリに導入されたエラー処理機能のベースとなったパッケージです。バージョンが進んだ現在も使っているのはおかしいので、利用箇所を標準パッケージの`errors.New()`と`fmt.Errorf()`に置換します。

一旦スタックトレースがつかなくなってしまいますが、後の手順によって再度つけています。

### 2.`pkg/errors`のラッパーの実装

基本的には`pkg/errors`の関数をラップしているだけです。`pkg/errors.Errorf()`のみそのままでは`fmt.Errorf()`と互換性がないため、少し工夫しています。

:::details code

```go
package error

import (
	"fmt"
	pkgerrors "github.com/pkg/errors"
)

// msgからトレース付きerrorを生成する
func New(msg string) error {
    return pkgerrors.New(msg)
}

// format文からトレース付きerrorを生成する
func Errorf(format string, args ...interface{}) error {
    // pkgerrors.Errorf()は%wに対応していないため、直接wrapせず以下のようにしてある。
    err := fmt.Errorf(format, args...)
    return pkgerrors.WithStack(err)
}

// errorにトレースをつける
func WithStack(err error) error {
    return pkgerrors.WithStack(err)
}

// errのメッセージをmsgでラップし、トレースも付与する
func Wrap(err error, msg string) error {
    return pkgerrors.Wrap(err, msg)
}

// errのメッセージをフォーマット文でラップし、トレースも付与する
func Wrapf(err error, format string, args ...interface{}) error {
    return pkgerrors.Wrapf(err, format, args...)
}

// errのメッセージをmsgでラップする. トレースは付与しない
func WithMessage(err error, message string) error {
    return pkgerrors.WithMessage(err, message)
}

// errのメッセージをフォーマット文でラップする. トレースは付与しない
func WithMessagef(err error, format string, args ...interface{}) error {
    return pkgerrors.WithMessagef(err, message)
}
```

:::

### 3. AST を用いて`pkg/errors`の利用箇所と`errors.New()`、`fmt.Errorf()`をラッパーの関数に置き換える

ツールのコードは以下になります。

これでは対応しきれないケースがあり手動で置き換えた場所があったり、プロジェクト固有の事情[^2]も考慮しているので、あくまで参考程度になります。

:::details code

```go
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	replacementPkg   = "github.com/CastingONE/castingone/go/pkg/error" // 置き換え後の関数の属するパッケージ
	replacementAlias = "pkgerror"                                      // 固定するエイリアス名
)

func main() {
	rootDir := "../../../../go" // 再帰的に探索するルートディレクトリ

	// 再帰的にディレクトリを歩いてGoファイルを修正する
	err := filepath.WalkDir(rootDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Goファイルだけを対象とする
		if !d.IsDir() && strings.HasSuffix(path, ".go") {
			fmt.Printf("Processing file: %s\n", path)
			if err := processFile(path); err != nil {
				return fmt.Errorf("failed to process file %s: %w", path, err)
			}
		}
		return nil
	})

	if err != nil {
		log.Fatalf("Error walking the path: %v\n", err)
	}
	fmt.Println("全てのファイルの処理が完了しました。")
}

// Goファイルを修正する処理
func processFile(filePath string) error {
	fset := token.NewFileSet()

	// ファイルをパース
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse file: %w", err)
	}

	// インポートパッケージをマッピング
	importMap := make(map[string]string)
	importExists := false
	var importDecl *ast.GenDecl // インポート文の位置を特定するための変数
	replaceOccurred := false    // 置き換えが行われたかどうかを追跡するフラグ

	for _, decl := range file.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.IMPORT {
			importDecl = genDecl
			for _, spec := range genDecl.Specs {
				if importSpec, ok := spec.(*ast.ImportSpec); ok {
					pkgPath := strings.Trim(importSpec.Path.Value, "\"")
					alias := ""
					if importSpec.Name != nil {
						alias = importSpec.Name.Name
					} else {
						// パッケージ名を推定
						parts := strings.Split(pkgPath, "/")
						alias = parts[len(parts)-1]
					}

					importMap[alias] = pkgPath

					// すでに置き換え対象のパッケージがインポートされている場合、エイリアスを"pkgerror"に変更
					if pkgPath == replacementPkg {
						importSpec.Name = ast.NewIdent(replacementAlias)
						importExists = true
					}
				}
			}
		}
	}

	// 関数呼び出しの置き換え
	ast.Inspect(file, func(n ast.Node) bool {
		if callExpr, ok := n.(*ast.CallExpr); ok {
			if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
				if ident, ok := selExpr.X.(*ast.Ident); ok {
					pkgPath, exists := importMap[ident.Name]

					// "github.com/pkg/errors"の関数置き換え
					if exists && pkgPath == "github.com/pkg/errors" {
						ident.Name = replacementAlias
						replaceOccurred = true
					}

					// "errors.New()"の置き換え
					if exists && pkgPath == "errors" && selExpr.Sel.Name == "New" {
						ident.Name = replacementAlias
						replaceOccurred = true
					}

					// "fmt.Errorf()"の置き換え
					if exists && pkgPath == "fmt" && selExpr.Sel.Name == "Errorf" {
						ident.Name = replacementAlias
						replaceOccurred = true
					}
				}
			}
		}
		return true
	})

	// 置き換えが行われた場合にのみインポート文を追加
	if replaceOccurred && !importExists {
		newImport := &ast.ImportSpec{
			Name: ast.NewIdent(replacementAlias),
			Path: &ast.BasicLit{
				Value: fmt.Sprintf("\"%s\"", replacementPkg),
			},
		}

		// インポート文がある場合はその位置に追加、ない場合は新しく作成
		if importDecl != nil {
			importDecl.Specs = append(importDecl.Specs, newImport)
		} else {
			// 新しくインポート宣言を作成
			newGenDecl := &ast.GenDecl{
				Tok:   token.IMPORT,
				Specs: []ast.Spec{newImport},
			}
			// 新しいインポートを最初に追加
			file.Decls = append([]ast.Decl{newGenDecl}, file.Decls...)
		}
	}

	// ファイルの内容をバッファに書き込む
	var buf bytes.Buffer
	if err := format.Node(&buf, fset, file); err != nil {
		return fmt.Errorf("failed to format file: %w", err)
	}

	// 置き換え後の内容をファイルに書き戻す
	if err := os.WriteFile(filePath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}
```

:::

[^1]: `pkg/errors`や`x/xerrors`が誕生した背景、なぜ現在は非推奨なのか等々については複雑な歴史があるわけですが、ここでは触れません。
[^2]: ラッパーは`github.com/CastingONE/castingone/go/pkg/error`というパッケージに配置しているのですが、パッケージ自体は以前から存在しており、さまざまな場所で参照されていました。そのため、置き換えを行った後にインポート文を追加すべきケースと追加すべきではないケースがありました。
