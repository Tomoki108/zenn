---
title: "AtCoder Beginer Contest 313~350 Dまでの要点・解答（Go）"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["atcoder", "go"]
published: true
---

next: [AtCoder Beginer Contest 351~388 D までの要点・解答（Go）](https://zenn.dev/shinonome81/articles/b1de75b0849b32)

※ 個人的なメモ。コードは比較的読み易いと思います。
※ そのトピックにおいて典型的な問題の場合、問題タイトルの後ろにトピックを記載。

# 350

## [A - Past ABCs](https://atcoder.jp/contests/abc350/tasks/abc350_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc350/a/main.go
:::

## [B - Dentist Aoki](https://atcoder.jp/contests/abc350/tasks/abc350_b)

- クエリが少ないので愚直にループ

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc350/b/main.go
:::

## [C - Sort](https://atcoder.jp/contests/abc350/tasks/abc350_c) / Sort

- **未ソート配列について、正しいソート順がわかっていれば最大でも N-1 回のスワップ操作でソートすることができる。**

  - 一つづつ正しい位置にスワップしていけばいい。

- 各数字のインデックスを記録する。1~N の数字について、実際のインデックスと期待するインデックス（num-1）と一致するかみて、一致していなければスワップし、インデックスの記録を更新していけばいい。

- 自前でソートを実装し、スワップ操作にコールバックを挟むようなやり方は厳しい。純粋なスワップ操作をするようなソートアルゴリズムは**バブルソート**などだが、計算量が N^2 なので間に合わない。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc350/c/main.go
:::

## [D - New Friends](https://atcoder.jp/contests/abc350/tasks/abc350_d) / Union Find、連結成分

- 友達の友達も友達にする。これをできなくなるまで繰り返す。これは、グラフの連結成分について、**完全グラフ**（全ての頂点から他の全ての頂点への変が存在する）にするということ。

- **完全グラフの辺の数は $\binom{N}{2}$**

- **Union Find**を用いて、各ノードを連結する。ルートノード毎のサイズから、各**連結成分**（辺で行き来的る範囲）の完全グラフになった時の辺数の和を求めていく。最初に存在していた辺数 M を引けば、答えになる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc350/d/main.go
:::

# 349

## [A - Zero Sum Game](https://atcoder.jp/contests/abc349/tasks/abc349_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/a/main.go
:::

## [B - Commencement](https://atcoder.jp/contests/abc349/tasks/abc349_b)

- マップに文字種ごとの出現回数を記録。そのマップをもとに、出現回数毎の文字種の数を別のマップに記録。

- 1~N までの数字について、後者のマップからその出現回数の文字種の数が 0 か 2 であるかを調べる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/b/main.go
:::

## [C - Airport Code](https://atcoder.jp/contests/abc349/tasks/abc349_c)

- `T = strings.ToLower(T)`で T を小文字に合わせる。
- `T = strings.TrimSuffix(T, "x")`で末尾に x があれば取り除く。（x は S に含まれていても含まれていなくてもどちらでもいい。）
- Ts をループし、中で Ss を最後に見たインデックス+1 から現在探している文字が見つかるまでループし、最後に見たインデックスを更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/c/main.go
:::

## [D - Divide Interval](https://atcoder.jp/contests/abc349/tasks/abc349_d) / 数列の分割、セグメント木

- 定義より、いい数列の `r-l`（=数列の要素数）は 2 の乗数になる。さらに、l, r ともに 2 の乗数の倍数になる。

- 2 の乗数の区間を考えるということで、**[セグメント木](https://algo-logic.info/segment-tree/)** が使えそう。

  - ある区間を 2 の乗数の長さの区間に分割することを考えるということ。
  - 大きな 2 の乗数の長さの区間から貪欲に分割していきたい。

- **セグメント木**とは、ある区間の範囲について、ルートノードには区間全体を、一つ下の階層のノードには左半分と右半分を、...というように**完全二分木**に格納したデータ構造。

- 制約よりあり得る最大の区間`[0, 2^60)`ついて、セグメント木のようなデータ構造を考える。
- 2^60 の長さの区間から順に、入力の`[L, R)`に完全に内包されているかどうかを見ていく。内包されていれば ans スライスに追加し、はみ出た左右の部分があれば同様の処理に再帰的にかけていけばいい。
  - 一度の処理で二つ以上の同じ長さの区間が完全に内包されることはない。そうであるならば、一つ上の二倍のサイズの区間が完全に内包されているはずだから。
  - `O(log N)`になる。完全に内包される区間がいつかは見つかりその際に再帰が止まるため、チェックする階層の数に比例する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/d/main.go
:::

# 348

## [A - Penalty Kick](https://atcoder.jp/contests/abc348/tasks/abc348_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/a/main.go
:::

## [B - Farthest Point](https://atcoder.jp/contests/abc348/tasks/abc348_b) / 全探索

- 各頂点について、他の頂点全てとの距離（の二乗）を計算し最も遠い点を求めても、制約より`O(100 * 99)`にしかならない。変な工夫を考えずに**全探索**する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/b/main.go
:::

## [C - Colorful Beans](https://atcoder.jp/contests/abc348/tasks/abc348_c) / Ordered Set

- N 行の入力を処理しながら、各色のおいしさを**Ordered Set**に突っ込んでいき、後で各色の最も低いおいしさを取り出して、その中の最大を出力すればいけそう。

- ただし色は最大で 10^9 種類存在し、色でループできないので工夫が必要。
  - 『「各色の Ordered Set の min value」の Ordered Set』を作っておく。
  - 「各色の Ordered Set」に更新があるときは、事前に`First()`を取得し『』から`Erace()`、更新後に再度`First()`を取得し『』に`Insert()`する。
  - N 回のループ後に『』の Ordered Set から`Last()`を取得すれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/c/main.go
:::

## [D - Medicines on Grid](https://atcoder.jp/contests/abc348/tasks/abc348_d) / BFS

- エネルギー量をキューアイテムに保持し、**BFS**を行う。ただし探索済みノードの記録において、よりエネルギーの多い状態でのノード再訪は試す価値があるため、bool ではなく残りエネルギー量で訪問を記録する。

- 薬は使うとなくなるが、個別の経路ごとに一度づつ使用可能なため、使っても記録からは消さない。上記の訪問済みノードの記録により、同一経路では二度同じ薬マスに来ない。

- **DFS**での探索も考えたくなるが、DFS では再帰の終了時（呼び出しもとに帰る時）に訪問済みを解除するため、よりエネルギーの少ない状態での訪問済みマスへの無駄な再訪を回避できず TLE になる。
  - エネルギーを無駄にしない効率的な（**最短の**）移動が求められることから、BFS が適していることを感じ取りたい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/d/main.go
:::

# 347

## [A - Divisible](https://atcoder.jp/contests/abc347/tasks/abc347_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/a/main.go
:::

## [B - Substring](https://atcoder.jp/contests/abc347/tasks/abc347_b) / 全探索

- 部分文字列の長さは最大 100。部分文字列の取り方も最大 100。全探索が 100^2 に収まるので、スマートなやり方を考えずに**全探索**する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/b/main.go
:::

## [C - Ideal Holidays](https://atcoder.jp/contests/abc347/tasks/abc347_c) / 円環

- １週間という**周期**の中で、各休日がどこに位置するかを考えたいので、各休日の日付を周期の長さ A+B で割った余り（rem）に変換する。

- 同じ位置の休日のデータが重複しても仕方ないので、rem を map に突っ込んで、map のキーからスライスに変換する。そしてソート。

- 休日の位置関係で考えると難しい。**逆側**の、平日について考える。平日が B 日以上連続している区間が存在すれば、条件を満たしていると問題文を言い換えることができる。

- `rems[i] - rems[i-1] - 1`で休日の間に何日平日が存在しているかが分かる。
  - **円環**を跨ぐ`i == 0`の時は工夫が必要で、`rems[i] - 1　+ (weekdays - rems[len(rems)-1])`とする必要がある。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/c/main.go
:::

## [D - Popcount and XOR](https://atcoder.jp/contests/abc347/tasks/abc347_d) / XOR（排他的論理和）

- **XOR（排他的論理和）** は、A と B のどちらかが一方のみが true なら true、それ以外は false。go の演算子は`xor := A ^ B`

- C を二進数表現にしてみる。`X ^ Y == C`となる （|C|桁の）X、Y は、（C、0）に加え、前者から任意の桁のビットをおり、後者の同じ桁のビットを立てる操作を任意の回数繰り返すことで列挙することができる。

  ```
  C: 7 => 111

  =>
  111 | 000
  110 | 001
  101 | 010
  ...
  ```

- よって|C|桁までの X と Y の、`popcount(X)+popcount(Y)`は常に `popcpount(C)`と一致することがわかる。そして、以下の場合に条件を満たす X、Y は存在しないことがわかる。

  - `a + b < popcpount(C)`
  - `abs(a-b)%2 != popcpount(C)%2`
    - `popcpount(C)`が偶数なら、幾つビットを受け渡しても X と Y の popcount の差は偶数にしかならないため。
  - `abs(a-b) > popcpount(C)`
    - 最大の差分は（C、0）の時の`popcpount(C)`であるため。

- 上記を弾いたのち、 X、Y を(C, 0)または(0, C)で初期化し、適切な diff になるまでビットを受け渡す。

- その後、所定の `popcount(X)（=a）`、`popcount(Y)（=b）`に達するまで無害な方法でビットを足して行けばいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/d/main.go
:::

# 346

## [A - Adjacent Product](https://atcoder.jp/contests/abc346/tasks/abc346_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/a/main.go
:::

## [B - Piano](https://atcoder.jp/contests/abc346/tasks/abc346_b) / 無限数列、円環

- **無限数列の条件に合う部分列を探すときは、2 周期分の数列を探索することで全ての部分列が探索できる。**

  - **指定の部分列の長さが一周期分を超えるときは、両側にはみ出す区間のパターンだけ考えればよく**、それが上記で探索できるということ。

- よって`部分列の長さ：W+B%12`、`探索する数列の長さ：24`となり、最大 24 回の探索で答えが判定できるので、**全探索**する。

- 類題：[384 D - Repeated Sequence](http://localhost:8000/articles/b1de75b0849b32#d---repeated-sequence-%2F-%E7%84%A1%E9%99%90%E6%95%B0%E5%88%97%E3%80%81%E5%B0%BA%E5%8F%96%E6%B3%95-or-%E5%86%86%E7%92%B0-%2B-%E7%B4%AF%E7%A9%8D%E5%92%8C)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/b/main.go
:::

## [C - Σ](https://atcoder.jp/contests/abc346/tasks/abc346_c) / 等差数列の和の公式

- As をソートし、`As[i] - As[i-1] => 1`なら間に飛ばされている整数があるので、その飛ばされている数字の合計を**等差数列の和の公式**で求めればいい。

- ただし、0 から As[0]の間で飛ばされている数も見つけたいので、As に 0 をアペンドしておく。

- K までの間に飛ばされている数字がないかどうか見たいので、As に K が含まれていると K に到達したイテレートでループを break できるので都合がいい。K が含まれていなければ K をアペンドし、飛ばされている数の合計に K を足しておく。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/c/main.go
:::

## [D - Gomamayo Sequence](https://atcoder.jp/contests/abc346/tasks/abc346_d) / 累積和

- どこで周期を変えるかは非自明であるため、その探索 O(N)はやらざるを得ない。よって、効率的にコストを計算する必要がある。

- N 文字の良い文字列とは、N 文字の`01`周期の繰り返し文字列（zeroOneSeq）と`10`周期の繰り返し文字列（oneZeroSeq）を用意し、index 0 ~ i が片方のもの、index i+1 ~ N-1 がもう一方のものになっている文字列であると**言い換えられる**。（0 < i < N-1）

- oneZeroSeq、zeroOneSeq を作るためのコストの**累積和**を作成しておき、周期の境目ごとのコストを累積和から算出していけば、O(N)で最小コストが求められる。

  - `oneZeroSeq => zeroOneSeq`と`zeroOneSeq => oneZeroSeq` の順番があり得ること、累積和（長さ N+1）からの値の取り出し方に注意する。

- 類題: [334 C - Socks 2](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#c---socks-2-%2F-組み合わせ、累積和)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/d/main.go
:::

# 345

## [A - Leftrightarrow](https://atcoder.jp/contests/abc345/tasks/abc345_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc345/a/main.go
:::

## [B - Integer Division Returns](https://atcoder.jp/contests/abc345/tasks/abc345_b)

- 愚直。go の割り算（`/`演算）は切り捨て。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc345/b/main.go
:::

## [C - One Time Swap](https://atcoder.jp/contests/abc345/tasks/abc345_c)

- スワップによって文字列が変化するのは、ある`Ss[i]`を別の文字種である`Ss[j]`とスワップしたとき。

- 文字種ごとに考えたいので、とりあえず`map[char]count`のマップにする。

- 各文字種ごとに、それらの文字以外とスワップするとユニークな文字列になる。

  - ループで数え上げ可能だが、ある index x, y について、`(i: x, j: y)`と`(i: y, j: x)`の 2 通りについて重複加算することになってしまう。（というより本来 i < j となる組み合わせのスワップしか許容されない。）なので、最後に数え上げを 2 で割る。

- あるスワップをして、オリジナルの S と全く変わらないものができても答えに１加算するべきなので、同じ文字種が２つ以上ある場合はそうする。（サンプルケースが教えてくれている。）

```go
sum := 0
sameChars := false
for _, count := range m {
  sum += count * (len(Ss) - count)
  if count >= 2 {
    sameChars := true
  }
}
sum = sum / 2
if sameChars {
  sum++
}
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc345/c/main.go
:::

## [D - Tiling](https://atcoder.jp/contests/abc345/tasks/abc345_d) / ポリオミノ、ビット全探索、順列

- **ポリオミノ系の問題は基本全探索で解く。**

  - 空きマスの最も左上からタイルを配置していき、グリッドからはみ出したり配置済みのタイルと被ると失敗。失敗せずにグリッドがすべて埋まれば（=空きマスが見つからない状態になれば）成功。

- $配置のパターン数 = タイルを使う順番 * 各タイルを縦横どちらで使うか = 7! * 2^7 = 645120$

  - 各タイルを縦横どちらで使うかは**ビット全探索**する。

- さらにタイルを置くたびに以下を行うため$O(200 * 645120) = O(129024000)$となるが、十分現実的。

  - タイルのマスが使用済みではないか調べつつ、使用済みの記録をする：10^2
  - グリッドをさらって最も左上の空きマスを調べる：10^2

- **`NextPermutation()`で順列に対してロジックを適用するときは、オリジナルの順列への適用を事前に別で書く必要がある。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc345/d/main.go
:::

# 344

## [A - Spoiler](https://atcoder.jp/contests/abc344/tasks/abc344_a)

- `Ss = append(Ss[:barIdx1], ...Ss[barIdx2+1:])`で該当区間を取り除く。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/a/main.go
:::

## [B - Delimiter](https://atcoder.jp/contests/abc344/tasks/abc344_b)

- `for true {}`で 0 が登場するまで行を読み込んでスライスに追加。最後にスライスを反転。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/b/main.go
:::

## [C - A+B+C](https://atcoder.jp/contests/abc344/tasks/abc344_c)

- Xi ごとに全探索すると、$O(Q * (N * M * L)) = O(3*10^8 * 100^3)$となり間に合わない。

- 問題の性質上 Xi ごとのループは必ずするので、Xi が作成可能かを高速に判定する必要がある。

- A, B, C の組み合わせをあらかじめ全探索（$O(100^3)$）して和をマップに記録しておけば、マップへのアクセスのみで各クエリを処理でき間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/c/main.go
:::

## [D - String Bags](https://atcoder.jp/contests/abc344/tasks/abc344_d) / DP（メモ化再帰）

- 全探索すると $O(袋の要素数^{袋の数}) = O(10^{10})$ となり間に合わない。

- 問題の性質上、順に各袋から要素を取る（またはとらない）、次の袋にいく...という処理はせざるを得ないと考えられるので、再帰を使いそう。

- **DP（メモ化再帰）** で枝狩りができないかを考える。「ある袋まで処理し終わっている」「T があるインデックスまで完成している」という状態が同じなら、**それまでの経過は関係ない。**

  - **これを管理する状態とし、状態ごとのコストをメモ化する。**
  - ある状態に到達した時に、コストがメモ化されていなければさらに再帰して先に進む。
  - メモ化されているコストより低いコストで到達したならメモを更新し、更に再帰して先に進む。それ以上のコストで到達したなら処理を打ち切る。

- DP（メモ化再帰）の計算量はとりうる状態の数による。今回は以下のようになり間に合う。
  - $O(袋の数 * len(T) * コストとして取りうる値) = O(10 * 100 * 10) = O(10000)$
  - 数え上げのような問題と違いメモ化された値によっても再帰が進む可能性があるので、それも計算量においては状態と見なされる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/d/main.go
:::

# 343

## [A - Wrong Answer](https://atcoder.jp/contests/abc343/tasks/abc343_a)

- 愚直。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc343/a/main.go
:::

## [B - Adjacency Matrix](https://atcoder.jp/contests/abc343/tasks/abc343_b)

- 愚直。何も出力しない場合は空行を１行のみ出力することに注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc343/b/main.go
:::

## [C - 343](https://atcoder.jp/contests/abc343/tasks/abc343_c) / 整数問題（最大のいい数）

- まず立方数のみについて考える。最大の K を考える。$N = 10^{18} = (10^6)^3 より、 K = 10^6$（**数式の変形**）

- よって検討すべき K は 0 ~ 10^6 であり、100 万個。立方数も同様に 100 万個。**全探索**できそう。

- 立方数のスライスを用意しておき、N より大きいインデックスを二分探索し、-１する。そこから回文判定のループをインデックスをデクリメントしながらする。

- 回文判定のコストは`文字数/2`で、n は最大でも 7 桁なので全探索が十分間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc343/c/main.go
:::

## [D - Diversity of Scores](https://atcoder.jp/contests/abc343/tasks/abc343_d)

- ユニークな要素の数を考えたいのでマップを上手く使えばいい。二分探索等はしないので Ordered Set は使う必要がなく、通常のマップで事足りる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc343/d/main.go
:::

# 342

## [A - Yay!](https://atcoder.jp/contests/abc342/tasks/abc342_a)

- マップで文字種の出現数をカウント。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/a/main.go
:::

## [B - Which is ahead?](https://atcoder.jp/contests/abc342/tasks/abc342_b)

- マップに各番号（の人）の出現位置を記録。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/b/main.go
:::

## [C - Many Replacement](https://atcoder.jp/contests/abc342/tasks/abc342_c) / メモ化

- 文字列を更新する作業はせざるを得ないため、N（2×10^5）のループは無くせない。つまり、ある文字が最終的にどの文字になるのかを高速に判定する必要がある。

- クエリを処理しながらある文字が最終的にどの文字になったのかを**メモ化**するか、あらかじめ a-z が何になるのかをメモ化しておく。

  - 計算量は $O(N + 26*Q) = O(5400万)$
  - **アルファベットが 26 文字しかないことに着目する問題。**

- **このようなデータ遷移を木のようなデータ構造に記録し、あるデータに対応する最終的な状態を高速に取り出すのは簡単ではない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/c/main.go
:::

## [D - Square Pair](https://atcoder.jp/contests/abc342/tasks/abc342_d) / 整数問題（いい数の個数）、素因数分解、平方数、合同式

- **平方数**は$(a^x)^2 * (b^x)^2 + ...$と表現でき、逆にこのような数は平方数である。

  - よって、**平方数の素因数の指数は全て 2 の倍数である。**

- 整数 A, B の積が平方数になるのは、素因数の指数の和が全て 2 の倍数になっている時。
  - $(a^p * b^q) * (a^r * b^s)$ が平方数であるとき、
  - $p + q \equiv r + s \equiv 0 \mod 2$
  - $(p \mod 2) + (q \mod 2) \equiv (r \mod 2) + (s \mod 2) \equiv 0 \mod 2$
  - つまり指数を 2 で割った余りに変換し、全ての素因数の指数が 0,0 または 1,1 の組み合わせになっているなら、平方数になる。
  - **各 Ai に対して素因数分解をし、素因数の指数を 2 で割った余りに変換し、それらを掛け合わせた値にする。こうして変化させて値が同じになった Ai 同士は、掛け合わせると平方数の条件を満たす。**
  - よって各 Ai を変化させ、変化後に同じ値がいくつあるかを map に格納する。そして map の key ごとに ${}_{value} C_{2}$ を求めてたしあげればいい。
  - ただし A, B いずれかまたは両方に０が含まれる場合は必ず平方数になるので、そこだけ別で考える。
    - 0 を少なくとも片方で使う組合わせ：${}_{len(As)} C_{2} - {}_{len(As)-len(map[0])} C_{2}$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/d/main.go
:::

# 341

## [A - Print 341](https://atcoder.jp/contests/abc341/tasks/abc341_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc341/a/main.go
:::

## [B - Foreign Exchange](https://atcoder.jp/contests/abc341/tasks/abc341_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc341/b/main.go
:::

## [C - Takahashi Gets Lost](https://atcoder.jp/contests/abc341/tasks/abc341_c)

- グリッドサイズ 500^2、実行時間 3sec という制約から、**全探索**が間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc341/c/main.go
:::

## [D - Only one of two](https://atcoder.jp/contests/abc341/tasks/abc341_d) / 整数問題（K 番目のいい数）、二分探索

- N と M の倍数を列挙すると、N\*M の周期になっている。（どちらの倍数が何番目に出てくるか。）K を周期の長さで割り、余りを順に列挙する方法を考えた。しかし制約より余りの最大は(10^8)^2 なので、厳しい。

- `0~K-1`で No になり、`K~INT_MAX`で Yes になるような条件があれば、**二分探索**が使える。

  - `f(x) = x以下の条件に当てはまる倍数`を実装し、`f(x) >= K`という条件で二分探索すれば、目当ての値が見つけられる。

- 制約より、探索範囲の上限は`10^8*10^10`でいい。
  - `A <= B` とし、B が`10^8`、K が`10^10`だった場合、`10^8*10^10`までの範囲に K 個以上の条件に当てはまる倍数がし存在するため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc341/d/main.go
:::

# 340

## [A - Arithmetic Progression](https://atcoder.jp/contests/abc340/tasks/abc340_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/a/main.go
:::

## [B - Append](https://atcoder.jp/contests/abc340/tasks/abc340_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/b/main.go
:::

## [C - Divide and Divide](https://atcoder.jp/contests/abc340/tasks/abc340_c) / メモ化再帰

- 2 以上の数字について、「数字分のコストを総コストに加算し、分割する」を再帰的に繰り返すので、**メモ化再帰**が使える。

- **計算量はとりうる状態＝メモの数になる。**

- $2^{63} \approx 10^{19}$ ということを覚えておけば、再帰的に二分割を行ってできる階層は 63 以下になることがわかる。一階層ごとに最大二種類の値が生まれる（奇数を分割する場合）ので、計算量は$O(126)$以下になり間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/c/main.go
:::

## [D - Super Takahashi Bros.](https://atcoder.jp/contests/abc340/tasks/abc340_d) / ダイクストラ法、優先度付きキュー（ヒープ）

- **ダイクストラ法**で解く。以下基本の tips。

  - グラフを作成するときは、`var graph [][][2]int // [node: [[node, weight],  ...], ...]`のような型になる
  - **優先度付きキュー**の要素は、`type item {node, weight int} // weightは始点からの距離`のような型になる。
  - **確定済みノード、各ノードの始点からの距離を別々のマップで管理する必要がある。**

- 類題: [362 D - Shortest Path 3](http://localhost:8000/articles/b1de75b0849b32#d---shortest-path-3-%2F-%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95%E3%80%81%E5%84%AA%E5%85%88%E5%BA%A6%E4%BB%98%E3%81%8D%E3%82%AD%E3%83%A5%E3%83%BC%EF%BC%88%E3%83%92%E3%83%BC%E3%83%97%EF%BC%89)

---

- 通常のダイクストラ法だと最短距離（時間）しか求められないが、距離（時間）を記録するときに prev node を一緒に記録しておくと、最後にそこから辿って経路も求めることができる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/d/main.go
:::

# 339

## [A - TLD](https://atcoder.jp/contests/abc339/tasks/abc339_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/a/main.go
:::

## [B - Langton's Takahashi](https://atcoder.jp/contests/abc339/tasks/abc339_b)

- ドーナツの表面の様な構造をトーラス状の曲面という。

- 愚直。

- **グリッドで上に行く場合、h-1 する！下に行く場合 h+1 する！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/b/main.go
:::

## [C - Perfect Bus](https://atcoder.jp/contests/abc339/tasks/abc339_c)

- `minStart := 0`で初期化しクエリを処理する。矛盾が生じたら minStart を辻褄が合う様にインクリメントする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/c/main.go
:::

## [D - Synchronized Players](https://atcoder.jp/contests/abc339/tasks/abc339_d) / BFS（グリッド）

- **最短**操作回数を求めるので、**BFS**。プレイヤー二人の位置の組み合わせより、$O(60^2 * 60^2)$となる。

- 試したプレイヤー二人の位置関係を記録する必要がある。**メモは 60^4 と巨大なので、マップだと遅い。** ４重スライスで管理する。（マップでもあらかじめサイズを最大数で初期化しておくと、ギリギリ TLE しない。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/d/main.go
:::

# 338

## [A - Capitalized?](https://atcoder.jp/contests/abc338/tasks/abc338_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc338/a/main.go
:::

## [B - Frequency](https://atcoder.jp/contests/abc338/tasks/abc338_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc338/b/main.go
:::

## [C - Leftover Recipes](https://atcoder.jp/contests/abc338/tasks/abc338_c) / 資源配分問題

- **料理 A を最大どのくらい作れるのかをとりあえず求める。** 全種類の材料の在庫/必要量の min になる。

- このとき料理 B がどのくらい作れるのかも、全種類の材料の在庫/必要量の min になる。(O(10))

- 料理 A のを最大量~0 作る場合についてこれをやればいいので、$O(10^6 * 10)$ で解くことができる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc338/c/main.go
:::

## [D - Island Tour](https://atcoder.jp/contests/abc338/tasks/abc338_d) / 円環、imos 法

- **サンプルが弱いので、適当な例を考える。**
  ```
  5 4
  1 3 2 5 3
  ```
- **各経路は独立で考えても良い**ので、`(1, 3), (3, 2), (2, 5), (5, 3)`の経路の距離の和について考えればいい。

- また、**経路の始点と終点を入れ替えても距離に影響しない**ので、`(始点 < 終点)`となる様にソートする。

- **円環を切り開いた数直線を書く。**

- 例えば`(2, 3)`の区間に関して、`[2, 3) = [s, t])`の間の辺が封鎖されると距離が 4 になり、それ以外=`[1, 2) = [0, s)]`または`[3, 5) = [t, N)`の間の辺が封鎖されると距離が 1 になることがわかる。
  :::details image
  ![image](/images/ABC/338/d.png)
  :::

- 「ある区間内の辺が封鎖されると、ツアーの総距離にある数字が足される」と解釈できる。これは区間更新なので、**imos 法**で効率化可能。

- 「index i の要素は、`[島i+1, 島i+2)`の辺を封鎖したときのツアーの総距離 (最後の要素は`[島N, 島1]`の辺を削除した時の~)
  」**という長さ N+1 の int スライスを作成することができれば、最小の要素の値が答えになる。**

- 全ての要素を 0 で初期化した N+1 の長さの int スライスを作成する。経路でループし、ある区間が封鎖されるとその経路の距離が X になる（ツアーの総距離に X プラスとなる）という情報を int スライスに **imos 法**で反映していけば、最終的に作りたいスライスの**差分配列**になる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc338/d/main.go
:::

# 337

## [A - Scoreboard](https://atcoder.jp/contests/abc337/tasks/abc337_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/a/main.go
:::

## [B - Extended ABC](https://atcoder.jp/contests/abc337/tasks/abc337_b)

- **ランレングス圧縮**をし、圧縮後のスライス長が３以下か、文字種の並びが期待する並び（ex, {A, B, C}, {B, C}, {A}, etc..）のいずれかと一致しているかで判定。

- `reflect.DeepEqual()`はスライスの中身の順序も含めて判定してくれる。

- 期待する並びはベタガキで列挙したが、**ビット全探索**でもいける。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/b/main.go
:::

## [C - Lining Up 2](https://atcoder.jp/contests/abc337/tasks/abc337_c) / Linked List、再帰

- `map[前にいる人の番号]自分の番号`を作成しておくと、先頭の人から順に再帰関数を使って辿ることができる。（map から何も見つからない＝自分の後ろに誰もいない場合に終了する。）

- **Linked List**に更新していき、最後にダンプしてもいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/c/main.go
:::

## [D - Cheating Gomoku Narabe](https://atcoder.jp/contests/abc337/tasks/abc337_d) / キュー、累積和

- 各行各列について、K 目が成立するか調べたい。

- 行・列の長さ K の部分区間について、高速に何回で K 目並べられるかを調べたい。

- 行、列ごとに**キュー**を使ってセルの値を格納していき、

  - `o`なら`oCount++`
  - `x`なら`q.Clear()`
  - `.`なら何もしない
  - 長さが K より多いなら`q.Pop()`して要素を減らし、`o`が出てきたら`oCount--`する。
  - その後 K 以上なら`q.Size()-oCount`で答えの更新を試みる。

- あるいは予め行、列ごとに`x, o, .`の数の**累積和**を作成しておき、それを元に書く長さ K の部分区間について高速に計算する手もある。。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/d/main.go
:::

# 336

## [A - Long Loong](https://atcoder.jp/contests/abc336/tasks/abc336_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc336/a/main.go
:::

## [B - ctz](https://atcoder.jp/contests/abc336/tasks/abc336_b)

- 愚直に後ろからビットポップ判定

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc336/b/main.go
:::

## [C - Even Digits](https://atcoder.jp/contests/abc336/tasks/abc336_c) / 整数問題（K 番目のいい数）、N 進数 or 桁 DP（メモ化再帰） + 二分探索

### 5 進法

- いい数は５つの数字を使って表現されるので、5 進法と同じ。

- N 番目の 5 進数の数字は N を５進数に変換したもの、と思いきや N-1 を 5 進数に変換したもの。0 を１番目と数えるので。

  - `strconv.FormatInt(int64(N), 5)`

- 実際は`0~4`ではなく`0,2,4,6,8`を使っているので、その対応をマップで作成しておき、５進数を変換して出力する。

- 類題: [372 B - 3^A](https://zenn.dev/shinonome81/articles/b1de75b0849b32#b---3%5Ea-%2F-%E6%95%B4%E6%95%B0%E5%95%8F%E9%A1%8C%E3%80%81n-%E9%80%B2%E6%95%B0-or-%E8%B2%AA%E6%AC%B2%E6%B3%95)

### 桁 DP（メモ化再帰）+二分探索

- $f(x) = x以下のいい数の個数$ を実装して、`AscIntSearch(0, INT_MAX, func(num int) {return f(num) >= K})`として**二分探索**すればいい。

- 上限以下の条件に合う数の個数の計算は、**桁 DP（メモ化再帰）** で求められる。

  - `var digitDP func (pos, strict int) int // pos: 左から何桁目まで決定済みか、strict: 埋まっている桁が上限のそれと全て一致しているか`を実装すればいい。
  - 一段目の関数呼び出しは`{0, 2, 4, 6, 8}`で行い、一桁目が上限のそれと一致しているときは`strict=true`

- **桁 DP の計算量はとりうる状態と一致する。** $O(pos * strict) = O(19 * 2)$

- **0~INT_MAX（2^63）の二分探索は最大 63 回行われる**ので、$O(19 * 2 *63) = O(2394)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc336/c/main.go
:::

## [D - Pyramid](https://atcoder.jp/contests/abc336/tasks/abc336_d)

- **ピラミッド型は考えづらいので、右側と左側の階段型について考える。**

- ある$A_i$が頂点だとして、左側だけを考慮した時の最大の高さは、$height(A_i) = min(height(A_{i-1})+1, A_i)$

- このように全ての Ai に対して左側だけを考慮した高さを index 0 から出していき、右側だけを考慮した高さを index N から出していく。その後全ての頂点について`min(lHeight, rHeight)`でとりうる高さを出し、最大の高さを記録更新すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc336/d/main.go
:::

# 335

## [A - 202<s>3</s>](https://atcoder.jp/contests/abc335/tasks/abc335_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/a/main.go
:::

## [B - Tetrahedral Number](https://atcoder.jp/contests/abc335/tasks/abc335_b)

- 0~N の三重ループを回し、それぞれの和が条件に合うかを判定すればマッチする x, y, z の組み合わせを**辞書順**に列挙できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/b/main.go
:::

## [C - Loong Tracking](https://atcoder.jp/contests/abc335/tasks/abc335_c)

- 移動クエリごとに頭の座標が変化し、それ以外の座標が前のパーツの以前の座標にスライドする。

- 尻尾~頭の順で座標をスライスに格納し、移動クエリの際は`sl = appen(sl[1:len(sl)-1], newCoodinate)`とすれば、O(1)で座標を更新できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/c/main.go
:::

## [D - Loong and Takahashi](https://atcoder.jp/contests/abc335/tasks/abc335_d) / グリッド（応用）

- 出力するパターンを決める。サンプル 1 の渦巻き状にする。

- スタート位置、一片の長さを渡せばグリッド内の四角の四辺を埋めてくれる関数を実装して、再帰呼び出しをすれば問題が解ける。
  - 渦巻きが再帰的な構造になっていることに気づき、**どんな関数を実装すれば処理ができるかを考える。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/d/main.go
:::

# 334

## [A - Christmas Present](https://atcoder.jp/contests/abc334/tasks/abc334_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/a/main.go
:::

## [B - Christmas Trees](https://atcoder.jp/contests/abc334/tasks/abc334_b) / 数直線

- **R, L に-A し、[R, L]の区間の $X \equiv A \mod M$ ではなく $X \equiv 0 \mod M$ となる X の数を数えることにする。**

- R 以下の最も R に近い $K_r*M$ の $K_r$ を求め、L-1 以下の最も L-1 に近い $K_{l-1}*M$ の $k_{l-1}$を求める。

- $K_r - K_{l-1}$が答えとなる。R, L-1 が両方ゼロ以上の場合、R, L-1 が 0 を跨ぐ場合、R, L-1 が両方ゼロ以下の場合を考えると、全てでそうなる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/b/main.go
:::

## [C - Socks 2](https://atcoder.jp/contests/abc334/tasks/abc334_c) / 組み合わせ、累積和

- [数学的な証明](https://atcoder.jp/contests/abc334/editorial/8983)は難しいが、捨てられていない靴下はそのままペアにすることが最善であることが直感的に分かる。

- 片方が捨てられて余っている靴下について、どうペアを組むのが最善かを求める。余りが偶数の場合は、(0, 1), (1, 2), ...をペアにするのが最善。

- 余りが奇数の時に、どの靴下を使わないのが最善かを求める問題になる。奇数インデックスの靴下を削除し、その左右で隣り合う靴下をペアにすることになる。（偶数インデックスだと、削除した靴下を挟んでペアを作らなければいけない組みが１つできてしまい、明らかに最善ではない。）

- 靴下は、直前の靴下あるいは直後の靴下のいずれかとペアになる。index 0 始まりのペア作成と、index 1 始まりのペア作成を考え、それぞれの場合の奇妙さの**累積和**配列を作る。（As を二つ見て prefSum を一つ埋めるというズレがあるのにループの実装では注意。）

- 使わない靴下を挟んで、左側が前者の累積和の値を採用し、右側が後者の累積和の値を採用することになる。実装は以下の通り。
  ```go
  for i := 0; i<prefSumLen; i++; {
    oddity := prefSumZeroStart[i] + prefSumOneStart[prefSumLen-1] - prefSumOneStart[i]
    ans = min(ans, oddity)
  }
  ```
- 類題: [346 D - Gomamayo Sequence](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#d---gomamayo-sequence-%2F-%E7%B4%AF%E7%A9%8D%E5%92%8C)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/c/main.go
:::

## [D - Reindeer and Sleigh](https://atcoder.jp/contests/abc334/tasks/abc334_d) / 貪欲法、累積和、二分探索

- 各クエリに対して、必要なトナカイの少ないソリから**貪欲に**トナカイを割り当てた方がいい。

- 各ソリに必要なトナカイの数を、昇順にソートする。**累積和**の配列にすると、`sort.Search(N+1, func (i int) bool { retunr prefsum[i] > X)`で**二分探索**すると、運べるソリの数が分かる。
  - 累積和の配列は、長さ N+1 であることに注意。（index 0 に 0 が入っているため。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/d/main.go
:::

# 333

## [A - Three Threes](https://atcoder.jp/contests/abc333/tasks/abc333_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/a/main.go
:::

## [B - Pentagon](https://atcoder.jp/contests/abc333/tasks/abc333_b) / 図形、円環

- 各頂点のインデックスのスライスを作る。頂点 1 のインデックスを 0, 頂点 2 のインデックスを 1, ..., 頂点 5 のインデックスを 5 とする。

- 頂点 a, b の距離は、以下のように計算できる。
  ```go
    a, b = sortIntAsc(a, b)
    dist := min(b-a, 5-(b-a))
  ```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/b/main.go
:::

## [C - Repunit Trio](https://atcoder.jp/contests/abc333/tasks/abc333_c) / 整数問題（K 番目のいい数）、全探索（全列挙後にソート）

- 条件に合致する数（Repunit Trio）を**全列挙**することができる。

  - Repunit は桁数毎に一種類なので、INT_MAX が 19 桁なことから 19 種類。19^3 は十分列挙可能。
  - `rep(i=1~max)(j=i~max)(k=j~max)`のループで、**順列**を**辞書順**に列挙できる。

  ```go
  	sl := make([]int, 0, pow(19, 3))
    // 上限は18桁に設定。19桁だと最後のイテレートでオーバーフローでマイナスになって無限ループ
    // 問題の制約より、上限ギリギリの巨大なRepUnitはなくても大丈夫。
    for i := 1; i <= 111111111111111111; i += pow(10, GetDigits(i)) {
  	  for j := i; j <= 111111111111111111; j += pow(10, GetDigits(j)) {
  	  	for k := j; k <= 111111111111111111; k += pow(10, GetDigits(k)) {
  	  		sl = append(sl, i+j+k)
  	  	}
  	  }
    }
  ```

- **順列の辞書順が Repunit Trio の小さい順ではないことに注意。** $1 + 1 + 1111 > 11 + 11 + 111$

- ソート後に、N 番目の数を出力すればいい。

- **サンプル 3 が使うマックスの Repunit の桁数を教えてくれている。制約で N が小さいことのメリットを教えてくれている。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/c/main.go
:::

## [D - Erase Leaves](https://atcoder.jp/contests/abc333/tasks/abc333_d) / 木、dfs（ノードカウント）、累積和

- **問題の言い換え**：葉ノードが削除可能 => 始点ノードを葉にする => 始点に隣接する N 個のノードの「自身を含めた下位ノードの数」を求め、最もその数が多い隣接ノード以外について、下位ノードを全て削除すればいい。

- **dfs**で自身を含む下位ノードの数を記録できる。

- 始点隣接ノードの記録をソートし**累積和**を作成し、`prefsum[len(prefsum)-2]`をとれば答えになる。

- 類題：[368 D - Minimum Steiner Tree](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---minimum-steiner-tree-%2F-%E6%9C%A8%E3%80%81dfs%EF%BC%88%E3%83%8E%E3%83%BC%E3%83%89%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%EF%BC%89)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/d/main.go
:::

# 332

## [A - Online Shopping](https://atcoder.jp/contests/abc332/tasks/abc332_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc332/a/main.go
:::

## [B - Glass and Mug](https://atcoder.jp/contests/abc332/tasks/abc332_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc332/b/main.go
:::

## [C - T-shirts](https://atcoder.jp/contests/abc332/tasks/abc332_c)

- 現在の `RequireAnyT`、`RequireLogoT` を記録、各 `Max` の更新を試みる。洗濯の日は `Require` をリセットする。

- LogoT を着る日に、`RequireAnyT` 及び `MaxRequireAnyT`の方も更新することに注意！

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc332/c/main.go
:::

## [D - Swapping Puzzle](https://atcoder.jp/contests/abc332/tasks/abc332_d) / グリッド（応用）、BFS

- **グリッドの列の入れ替え、行の入れ替えで発生する盤面のパターンは、$行の順列 * 列の順列 = H! * W!$ となる。**

  - $マス目の順列 = (H*W)!$ ではない。

- 今回の場合は $5! * 5! = 120^2$ パターンなので、**全探索**できる。

- **最短手数**を求める問題なので**BFS**。
  - visited map のキーはグリッドを文字列に変換して作る。
  - キューアイテムにはグリッドそのものを持たせる。
  - 行入れ替えまたは列入れ替えをする直前にコピーを作成し、そのコピーから次のキューアイテムを作る。隣接ノードをあらかじめ隣接リストに保持するのではなく、移動を行う直前に作成することを、**グラフを陽にもたない**という。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc332/d/main.go
:::

# 331

## [A - Tomorrow](https://atcoder.jp/contests/abc331/tasks/abc331_a)

- 超過した日月を%演算で丸めたら 1WA になったので、よりミスしにくい大小比較を使った。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/a/main.go
:::

## [B - Buy One Carton of Milk](https://atcoder.jp/contests/abc331/tasks/abc331_b) / 資源配分問題、全探索

- 制約の狭さから全列挙できそう。６, 8, 12 個入りは最大`N/6+1`, `N/8+1`, `N/12+1`個買える。三重ループして、`6*i+8*j+12*k >= N`なら minAns の更新を試みればいい。

- N が 6, 8, 12 のいずれか割り切れる場合は不必要に個数を 1 を足していたり、そもそも N を大幅に超える個数の組み合わせも試しているが、**最小金額を求める問題なので問題ない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/b/main.go
:::

## [C - Sum of Numbers Greater Than Me](https://atcoder.jp/contests/abc331/tasks/abc331_c) / 累積和

- $A_i$ より大きな要素の総和を求めるということで、As をソートして**累積和**を取れば良さそう。
- ただし同じ数字が重複しているときは、$prefsum_{N} - prefsum_{i+1}$ をとっても、自身と同じ数字も加算されてしまっている。
- `map[num]sum`を作り、**累積和をイテレートするときに`num := prefsum[i]-[i-1]`として A を復元**すれば、自身と同じ数を含まない累積和の値でマップの値を上書きできる。
- 最後に As でイテレートして、マップから答えを取得して出力すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/c/main.go
:::

## [D - Tile Pattern](https://atcoder.jp/contests/abc331/tasks/abc331_d) / 二次元累積和、包除原理

- 四角形の面積（含まれる何かの個数などでも可）を考えるときは、**右下一点を指定することで`原点-その点`の四角形の面積をだせる関数を実装し**、以下のような範囲を考えることで**包除原理**で目当ての面積が導き出せる。 （これはグリッドバージョンで、座標平面なら`f(右上)`を実装する。）

  :::details imgae この図を書いて思い出してもいい。
  ![image](/images/ABC/331/331_d_image1.png)
  :::

- `ans := f(C, D) - f(C, B) - f(A, D) + f(A, B)`

  - **引数に渡す前に A, B を 1 づつデクリメントするか、C, D を１つづインクリメントすることが、関数 f の実装を考える上で重要。**

- 関数 f の実装：ある点と原点を含む四角形に、周期（とそのパーツ、その中に含まれる黒マス）がいくつ含まれるのかは、以下の図のように考えられる。**詳細は実装およびコメントを参照。**

  :::details imgae
  ![image](/images/ABC/331/331_d_image2.png)
  ![image](/images/ABC/331/331_d_image3.png)
  :::

- **この手の問題でも実装は綺麗にできることが多いので、こんがらがったらやり方を見直す。**

- 類題：[354 D - AtCoder Wallpaper](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---atcoder-wallpaper-%2F-%E5%BA%A7%E6%A8%99%E5%B9%B3%E9%9D%A2%E3%80%81%E9%9D%A2%E7%A9%8D%E3%80%81%E5%8C%85%E9%99%A4%E5%8E%9F%E7%90%86)、[366 D - Cuboid Sum Query](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---cuboid-sum-query-%2F-%E4%B8%89%E6%AC%A1%E5%85%83%E7%B4%AF%E7%A9%8D%E5%92%8C%E3%80%81%E5%8C%85%E9%99%A4%E5%8E%9F%E7%90%86)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/d/main.go
:::

# 330

## [A - Counting Passes](https://atcoder.jp/contests/abc330/tasks/abc330_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/a/main.go
:::

## [B - Minimize Abs 1](https://atcoder.jp/contests/abc330/tasks/abc330_b)

- **場合分けして考える。**
  - $L <= A_i <= R$
    - `[L, R]`の範囲で、$A_i$ との距離（差分の絶対値）を一番小さくできるの $X_i$ は、$A_i$
  - $A_i < L <= R$
    - ~$X_i$ は、$L$
  - $L <= A_i < R$
    - ~$X_i$ は、$R$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/b/main.go
:::

## [C - Minimize Abs 2](https://atcoder.jp/contests/abc330/tasks/abc330_c) / 整数問題、全列挙、二分探索

- **あり得る x, y の上限が制約より導けそう。**

- D の上限を**式変形**すると、$2 * 10^{12} = (\sqrt 2 * 10^6)^2$。`0 ~ 2*10^6`までの数の二乗は、十分**全列挙**できる（200 万）。

- 平方数のスライスでループする。現在のインデックス以降の平方数から「現在の平方数 + その平方数が、D を超える平方数」を**二分探索する。** minAns の更新を試み、index が 1 以上ならその一つ前の平方数を使った値でも minAns の更新を試みる。
  - $O(200万 * \log 200万)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/c/main.go
:::

## [D - Counting Ls](https://atcoder.jp/contests/abc330/tasks/abc330_d)

- **ある`o`のマスを固定したとき**、同じ列の`o`を一つ、同じ行の`o`を一つ選ぶということ。あらかじめ行と列の`o`の数を記録しておけば、そのような組み合わせがいくつあるかが分かる。あとはマス目でループして足し上げるだけ。

  - 上記の操作をイメージすると、同じ組み合わせを別のマスを起点にしたカウントで重複カウントすることはない。

- **累積和**を使って解くことも可能。しかし上記のやり方の方がずっと簡単なので、立ち止まりたい。
  - 自身より前/下の`o`を一つづつ取る組み合わせを考える。そのために行と列の`o`の数の累積和をあらかじめ作成。
  - L 字の向きが 4 種類なので、4 隅それぞれを起点にマス目のイテレートをする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/d/main.go
:::

# 329

## [A - Spread](https://atcoder.jp/contests/abc329/tasks/abc329_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc329/a/main.go
:::

## [B - Next](https://atcoder.jp/contests/abc329/tasks/abc329_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc329/b/main.go
:::

## [C - Count xxx](https://atcoder.jp/contests/abc329/tasks/abc329_c) / ランレングス圧縮

- **ランレングス圧縮**して、圧縮後のスライスでループ。例えば`3_a`だったら、マップに`1_a`,`2_a`, `3_a`を記録。ループ全体で$O(N)$。最後にマップの長さを数えれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc329/c/main.go
:::

## [D - Election Quick Report](https://atcoder.jp/contests/abc329/tasks/abc329_d)

- クエリが 20 万個なので、各クエリで当選者を高速に求める必要がある。マップに各候補者の各得票数を記録し、最多得票数とその者を別で記録。各クエリでマップを更新するときに、最多得票数、その者と比較すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc329/d/main.go
:::

# 328

## [A - Not Too Hard](https://atcoder.jp/contests/abc328/tasks/abc328_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc328/a/main.go
:::

## [B - 11/11](https://atcoder.jp/contests/abc328/tasks/abc328_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc328/b/main.go
:::

## [C - Consecutive](https://atcoder.jp/contests/abc328/tasks/abc328_c) / 累積和

- クエリが 30 万個なので、クエリごとに**ランレングス圧縮**（$O(N)$）をしていては間に合わない。

- 隣り合う数の個数の**累積和**を作成しておけば、区間[l, r]のそのような数の個数が高速に求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc328/c/main.go
:::

## [D - Take ABC](https://atcoder.jp/contests/abc328/tasks/abc328_d) / Deque or Stack

- 文字列 S を順に**Deque**に突っ込んでおき、最後に入っている三文字が ABC であれば取り除けばいい。（**Stack**でもいい）。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc328/d/main.go
:::

# 327

## [A - ab](https://atcoder.jp/contests/abc327/tasks/abc327_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc327/a/main.go
:::

## [B - A^A](https://atcoder.jp/contests/abc327/tasks/abc327_b)

- 適当に試すと`16^16`が B の上限を超えるので、A の候補を 16 まで**全探索**すればいい。
- あるいは適当な上限 INT_MAX や B を設定し、A^A が B を超えたら break でも可。
- **繰り返し二乗法**を使うと効率いい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc327/b/main.go
:::

## [C - Number Place](https://atcoder.jp/contests/abc327/tasks/abc327_c)

- 愚直（グリッドが極小）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc327/c/main.go
:::

## [D - Good Tuple Problem](https://atcoder.jp/contests/abc327/tasks/abc327_d) / 頂点彩色問題、DFS

- 「Xs について、インデックス i とインデックス j は異なる」という情報が複数渡されて、それらが矛盾しないかどうかという様に問題を言い換えられる。これは、グラフの**頂点彩色問題**である。（N 色を使い、辺で直接繋がったノード同士を違う色で塗り分けられるか。）

- Xs のインデックス番号をノードとし、違うことが確定しているインデックス同士を辺で結ぶ。そのようなグラフを隣接リストで作成する。

- Xs を全要素-1 で初期化し、インデックス番号でループ。`Xs[i]`が-1 なら **DFS** を開始し、未確定のノードに色をつけるか、つけてある色が矛盾しないかをチェックする。**詳細は実装参照。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc327/d/main.go
:::

# 326

## [A - 2UP3DOWN](https://atcoder.jp/contests/abc326/tasks/abc326_a)

- 愚直に条件分岐

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc326/a/main.go
:::

## [B - 326-like Numbers](https://atcoder.jp/contests/abc326/tasks/abc326_b)

- 愚直に全探索

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc326/b/main.go
:::

## [C - Peak](https://atcoder.jp/contests/abc326/tasks/abc326_c) / 累積和、二分探索

- **入力値がソートされている保証がないので、ソートすること（As）**

- ある x 座標までのプレンゼント総数の**累積和**を作成できることがわかる。 `var psum []struct{x, count int}`

- As でループし、L を`As[i]`で**固定**、psum を x 座標 R 以上で psum を**二分探索**し、「その一つ前にある x 座標の累積和(=`psum[idx].count`)」-「L より一つ前の x 座標の累積和 (=`psum[i].count`)」で minAns の更新を試みる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc326/c/main.go
:::

## [D - ABC Puzzle](https://atcoder.jp/contests/abc326/tasks/abc326_d) / 全探索、DFS

- グリッドが最大 5\*5 なので全探索できそう。

  - 各行について をどのインデックスに置くかで $5*4*3 = 60$。それが５行なので $60^5$。まだ効率化が必要。
    - `A,B,C,.,.`の順列と考えてしまうと二つのドットが区別されてしまうので、間違い。
  - 各行について、１~5 行目はそれぞれどのインデックスに A を置くかを考えると、$5!$通り。A, B, C それぞれについて考え、文字種ごとにインデックスが重複するパターンを一旦許容しても、$120^{3}$となり間に合う。

- 上記のパターンを**全探索**する。ループのみで書こうと思うとループのネストが N によって動的に変化してしまう。**一定程度複雑な全探索は再帰（DFS）で書く。** `dfs(char string, grid [][]string) bool`

- `NextPermutation()`で「１~5 行目はそれぞれどのインデックスに char を置くか」を列挙し、その通りにグリッドを埋め、文字種をインクリメントして次の再帰へ。char が D ならグリッドが R,C の条件を満たすか判定して bool を返す。

- `NextPermutation()`は以下の様に書くと、オリジナルの順列への処理をループ外に別で書かなくて良くなる。

```go
next := true
for next {
  someFunc(sl)
  next = NextPermutation(sl)
}
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc326/d/main.go
:::

# 325

## [A - Takahashi san](https://atcoder.jp/contests/abc325/tasks/abc325_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/a/main.go
:::

## [B - World Meeting](https://atcoder.jp/contests/abc325/tasks/abc325_b)

- mtg の時間としてあり得るのは標準時刻で 0~1 時、1~2 時、...23~24 時の 24 パターンと少ないので、**全探索**できる。

- mtg の開始・終了時刻を支社の現地時間に直し、それらが両方 9~18 時におさまっている場合、社員数を参加可能人数に足す。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/b/main.go
:::

## [C - Sensors](https://atcoder.jp/contests/abc325/tasks/abc325_c)　/ Union Find、DFS or BFS

- グリッド上で隣接するセンサー同士を**一つのグループにまとめる**というので、**Union Find**が使える。

- Union Find の対象となるのはセンサーのマスなので、一旦それらの座標をスライスに入れる。

- Union Find の内部配列のインデックス = センサースライスのインデックスということにし、マップ（`map[coordinate{i, j}]index`）を作成する。

- あとは各センサーマスを始点に **BFS** や **DFS** をしていき、Union Find を更新すればいい。ただし、それ以前の BFS、DFS で自身以外がルートになっているマス目はスキップ可能。（すでに他の始点からの探索で探索済みの**連結成分**に入っている。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/c/main.go
:::

## [D - Printing Machine](https://atcoder.jp/contests/abc325/tasks/abc325_d) / 区間問題、優先度付きキュー（ヒープ）

### 設計

- 数直線上に各製品の開始時間、終了時間を記録する。
- プリント可能な製品は、現在以前に開始しているもの。
- それらの **どれにプリントすべきかは、最も終了時間が近い製品である**。（すぐプリントできる対象から外れてしまうため。）
- 終了時間を**優先度付きキュー**に入れて、最も喫緊の製品のそれを取り出す方法が良さそう。
- 時刻を 1 づつインクリメントしていると TLE になる && 全く製品が存在しない区間が存在しうる　ので、キューが空になった後に次に見るべき製品が存在する時刻まで飛びたい。**何らかの形でどの製品まで見たかを保持する必要がありそう。**

### 実装

- 製品の開始時間と終了時間の構造体スライスを、ソートしておく。
- 大外の**ループの終了条件は、キューが空になりかつ全ての製品の処理が終わっていること**。
- 現在時刻から開始する製品の終了時間を全てキューに入れる。どの製品の終了時間まで入れたかのインデックスを保持しておく。
- キューから期限切れの終了時間を全て取り出す。
- キューが空でないなら、喫緊の終了時間を取り出し、ans をインクリメントする。
- キューが空でないなら、現在時刻を 1 インクリメントして次のループへ。キューが空なら、次に終了時間をキューに入れる製品の開始時間まで現在時刻を飛ばして、次のループへ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/d/main.go
:::

# 324

## [A - Same](https://atcoder.jp/contests/abc324/tasks/abc324_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/a/main.go
:::

## [B - 3-smooth Numbers](https://atcoder.jp/contests/abc324/tasks/abc324_b) / 整数問題、全探索、素因数分解

- **素因数分解は $O(\sqrt N)$かかるため、N の制約より間に合わない。**

- 計算すると $\log_2 10^{18} = 59.7$ 、$\log_3 10^{18} = 37.7$ となるため、2 の乗数を 60 まで、3 の乗数を 38 まで**全探索**すればいい。

- **オーバフローしないように**、$2^i * 3^j > N$ となったときに内側の loop を break する。

- 繰り返し二乗法は $O(log_2 N)$なので、$O(60*38* (\log_2 60 + \log_2 38))$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/b/main.go
:::

## [C - Error Correction](https://atcoder.jp/contests/abc324/tasks/abc324_c)

- 文字列が等しいか、いずれかから一文字足す（一文字消す）と同じになるか、一文字のみ違うかを判定する頻出問題。ライブラリを用意する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/c/main.go
:::

## [D - Square Permutation](https://atcoder.jp/contests/abc324/tasks/abc324_d) / 整数問題（いい数の個数）、平方数、組み合わせ

- **`NextPemutation()`で全順列を試すと$13!$かかり間に合わない。** **逆側の**、あり得る平方数を試すことを考える。

- $(10^6)^2 = 10^{12} （13桁）$であるため、10^6 程度までの数が平方根としてあり得るので、平方数の列挙は間に合う。

  - 実際は、S を最も大きくなる様にソートした数の平方根の平方数までを列挙すればいい。

- ある平方数が S から作成可能かを高速に判定する必要がある。**各桁の数のスライスを降順（または昇順）にソートして一致すれば、作成できるということ。**
  - ただし今回は`010`で`10`を表現することも可能なので、平方数の桁数が S の桁数に満たない場合は、同じになるように`0`をアペンドする。
  - $O(10^6 * 13 * 13 \log 13)$ （ソートが$N * log N$。N は最大の桁数 13。）

---

- **M4 Mac の CPU の処理速度はジャッジサーバーの二倍程度だということに注意。**
- **制限時間 4 sec のギリギリをせめる問題は、ローカルで余裕でも注意する。** また、そういう問題はサンプルで上限付近の入力を示してくれていることも多い。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/d/main.go
:::

# 323

## [A - Weak Beats](https://atcoder.jp/contests/abc323/tasks/abc323_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/a/main.go
:::

## [B - Round-Robin Tournament](https://atcoder.jp/contests/abc323/tasks/abc323_b)

- グリッドで勝利数を読み込む。`{勝利数、インデックス}`という**構造体のスライスを作成し、二つの値を使ってソートする。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/b/main.go
:::

## [C - World Tour Finals](https://atcoder.jp/contests/abc323/tasks/abc323_c) / Ordered Multi Set、貪欲法

- 各人の点数、解いていない問題の点数セットを記録しておく。各人でループし、自身を除いた点数の最多を超えるためには、解いていない問題を何問解く必要があるかを求める。（得点の高い順に**貪欲**に解く。）

- 各人の得点の集合、各人の解いていない問題の点数の集合について、**挿入、削除、最多の取得を高速に行う必要**があるので、**Ordered Multi Set**が適していることが分かる。

---

- gostl の`MultiSet`は、`Erase(val)`で val と同じ値全てが消えてしまうため、独自のライブラリを使う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/c/main.go
:::

## [D - Merge Slimes](https://atcoder.jp/contests/abc323/tasks/abc323_d) / 優先度付きキュー（ヒープ）

- スライムは可能な限り同じサイズ同士で合成するのが最善。最終的に同じサイズのスライムが二個以上存在するのはあり得ないため。また、最終的に X 種類のスライムが１体ずつ存在する状態になる。

- サイズの小さなスライムから合成していき、二倍のサイズのスライムがすでにいればその個数に加算、なければ新規に記録。これを繰り返したい。

  - **小さな値から処理する**ということで、サイズの**優先度付きキュー（ヒープ）** が使える。
  - **Ordered Set**も思い浮かぶが、**こちらは取得と削除の両方で`O(log N)`かかるので不利。** 一度処理したサイズはもう処理しなくていいので。

- 実装
  - サイズをヒープに追加し、サイズごとの個数をマップで管理する。
  - ヒープが空になるまでサイズを取り出し、個数を 2 で割った数を二倍のサイズのマップのバリューに加算。
  - 2 で割った余りが 1 ならそのサイズのスライムは最後まで残るので、`ans++`
  - マップにキーが存在していなかった場合のみ二倍のサイズをヒープに追加。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/d/main.go
:::

# 322

## [A - First ABC 2](https://atcoder.jp/contests/abc322/tasks/abc322_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc322/a/main.go
:::

## [B - Prefix and Suffix](https://atcoder.jp/contests/abc322/tasks/abc322_b)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc322/b/main.go
:::

## [C - Festival](https://atcoder.jp/contests/abc322/tasks/abc322_c) / 二分探索

- 現在の日付以降の直近の花火の日付を**二分探索**。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc322/c/main.go
:::

## [D - Polyomino](https://atcoder.jp/contests/abc322/tasks/abc322_d) / ポリオミノ、DFS（全探索）

- 「ポリオミノをどの順番で配置するか」x「ポリオミノを何回 90 度回転させるか」のパターンを**全探索**する。

  - $O(3! * 4^3)$
  - **複雑な全探索なので、再帰、DFS で書く。**

- **各ポリオミノの座標を、0~3 回 90 度回転させたものを予め用意しておく。**

  - `var partsMap [3][4][]Coodinate // partsNo => rotateNum => cordinates sorted by most left up`
  - **座標は、最も左上に近い順でソートしておく。**
  - **座標は`[2]int`ではなく`Coodinate`型にする。多重配列の可読性をマシにするため。**

- 実装
  - **パーツの順番を`NextPermutation()`でループ、再帰関数の中で回転を列挙して再帰。**
  - 関数の引数に現在の最も左上の空きマスを渡す。空きマスからポリオミノを配置しようとする。
  - 元々のパーツの座標は、最も左上の空きマスとのデルタを加算して使う。
  - 更に再帰する直前に、最も左上の空きマスを更新する。**空きマス発見後に loop break を忘れない。**
  - 再帰関数の戻り値は、パズルが全て解けたかどうかの bool。**再帰呼び出しの際は、戻り値が true だったら true を返し、false なら別の再帰をするために次のループにイテレート。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc322/d/main.go
:::

# 321

## [A - 321-like Checker](https://atcoder.jp/contests/abc321/tasks/abc321_a)

- string で読み込んで桁に分割して比較。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/a/main.go
:::

## [B - Cutoff](https://atcoder.jp/contests/abc321/tasks/abc321_b)

- ソートして最大と最小を記録、それ以外の合計を記録。足りない点が最小以下か、最大以上かで分岐。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/b/main.go
:::

## [C - 321-like Searcher](https://atcoder.jp/contests/abc321/tasks/abc321_c) / 整数問題（K 番目のいい数）、DFS（全列挙）

- **質問タブの「321-like Number は有限個であることが示せます。」に注目。**

- よく考えると、最大のいい数は`9876543210`であることが自明。いい数の総数も少なそう。何か**全列挙**する方法はないか？

- 自身より少ない数が存在すれば、それを後ろにくっつけるということを**DFS**で再帰的に繰り返せば全列挙できる。

- **0 は正の整数ではないことに注意。（正負どちらでも無い。）**

- やってみると分かるが**桁 DP**+**二分探索**で解くのは相当困難。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/c/main.go
:::

## [D - Set Menu](https://atcoder.jp/contests/abc321/tasks/abc321_d)　/ 二分探索 + 累積和

- As と Bs をソートすれば、`As[i]`に対して`As[i] + Bs[j] >= P`となる B の数を数えられる。

- 更にソート済み Bs に対して**累積和**を作っておけば、P を超えない組み合わせで使う B の総和が高速に求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/d/main.go
:::

# 320

## [A - Leyland Number](https://atcoder.jp/contests/abc320/tasks/abc320_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/a/main.go
:::

## [B - Longest Palindrome](https://atcoder.jp/contests/abc320/tasks/abc320_b) / 回文

- `len(S)`文字の部分列チェック、`len(S)-1`文字の部分列チェック、...とすればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/b/main.go
:::

## [C - Slot Strategy 2 (Easy)](https://atcoder.jp/contests/abc320/tasks/abc320_c) / 全探索

- **最悪のケースは、** S1,S2,S3 の最後の一文字を使わないと揃わないケース。その場合、M-1 秒、2M-1 秒、3M-1 秒にボタンを押す必要がある。よって、0~3M-1 秒の間のいずれかの 3 点でボタンを押すパターンを**全探索**すればいい。
  - ボタンを押すパターン：$300^3$
  - `i < j < k`となるように三重ループして、どのインデックスがどのリールに対応するかの 6 通りを試してもいい。（この 6 通りの検証は簡単なので、計算量には影響出ない。）
  - あるいは、`i, j, k`いずれも 0~3M-1 秒の範囲でイテレートし、一つでも被っていたら continue する。各インデックスはリール 1、2、3 に固定で対応させる。という方法でもいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/c/main.go
:::

## [D - Relative Position](https://atcoder.jp/contests/abc320/tasks/abc320_d) / キュー

- 人 1 の座標から、関連する人達の座標を求める。さらに座標が判明した人達の情報から、関連する人達の座標を求める。ということを繰り返したい。**キューに座標の判明している人の番号を突っ込んでいけばできそう。**

- 座標の関係性を**隣接リスト**に格納しておく。**その際に、`A => B, +X, +Y`という情報があったら、逆の`B => A, -X, -Y`という情報も記録する。**

- キューから座標の判明している人の番号を取り出し、隣接リストから関連する人の情報を取り出す。それらの人の座標がすでにわかっているなら continue。そうでないならその人の座標を確定し、その人の番号をキューに積む。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/d/main.go
:::

# 319

## [A - Legendary Players](https://atcoder.jp/contests/abc319/tasks/abc319_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/a/main.go
:::

## [B - Measure](https://atcoder.jp/contests/abc319/tasks/abc319_b)

- 愚直に各インデックスに対して 1~9 が約数かを判定する。全探索。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/b/main.go
:::

## [C - False Hope](https://atcoder.jp/contests/abc319/tasks/abc319_c) / ビンゴ、全探索

- マス目が判明する順番は $9! = 362880$ 通りなので**全探索**可能。
- マス目に 1~9 の番号をつけ、番号とグリッドの座標のマップを作成する。
- 判明順を`NextPermutation()`で全探索する。判明していく座標を行スライス、列スライス、クロススライスで管理し、”がっかり”したらそれをカウントする。最後までしなかったらそれをカウントする。最後に割合から確率を出す。
- **グリッドのマス目の座標がクロスの位置にあるかどうかの判定方法は、以下の類題を参照。**

- 類題：[355 C - Bingo 2](https://zenn.dev/shinonome81/articles/b1de75b0849b32#c---bingo-2-%2F-%E3%83%93%E3%83%B3%E3%82%B4)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/c/main.go
:::

## [D - Minimum Width](https://atcoder.jp/contests/abc319/tasks/abc319_d) / 二分探索（応用）、貪欲法

- ウィンドウ幅が大きくなるほど、必要な行数が減る（**単調性**）。M 行に収まるようなウィンドウ幅を**二分探索**できる。

  - min は、最も長い単語のサイズ。max は、単語のサイズの総和+`(N-1)*1`のスペース。
  - **$\log (max-min)$ が二分探索の計算コスト**

- ウィンドウ幅に対する必要行数はどのように判定できる？前から**貪欲に**単語サイズ+スペースを足していき、ウィンドウ幅を超えたら改行する。$O(N)$

- $O(log (10^9*N) * N) = O(47 * 2*10^5)$ なので現実的。

- **`AscIntSearch()`と`DescIntSearch()`はどちらを使うかよく考える。（答えが見つからない場合を除き）戻り値がそのまま求める値にならないケースは、何かがおかしい。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/d/main.go
:::

# 318

## [A - Full Moon](https://atcoder.jp/contests/abc318/tasks/abc318_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/a/main.go
:::

## [B - Overlapping sheets](https://atcoder.jp/contests/abc318/tasks/abc318_b) / 座標平面（面積）

- 一つづつ面積を出し加算し、他との重なりを判定してその部分をどうこうする方法は難しすぎる。

- 範囲が`(0~100, 0~100)`に限定されていることから`100*100` のグリッドだと考え、長方形の範囲を塗りつぶし、最後に塗りつぶしをカウントする方法でやる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/b/main.go
:::

## [C - Blue Spring](https://atcoder.jp/contests/abc318/tasks/abc318_c) / 貪欲法、累積和

- 運賃 Fs をソートし後ろから D 日づつ見ていき、その和が P 円より高ければ周遊パスを**貪欲に**セット購入していく。ある区間の和を高速に求めたいので、**累積和**を作成しておく。

- D 日未満しか残っていなくても周遊パスをセット購入した方が得な場合があるので、その条件分岐が必要なことに注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/c/main.go
:::

## [D - General Weighted Max Matching](https://atcoder.jp/contests/abc318/tasks/abc318_d) / グループ分け、DFS

- **無向辺グラフの辺の重みを記録するときは、`from => to, to => from`の両方にとりあえず必ず入れる。**

- **偶数である N 個の要素を 2 個づつの区別のない N/2 グループに分割するパターン数は、N-1 の二重階乗通りである。**

  - $(N-1)!! = (N-1) * (N-3) * (N-5) * ... * 1$
  - 先頭の要素について、ペアリング先が残りの N-1 通り。残った N-2 個の要素についても、先頭の要素について、ペアリング先が N-3 通り。...。となるため。
  - **先頭から後ろの要素をペアリング先に選ぶことで、重複数え上げ（グループの区別）を排除できている。**

- **奇数である N 個の要素を 2 個づつの区別のない N/2 グループに分割するパターン数は、N の二重階乗通りである。**

  - $N!! = N * (N-2)!!$
  - `どの要素を使わないのか * N-1個の偶数個をグループ分けする場合の数`になるため。

- 上記より $O(15!!) = O(2,027,025)$ であるため**全探索**が可能。複雑な全探索なので**DFS**で書く。

- 先頭から後ろの要素をペアリングさせる。使用済み要素をマップで管理し、ペアリング元、先が使用済みなら continue する。**詳細は実装参照。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/d/main.go
:::

# 317

## [A - Potions](https://atcoder.jp/contests/abc317/tasks/abc317_a)

- 二分探索

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/a/main.go
:::

## [B - MissingNo.](https://atcoder.jp/contests/abc317/tasks/abc317_b)

- ソートしてループ

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/b/main.go
:::

## [C - Remembering the Days](https://atcoder.jp/contests/abc317/tasks/abc317_c) / DFS（グラフ）

- 今回の計算量：$O(N! * N) = O(完全グラフの全経路数 * 探索一回ごとの訪問済みノードの判定)$

- 今回の全経路数は $10! = 3628800$。この回数訪問済みノードの読み取り、更新を行うわけだが、マップだと処理全体が 1000ms、スライスだと 200ms だった。**マップの読み取り、更新は $O(1)$ だが、スライスと比べて処理の定数時間が 4, 5 倍程度遅い。**

### DFS memo

- $N(N-1)/2 = \binom{N}{2}$ であり、グラフが完全グラフである場合の辺数。

- 「DFS の計算量は $O(V + E)$ （V: vertexes, E: edges）」と言われるが、これは**始点を固定した**、**バックトラックなしの**、DFS の計算量である。
  - バックトラックとは跡を引き返すということで、再帰呼び出しの直後に訪問済みノードを解除し、別の経路で訪問できるようにすることである。
  - バックトラックなしの DFS は連結成分内の全てのノードに訪問することを目的とし、このような解除は行わない。
  - バックトラックありの DFS の計算量は問題設定による。今回のような全経路を探索する場合は $N!$ となる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/c/main.go
:::

## [D - President](https://atcoder.jp/contests/abc317/tasks/abc317_d) / ナップサック問題、DP（テーブル）

- 限られたコストで価値を最大化したり、ある価値に到達するための最小コストを求める問題を **ナップサック問題**といい、**DP（テーブル）** で解く。

- 各選挙区について、P 人鞍替えさせると（コスト）、Q 票獲得出来る（価値）。過半数票を獲得するための最小コストは？

  - 負けている選挙区は、`(X-Y+1)/2`のコストで勝てる。
  - 勝っている選挙区は、コストゼロでその票数を取れると考えると楽。（選挙区リストから取り除き、勝敗ラインを過半数から調整する必要がなくなる。）

- DP テーブル `var dp [][]int` の設計

  - 行: 何個目の選挙区まで処理したか。**大抵の DP で同様。**
  - 列: 各得票数。
  - セル: その状況における最小コスト。
  - **セルに求めたい答えと同様の値を入れる。求めたい答えの状況を列で表現する。**
    - 今回は最小コスト、特に過半数以上の票を獲得している状況のそれを求めたい。
  - ゼロ個目の選挙区まで処理した場合、ゼロ票の場合も格納したいので、行・列の長さは 1 を足しておく。
  - 各セルは初期値で埋めておく。**今回は最小を求めたい（=min をとる処理があるはず）ので、十分に大きな数 INF で埋める。** （最大を求める問題なら逆。）
    - **INT_MAX や INT_MIN だとオーバーフローの危険がある。**
  - $O(N * (10^5/2+1))$ （セルの数）

- テーブルを埋めるループは一つ前の行（選挙区）の全列（票数）から、次の行の遷移先（あり得る票数）の列に値を埋めていく。

  - 遷移先はすでに別の遷移で埋まっている可能性があるので、そのセルの値と今埋めようとしている値の min を採用する。
  - 値の入っていない（INF である）セルも処理してしまうが、**min をとっている関係で上手くいく。** そこからどこへ遷移しようと、遷移先は元から入っている有効な値か、INF のままになる。

- 過半数以上取る様な遷移をしようとして、DP テーブルの範囲外アクセスになってしまう可能性がある。**過半数票の列 (最後列)だけそれ以上以上の票を獲得している状態と定義しても問題の設定上問題ない。DP でよくあるテクニック。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/d/main.go
:::

# 315

## [A - tcdr](https://atcoder.jp/contests/abc315/tasks/abc315_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/a/main.go
:::

## [B - The Middle Day](https://atcoder.jp/contests/abc315/tasks/abc315_b)

- 目標の日数から各月の日数を順に引いていく。マイナスになったら「その月」の「終わりからマイナス分を引いた日付」が答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/b/main.go
:::

## [C - Flavors](https://atcoder.jp/contests/abc315/tasks/abc315_c)

- 異なる味同士の美味しさの和の最大は、各味の中の最大の美味しさを昇順に並べた後ろ二つの和。
- 同じ味同士の美味しさの和の最大は、各味の中の美味しさを昇順に並べた後ろ二つの和。
- 上記を求めて maxAns を更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/c/main.go
:::

## [D - Magical Cookies](https://atcoder.jp/contests/abc315/tasks/abc315_d) / グリッド（応用）

- 行、列ごとに`map[color][]col(row)_indexes`を作成し、削除できる行、列があった場合は、インデックスをもとに逆側のマップから削除する、というやり方が思いつく。これだと各マスの h, w 座標がそれぞれ一箇所に入りそれらが最大一回ずつ削除されるので $O(2*2000^2)$ になる。**しかし 400 万回以上ものマップの操作は 2 sec では TLE になるので、マップを使わないやり方を考える。**

- **色の種類がアルファベットの種類 26 個しかないことに着目する。** 行、列ごとの色の数を `make([]int, 0, 26)` のスライスで保持することを考える。行、列の削除できるかどうかの判定は $O(26)$ で可能。

- 行の削除の影響を列の色分布に反映する方法を考える。ある回である行が削除されたら、`i:=0~W-1`の列インデックスでループを回す。`color := grid[rowIdx][i]`でその列から削除された色がわかるので、その色を列の色分布からマイナスすればいい。

  - $O(26(H + W) * (H + W))$ // (最初の行、列が削除できるかのチェック) \* (削除された行、列に対する列、行の処理)

- 最後にマス目でループし、その行も列も削除されていないものを数えれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/d/main.go
:::

# 314

## [A - 3.14](https://atcoder.jp/contests/abc314/tasks/abc314_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/a/main.go
:::

## [B - Roulette](https://atcoder.jp/contests/abc314/tasks/abc314_b)

- 制約より**全探索**できそう。各人のベット先を Map（as Set）で保持。X にベットしていた人を、ベット種類数と一緒にスライスに突っ込んでいく。最後に種類数と人の番号でソートして、minCount を超えるまで出力すれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/b/main.go
:::

## [C - Rotate Colored Subsequence](https://atcoder.jp/contests/abc314/tasks/abc314_c)

- M（クエリ回数）が最大 20 万なので、スワップ操作を高速にやる方法を考える。色ごとのインデックスのスライスを作りソートする。色ごとに一旦`var toUpdate []struct{idx int, char string}`を作って、それを元に更新する。（末尾のインデックスの文字が先頭のインデックスに移ることにだけ注意。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/c/main.go
:::

## [D - LOWER](https://atcoder.jp/contests/abc314/tasks/abc314_d)

- 最終的には、文字は最後の変換が大文字なら大文字、小文字なら小文字になる。ただし最後の変換の後に変更された文字は別。よって最後の変換がどちらか、それ以降に変更されたインデックスはどこかをスライスで保持する。

- あとは文字の変更操作だけを順にやり、その後除外インデックス以外を順に大文字変換または小文字変換すればいいだけ。

- **`if`ブロックとは違い、ループ内の`switch`ブロック内で break してもその switch を抜けるだけであることに注意。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/d/main.go
:::

# 313

## [A - To Be Saikyo](https://atcoder.jp/contests/abc313/tasks/abc313_a)

- 愚直。As が一人だけなら、その人は最強であることに注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/a/main.go
:::

## [B - Who is Saikyo?](https://atcoder.jp/contests/abc313/tasks/abc313_b) / DFS、有向グラフ

- 強い人から弱い人に辺が伸びる**有向グラフ**として表現可能。

- あとは各人から始まる`DFS`を行い、何人の弱い人を訪問できたかをカウントすればいい。関数は node を受け取り、そこから訪問できた node 数を返す。

- 一度の DFS で同じ人に二度訪問しないために、`visited`を管理する。経路はどうでもよく**連結成分**を全て訪問できればいいため、呼び出しもとに帰る前に自身の訪問済みを解除するバックトラックはやらない。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/b/main.go
:::

## [C - Approximate Equalization 2](https://atcoder.jp/contests/abc313/tasks/abc313_c)

- 「数列の最大値と最小値の差が１以下」の場合、数列の要素は 1 種類か 2 種類しかないことになる。`sum%N == 0`なら`sum/N`、そうでないなら`sum/N, sum/N+1`になる。（**問題の言い換え**）

- 後者の場合、`sum/N`は`N-(sum%N)`個、sum/N+1 は`sum%N`個あることになる。（前者でも結局は同じ式になる。）

- As をソートして、`sum/N`の個数に達していなければ、`sum/N`との diff、達していれば`sum/N+1`との diff をとる。

  - 小さい数字を小さい値に変更させる方が効率がいいことは自明。
  - diff は正負どちらにでもなり得ることに注意。
  - diff の正負に応じて positiveCost, negativeCost に加算し、最後にそれらが一致していることを一応アサートし、一方の値を出力すれば答え。

- 「As をソートして Deque に突っ込み最小と最大を取って平均にならすことを繰り返す」等が思いつきサンプルも通るが、**やり方に正当性が無いのでこういう当てずっぽうをしない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/c/main.go
:::

## [D - Odd or Even](https://atcoder.jp/contests/abc313/tasks/abc313_d) / インタラクティブ問題、合同式、XOR（排他的論理和）

- **数字の和が偶数なら 0、奇数なら 1 ということは、数字の和を mod 2 しているということになる。**

- 0, 1 しか数字が存在しないので、**XOR** を取っていけば同じことができる。

```go
a := 0
b := 1

// 0 + 1 ≡ 1 mod 2
ans1 := (a+b)%2 // 1
ans2 := a^b     // 1
```

- **部分問題から考える。** N=4, K=3 の時。
  - K+1 までの数字について、1 つを抜かした K 個のクエリを投げるとする。
  - K 個のクエリの答えの和の mod 2 を取ることで、1~K+1 の数字の和の mod 2 が分かる。
  - 上記をもとに 1~K+1 文字目の 0, 1 が判明する。（**連立方程式**の様に考えられる。）
  - N がもっと多かったとしても同じ要領で、「確定している K-1 個の数字の番号」＋「判明していない数字の番号」でクエリを投げていき、残りの番号の数字も求めていけばいい。

```
  a b c d
  1 0 0 1
  -------
  o o o x ≡ 1 mod 2 // ①
  o o x o ≡ 0 mod 2 // ②
  o x o o ≡ 0 mod 2 // ③
+ x o o o ≡ 1 mod 2 // ④
--------------------
3a + 3b + 3c + 3d ≡ 0 mod 2
    a + b + c + d ≡ 0 mod 2 // ⑤

⑤に例えば④を足すと、以下が求められaの値がわかる。
 a + 2b + 2c + 2d ≡ 1 mod 2
                a ≡ 1 mod 2
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/d/main.go
:::

# 312

## [A - Chord](https://atcoder.jp/contests/abc312/tasks/abc312_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/a/main.go
:::

## [B - TaK Code](https://atcoder.jp/contests/abc312/tasks/abc312_b)

- グリッドサイズが小さいので左上を固定した全探索。$O(100^2 * 9^9)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/b/main.go
:::

## [C - Invisible Hand](https://atcoder.jp/contests/abc312/tasks/abc312_c) / 二分探索

- 昇順ソートした売り手の価格を順に見て、価格をもとに昇順ソートの買い手の希望価格で何人買うか見つける。売り手の人数 >= 買い手の人数なら現在の価格が答え。としたくなるが、これでは以下のケースに対応できていない。

```
2 3
10 10
11 11 22
=> expexted: 12. 売り手：2人、買い手：1人になる。
```

- **単純な二分探索（`AscIntSearch()`, `DescIntSearch()`）ができないかをまず考える。**

- 最小の価格を求めたい。価格を**増やして行った時に単調に変化するものは何かあるか？**

  - => 価格が上がるほど売り手の人数が増え、買い手の人数が減る。**二分探索**可能。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/c/main.go
:::

## [D - Count Bracket Sequences](https://atcoder.jp/contests/abc312/tasks/abc312_d) / DP（メモ化再帰）

- 考慮するパターンを相当減らす必要があるので**DP**が濃厚。

- ”括弧列”を**言い換える**と「文字列内の括弧は全て閉じていなければならない」ということ。つまり、`(`が一つ出現すると後で`)`をいつか必ず付けなければならない。

- 上記をもとに、「何文字目まで処理済みか」「あと何個`)`を付けなくてはならないか」という状態と、その時のパターン数を考える**メモ化再帰**で解ける。

- 「あと何個`)`を付けなくてはならないか」が残りの文字数を超えてしまう場合は場合は**枝刈り**する。

- 必要以上に（前に十分な数の`(`が無いのに）`)`を付けてしまうケースもハンドリングする。

- 類題：[359 D - Avoid K Palindrome](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---avoid-k-palindrome-%2F-dp%EF%BC%88%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%EF%BC%89%E3%80%81dfs%E3%80%81%E5%9B%9E%E6%96%87)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/d/main.go
:::

# 311

## [A - First ABC](https://atcoder.jp/contests/abc311/tasks/abc311_a)

- 愚直

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/a/main.go
:::

## [B - Vacation Together](https://atcoder.jp/contests/abc311/tasks/abc311_b) / 論理積

- 予定文字列をビットに変換して**論理積**（両方 true の時だけ true）を取れば良さそうに見えるが、文字列が 100 桁まであり、整数が 64 ビットまでしか扱えないことから、**オーバーフローする。**

- 文字列は文字列スライスにして、if 文で自分で論理積を撮って更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/b/main.go
:::

## [C - Find it!](https://atcoder.jp/contests/abc311/tasks/abc311_c) / Functional Graph、DFS（グラフ）

- 各ノードが一つだけ辺を持つ有向グラフのことを、**Functional Graph**という。`f(node) = next_node`の関数の様な構造をしているため。

  - Functional Graph は、一つの連結成分内に必ず一つの**閉路**を持つ。（全てのノードは必ず別のノードに行けるので、連結成分を探索すればいつか必ず同じノードを通る。）
  - 一つの閉路と、そこから木が伸びたような構造をしている。
  - `var graph []int // node => next_node`の構造に格納できる。

- 上記の法則を知っていれば、順番に適当なノードから探索を始め訪問したノードをスライスに格納し、同じノードを通ったら探索を終了すればいい。

---

- 通常の**DFS**でも解ける。ただしノードの数が 20 万と多いため、$O(N)$ でも定数倍が重いと TLE する。
  - 訪問ノードを順番に記録する際に、1 つのスライスを使い回す。**再帰呼び出しが帰ってきた時に末尾に追加したものを削除する。** **再帰呼び出しごとにスライスを複製する方法は遅すぎる。**
  - 文字列で訪問ノードの順番を記録する方法も考えたが、**文字列結合も実はかなり遅い。** 文字列は immutable なため、毎回新しいメモリを用意してコピーするため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/c/main.go
:::

## [D - ](https://atcoder.jp/contests/abc311/tasks/abc311_d)

-

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/d/main.go
:::
