---
title: "AtCoder Beginer Contest 301~350 D or E までの要点・解答（Go）"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["atcoder", "go"]
published: true
---

next: [AtCoder Beginer Contest 351~400 D or E までの要点・解答（Go）](https://zenn.dev/shinonome81/articles/b1de75b0849b32)

※ 個人的なメモ。コードは比較的読み易いと思います。
※ 愚直に解くだけの問題は省略。

# 350

## [C - Sort](https://atcoder.jp/contests/abc350/tasks/abc350_c) / Sort

- **未ソート配列について、正しいソート順がわかっていれば最大でも N-1 回のスワップ操作でソートすることができる。**

  - 一つづつ正しい位置にスワップしていけばいい。

- 各数字のインデックスを記録する。1~N の数字について、実際のインデックスと期待するインデックス（num-1）と一致するかみて、一致していなければスワップし、インデックスの記録を更新していけばいい。

- 自前でソートを実装し、スワップ操作にコールバックを挟むようなやり方は厳しい。純粋なスワップ操作をするようなソートアルゴリズムは**バブルソート**などだが、計算量が N^2 なので間に合わない。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc350/c/main.go
:::

## [D - New Friends](https://atcoder.jp/contests/abc350/tasks/abc350_d) / Union Find、連結成分

- 友達の友達も友達にする。これをできなくなるまで繰り返す。これは、グラフの連結成分について、**完全グラフ**（全ての頂点から他の全ての頂点への変が存在する）にするということ。

- **完全グラフの辺の数は $\binom{N}{2}$**

- **Union Find**を用いて、各ノードを連結する。ルートノード毎のサイズから、各**連結成分**（辺で行き来的る範囲）の完全グラフになった時の辺数の和を求めていく。最初に存在していた辺数 M を引けば、答えになる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc350/d/main.go
:::

# 349

## [B - Commencement](https://atcoder.jp/contests/abc349/tasks/abc349_b)

- マップに文字種ごとの出現回数を記録。そのマップをもとに、出現回数毎の文字種の数を別のマップに記録。

- 1~N までの数字について、後者のマップからその出現回数の文字種の数が 0 か 2 であるかを調べる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/b/main.go
:::

## [C - Airport Code](https://atcoder.jp/contests/abc349/tasks/abc349_c)

- `T = strings.ToLower(T)`で T を小文字に合わせる。
- `T = strings.TrimSuffix(T, "x")`で末尾に x があれば取り除く。（x は S に含まれていても含まれていなくてもどちらでもいい。）
- Ts をループし、中で Ss を最後に見たインデックス+1 から現在探している文字が見つかるまでループし、最後に見たインデックスを更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/c/main.go
:::

## [D - Divide Interval](https://atcoder.jp/contests/abc349/tasks/abc349_d) / 数列の分割、セグメント木

- 定義より、いい数列の `r-l`（=数列の要素数）は 2 の乗数になる。さらに、l, r ともに 2 の乗数の倍数になる。

- 2 の乗数の区間を考えるということで、**[セグメント木](https://algo-logic.info/segment-tree/)** が使えそう。

  - ある区間を 2 の乗数の長さの区間に分割することを考えるということ。
  - 大きな 2 の乗数の長さの区間から貪欲に分割していきたい。

- **セグメント木**とは、ある区間の範囲について、ルートノードには区間全体を、一つ下の階層のノードには左半分と右半分を、...というように**完全二分木**に格納したデータ構造。

- 制約よりあり得る最大の区間`[0, 2^60)`ついて、セグメント木のようなデータ構造を考える。
- 2^60 の長さの区間から順に、入力の`[L, R)`に完全に内包されているかどうかを見ていく。内包されていれば ans スライスに追加し、はみ出た左右の部分があれば同様の処理に再帰的にかけていけばいい。
  - 一度の処理で二つ以上の同じ長さの区間が完全に内包されることはない。そうであるならば、一つ上の二倍のサイズの区間が完全に内包されているはずだから。
  - `O(log N)`になる。完全に内包される区間がいつかは見つかりその際に再帰が止まるため、チェックする階層の数に比例する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc349/d/main.go
:::

# 348

## [B - Farthest Point](https://atcoder.jp/contests/abc348/tasks/abc348_b) / 全探索

- 各頂点について、他の頂点全てとの距離（の二乗）を計算し最も遠い点を求めても、制約より`O(100 * 99)`にしかならない。変な工夫を考えずに**全探索**する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/b/main.go
:::

## [C - Colorful Beans](https://atcoder.jp/contests/abc348/tasks/abc348_c) / Ordered Set

- N 行の入力を処理しながら、各色のおいしさを**Ordered Set**に突っ込んでいき、後で各色の最も低いおいしさを取り出して、その中の最大を出力すればいけそう。
- ただし色は最大で 10^9 種類存在し、色でループできないので工夫が必要。
  - 『「各色の Ordered Set の min value」の Ordered Set』を作っておく。
  - 「各色の Ordered Set」に更新があるときは、事前に`First()`を取得し『』から`Erace()`、更新後に再度`First()`を取得し『』に`Insert()`する。
  - N 回のループ後に『』の Ordered Set から`Last()`を取得すれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/c/main.go
:::

## [D - Medicines on Grid](https://atcoder.jp/contests/abc348/tasks/abc348_d) / BFS

- エネルギー量をキューアイテムに保持し、**BFS**を行う。ただし探索済みノードの記録において、よりエネルギーの多い状態でのノード再訪は試す価値があるため、bool ではなく残りエネルギー量で訪問を記録する。
- 薬は使うとなくなるが、個別の経路ごとに一度づつ使用可能なため、使っても記録からは消さない。上記の訪問済みノードの記録により、同一経路では二度同じ薬マスに来ない。
- **DFS**での探索も考えたくなるが、DFS では再帰の終了時（呼び出しもとに帰る時）に訪問済みを解除するため、よりエネルギーの少ない状態での訪問済みマスへの無駄な再訪を回避できず TLE になる。
  - エネルギーを無駄にしない効率的な（**最短の**）移動が求められることから、BFS が適していることを感じ取りたい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc348/d/main.go
:::

# 347

## [B - Substring](https://atcoder.jp/contests/abc347/tasks/abc347_b) / 全探索

- 部分文字列の長さは最大 100。部分文字列の取り方も最大 100。全探索が 100^2 に収まるので、スマートなやり方を考えずに**全探索**する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/b/main.go
:::

## [C - Ideal Holidays](https://atcoder.jp/contests/abc347/tasks/abc347_c) / 円環

- １週間という**周期**の中で、各休日がどこに位置するかを考えたいので、各休日の日付を周期の長さ A+B で割った余り（rem）に変換する。
- 同じ位置の休日のデータが重複しても仕方ないので、rem を map に突っ込んで、map のキーからスライスに変換する。そしてソート。
- 休日の位置関係で考えると難しい。**逆側**の、平日について考える。平日が B 日以上連続している区間が存在すれば、条件を満たしていると問題文を言い換えることができる。
- `rems[i] - rems[i-1] - 1`で休日の間に何日平日が存在しているかが分かる。
  - **円環**を跨ぐ`i == 0`の時は工夫が必要で、`rems[i] - 1　+ (weekdays - rems[len(rems)-1])`とする必要がある。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/c/main.go
:::

## [D - Popcount and XOR](https://atcoder.jp/contests/abc347/tasks/abc347_d) / XOR

- **XOR（排他的論理和）** は、A と B のどちらかが一方のみが true なら true、それ以外は false。go の演算子は`xor := A ^ B`

- C を二進数表現にしてみる。`X ^ Y == C`となる （|C|桁の）X、Y は、（C、0）に加え、前者から任意の桁のビットをおり、後者の同じ桁のビットを立てる操作を任意の回数繰り返すことで列挙することができる。

  ```
  C: 7 => 111

  =>
  111 | 000
  110 | 001
  101 | 010
  ...
  ```

- よって|C|桁までの X と Y の、`popcount(X)+popcount(Y)`は常に `popcpount(C)`と一致することがわかる。そして、以下の場合に条件を満たす X、Y は存在しないことがわかる。

  - `a + b < popcpount(C)`
  - `abs(a-b)%2 != popcpount(C)%2`
    - `popcpount(C)`が偶数なら、幾つビットを受け渡しても X と Y の popcount の差は偶数にしかならないため。
  - `abs(a-b) > popcpount(C)`
    - 最大の差分は（C、0）の時の`popcpount(C)`であるため。

- 上記を弾いたのち、 X、Y を(C, 0)または(0, C)で初期化し、適切な diff になるまでビットを受け渡す。

- その後、所定の `popcount(X)（=a）`、`popcount(Y)（=b）`に達するまで無害な方法でビットを足して行けばいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/d/main.go
:::

## [E - Set Add Query](https://atcoder.jp/contests/abc347/tasks/abc347_e) / 遅延評価

- 愚直にやると N 回のクエリの中で N 回ループをやらないといけないので間に合わない。後者を高速化する。$A_i$ に対する更新結果はその後の更新に影響を与えないので、まとめて行うためになんらかの**遅延評価**を考えたい。

### 解法 1 累積和

- 「各 $A_i$ の i が、いつ集合 S に追加されたか、削除されたか（`var idxInOut [][]int // idx => in, out, in, ...`）」を記録し、「j 回目のクエリでいくつインクリメントがおきたかの**累積和**」を記録すると、最後に各 $A_i$ に対して値を求められる。
  - 各 `idxInOut`の要素数について、奇数のもの（最後に out していないもの）には Q をアペンドすればいい。
  - `idxInOut`の要素数の合計は高々 N なので、全体で`O(N)`で済む。

### 解法 2 ポインタ

- 今までに行われたインクリメントを`var increment int`に反映していく。
- S に idx の追加があったときに、`&increment`とそれまでのインクリメントを相殺するための`-*increment`を持った構造体をスライスに追加する。
- S に idx の削除があったときに、上記スライスから別のスライスにインクリメントを整理した上で構造体を移す。
- 最後に各 i に対して、いずれかのスライスから`Increment`を取り出し、値を求められる。

```go
type Increment {Diff int, increment *int}
var increments []Increment // idx => ongoing Inc
var suspendedIncrements []Increment // idx => suspended Inc
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc347/e/main.go
:::

# 346

## [B - Piano](https://atcoder.jp/contests/abc346/tasks/abc346_b) / 無限数列、円環

- **無限数列の条件に合う部分列を探すときは、2 周期分の数列を探索することで全ての部分列が探索できる。**

  - **指定の部分列の長さが一周期分を超えるときは、両側にはみ出す区間のパターンだけ考えればよく**、それが上記で探索できるということ。

- よって`部分列の長さ：W+B%12`、`探索する数列の長さ：24`となり、最大 24 回の探索で答えが判定できるので、**全探索**する。

- 類題：[384 D - Repeated Sequence](http://localhost:8000/articles/b1de75b0849b32#d---repeated-sequence-%2F-%E7%84%A1%E9%99%90%E6%95%B0%E5%88%97%E3%80%81%E5%B0%BA%E5%8F%96%E6%B3%95-or-%E5%86%86%E7%92%B0-%2B-%E7%B4%AF%E7%A9%8D%E5%92%8C)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/b/main.go
:::

## [C - Σ](https://atcoder.jp/contests/abc346/tasks/abc346_c) / 等差数列の和の公式

- As をソートし、`As[i] - As[i-1] => 1`なら間に飛ばされている整数があるので、その飛ばされている数字の合計を**等差数列の和の公式**で求めればいい。
- ただし、0 から As[0]の間で飛ばされている数も見つけたいので、As に 0 をアペンドしておく。
- K までの間に飛ばされている数字がないかどうか見たいので、As に K が含まれていると K に到達したイテレートでループを break できるので都合がいい。K が含まれていなければ K をアペンドし、飛ばされている数の合計に K を足しておく。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/c/main.go
:::

## [D - Gomamayo Sequence](https://atcoder.jp/contests/abc346/tasks/abc346_d) / 累積和

- どこで周期を変えるかは非自明であるため、その探索 O(N)はやらざるを得ない。よって、効率的にコストを計算する必要がある。
- N 文字の良い文字列とは、N 文字の`01`周期の繰り返し文字列（zeroOneSeq）と`10`周期の繰り返し文字列（oneZeroSeq）を用意し、index 0 ~ i が片方のもの、index i+1 ~ N-1 がもう一方のものになっている文字列であると**言い換えられる**。（0 < i < N-1）
- oneZeroSeq、zeroOneSeq を作るためのコストの**累積和**を作成しておき、周期の境目ごとのコストを累積和から算出していけば、O(N)で最小コストが求められる。
  - `oneZeroSeq => zeroOneSeq`と`zeroOneSeq => oneZeroSeq` の順番があり得ること、累積和（長さ N+1）からの値の取り出し方に注意する。
- 類題: [334 C - Socks 2](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#c---socks-2-%2F-組み合わせ、累積和)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/d/main.go
:::

## [E - Paint](https://atcoder.jp/contests/abc346/tasks/abc346_e) / 後ろから見る or 二分探索

- マスの最終的な色は、そのマスが属する行 or 列に対して**最後に**どの色で塗られたか。

### 解法 1 後ろから見る

- 行、列が未確定かどうかを管理しつつ、**クエリを後ろから処理する。**
- 行が一つ確定した場合、それ移行（=以前）のクエリでなんらかの列を確定させるとき、H-1 マスしかその色で塗れない。これを利用し、remainH, remainW を記録更新する。
- 最後に`remainH * remainW`を色 0 のカウントに足す。（何行目、何列目かという情報はどうでもいいので、グリッドを右下から塗り、最後に左上の領域が塗られずに残るというイメージを持つと分かり易い。）

### 解法 2 二分探索

- 各行、各列が最終的に何回目のクエリで何色で塗られたかを記録する。スライスは`{qIndex: 0, color: 0}`で初期化。
  - その後、`qIndex`でソート。
- 上記スライスをループし、その行への変更より`qIndex`が大きい列の変更がいくつあるかを**二分探索**し、その行の変更で何マスその色で確定したかをカウントする。
  - 初期値の`{qIndex: 0, color: 0}`の場合スキップ。重複`qIndex`は二分探索の妨げにはならないものの、塗られなかったマスを重複でカウントしてしまうことにつながってしまうため。
- 最後に総マス数から上記の操作で確定したマス数を引いたものを色 0 のカウントに足す。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc346/e/main.go
:::

# 345

## [B - Integer Division Returns](https://atcoder.jp/contests/abc345/tasks/abc345_b)

- 愚直。go の割り算（`/`演算）は切り捨て。

## [C - One Time Swap](https://atcoder.jp/contests/abc345/tasks/abc345_c)

- スワップによって文字列が変化するのは、ある`Ss[i]`を別の文字種である`Ss[j]`とスワップしたとき。
- 文字種ごとに考えたいので、とりあえず`map[char]count`のマップにする。
- 各文字種ごとに、それらの文字以外とスワップするとユニークな文字列になる。
  - ループで数え上げ可能だが、ある index x, y について、`(i: x, j: y)`と`(i: y, j: x)`の 2 通りについて重複加算することになってしまう。（というより本来 i < j となる組み合わせのスワップしか許容されない。）なので、最後に数え上げを 2 で割る。
- あるスワップをして、オリジナルの S と全く変わらないものができても答えに１加算するべきなので、同じ文字種が２つ以上ある場合はそうする。（サンプルケースが教えてくれている。）

```go
sum := 0
sameChars := false
for _, count := range m {
  sum += count * (len(Ss) - count)
  if count >= 2 {
    sameChars := true
  }
}
sum = sum / 2
if sameChars {
  sum++
}
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc345/c/main.go
:::

## [D - Tiling](https://atcoder.jp/contests/abc345/tasks/abc345_d) / ポリオミノ、ビット全探索、順列

- **ポリオミノ系の問題は基本全探索で解く。**
  - 空きマスの最も左上からタイルを配置していき、グリッドからはみ出したり配置済みのタイルと被ると失敗。失敗せずにグリッドがすべて埋まれば（=空きマスが見つからない状態になれば）成功。
- $配置のパターン数 = タイルを使う順番 * 各タイルを縦横どちらで使うか = 7! * 2^7 = 645120$
  - 各タイルを縦横どちらで使うかは**ビット全探索**する。
- さらにタイルを置くたびに以下を行うため$O(200 * 645120) = O(129024000)$となるが、十分現実的。
  - タイルのマスが使用済みではないか調べつつ、使用済みの記録をする：10^2
  - グリッドをさらって最も左上の空きマスを調べる：10^2
- **`NextPermutation()`で順列に対してロジックを適用するときは、オリジナルの順列への適用を事前に別で書く必要がある。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc345/d/main.go
:::

# 344

## [A - Spoiler](https://atcoder.jp/contests/abc344/tasks/abc344_a)

- `Ss = append(Ss[:barIdx1], ...Ss[barIdx2+1:])`で該当区間を取り除く。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/a/main.go
:::

## [B - Delimiter](https://atcoder.jp/contests/abc344/tasks/abc344_b)

- `for true {}`で 0 が登場するまで行を読み込んでスライスに追加。最後にスライスを反転。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/b/main.go
:::

## [C - A+B+C](https://atcoder.jp/contests/abc344/tasks/abc344_c)

- Xi ごとに全探索すると、$O(Q * (N * M * L)) = O(3*10^8 * 100^3)$となり間に合わない。
- 問題の性質上 Xi ごとのループは必ずするので、Xi が作成可能かを高速に判定する必要がある。
- A, B, C の組み合わせをあらかじめ全探索（$O(100^3)$）して和をマップに記録しておけば、マップへのアクセスのみで各クエリを処理でき間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/c/main.go
:::

## [D - String Bags](https://atcoder.jp/contests/abc344/tasks/abc344_d) / DP（メモ化再帰）

- 全探索すると $O(袋の要素数^{袋の数}) = O(10^{10})$ となり間に合わない。
- 問題の性質上、順に各袋から要素を取る（またはとらない）、次の袋にいく...という処理はせざるを得ないと考えられるので、再帰を使いそう。
- **DP（メモ化再帰）** で枝狩りができないかを考える。「ある袋まで処理し終わっている」「T があるインデックスまで完成している」という状態が同じなら、**それまでの経過は関係ない。**
  - **これを管理する状態とし、状態ごとのコストをメモ化する。**
  - ある状態に到達した時に、コストがメモ化されていなければさらに再帰して先に進む。
  - メモ化されているコストより低いコストで到達したならメモを更新し、更に再帰して先に進む。それ以上のコストで到達したなら処理を打ち切る。
- DP（メモ化再帰）の計算量はとりうる状態の数による。今回は以下のようになり間に合う。
  - $O(袋の数 * len(T) * コストとして取りうる値) = O(10 * 100 * 10) = O(10000)$
  - 数え上げのような問題と違いメモ化された値によっても再帰が進む可能性があるので、それも計算量においては状態と見なされる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/d/main.go
:::

## [E - Insert or Erase](https://atcoder.jp/contests/abc344/tasks/abc344_e) / 双方向連結リスト

- ノードの順番を管理、更新する様な場合、**双方向連結リスト（Doubly Linked List）** を使えば以下のことが高速に行える。（$O(1)$）
  - 連続するノードから特定のノードを消して前後を繋げる
  - （`map[ノードの値]ノードのポインタ`を別で管理することで、）特定のノードの前後に要素を挟み込む

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc344/e/main.go
:::

# 343

## [B - Adjacency Matrix](https://atcoder.jp/contests/abc343/tasks/abc343_b)

- 愚直。何も出力しない場合は空行を１行のみ出力することに注意。

## [C - 343](https://atcoder.jp/contests/abc343/tasks/abc343_c) / 整数問題（最大のいい数）

- まず立方数のみについて考える。最大の K を考える。$N = 10^{18} = (10^6)^3 より、 K = 10^6$（**数式の変形**）
- よって検討すべき K は 0 ~ 10^6 であり、100 万個。立方数も同様に 100 万個。**全探索**できそう。
- 立方数のスライスを用意しておき、N より大きいインデックスを二分探索し、-１する。そこから回文判定のループをインデックスをデクリメントしながらする。
- 回文判定のコストは`文字数/2`で、n は最大でも 7 桁なので全探索が十分間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc343/c/main.go
:::

## [D - Diversity of Scores](https://atcoder.jp/contests/abc343/tasks/abc343_d)

- ユニークな要素の数を考えたいのでマップを上手く使えばいい。二分探索等はしないので Ordered Set は使う必要がなく、通常のマップで事足りる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc343/d/main.go
:::

# 342

## [A - Yay!](https://atcoder.jp/contests/abc342/tasks/abc342_a)

- マップで文字種の出現数をカウント。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/a/main.go
:::

## [B - Which is ahead?](https://atcoder.jp/contests/abc342/tasks/abc342_b)

- マップに各番号（の人）の出現位置を記録。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/b/main.go
:::

## [C - Many Replacement](https://atcoder.jp/contests/abc342/tasks/abc342_c) / メモ化

- 文字列を更新する作業はせざるを得ないため、N（2×10^5）のループは無くせない。つまり、ある文字が最終的にどの文字になるのかを高速に判定する必要がある。
- クエリを処理しながらある文字が最終的にどの文字になったのかを**メモ化**するか、あらかじめ a-z が何になるのかをメモ化しておく。
  - 計算量は $O(N + 26*Q) = O(5400万)$
  - **アルファベットが 26 文字しかないことに着目する問題。**
- **このようなデータ遷移を木のようなデータ構造に記録し、あるデータに対応する最終的な状態を高速に取り出すのは簡単ではない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/c/main.go
:::

## [D - Square Pair](https://atcoder.jp/contests/abc342/tasks/abc342_d) / 整数問題（いい数の個数）、素因数分解、平方数、合同式

- **平方数**は$(a^x)^2 * (b^x)^2 + ...$と表現でき、逆にこのような数は平方数である。
  - よって、**平方数の素因数の指数は全て 2 の倍数である。**
- 整数 A, B の積が平方数になるのは、素因数の指数の和が全て 2 の倍数になっている時。
  - $(a^p * b^q) * (a^r * b^s)$ が平方数であるとき、
  - $p + q \equiv r + s \equiv 0 \mod 2$
  - $(p \mod 2) + (q \mod 2) \equiv (r \mod 2) + (s \mod 2) \equiv 0 \mod 2$
  - つまり指数を 2 で割った余りに変換し、全ての素因数の指数が 0,0 または 1,1 の組み合わせになっているなら、平方数になる。
  - **各 Ai に対して素因数分解をし、素因数の指数を 2 で割った余りに変換し、それらを掛け合わせた値にする。こうして変化させて値が同じになった Ai 同士は、掛け合わせると平方数の条件を満たす。**
  - よって各 Ai を変化させ、変化後に同じ値がいくつあるかを map に格納する。そして map の key ごとに ${}_{value} C_{2}$ を求めてたしあげればいい。
  - ただし A, B いずれかまたは両方に０が含まれる場合は必ず平方数になるので、そこだけ別で考える。
    - 0 を少なくとも片方で使う組合わせ：${}_{len(As)} C_{2} - {}_{len(As)-len(map[0])} C_{2}$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc342/d/main.go
:::

# 341

## [C - Takahashi Gets Lost](https://atcoder.jp/contests/abc341/tasks/abc341_c)

- グリッドサイズ 500^2、実行時間 3sec という制約から、**全探索**が間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc341/c/main.go
:::

## [D - Only one of two](https://atcoder.jp/contests/abc341/tasks/abc341_d) / 整数問題（K 番目のいい数）、二分探索

- N と M の倍数を列挙すると、N\*M の周期になっている。（どちらの倍数が何番目に出てくるか。）K を周期の長さで割り、余りを順に列挙する方法を考えた。しかし制約より余りの最大は(10^8)^2 なので、厳しい。
- `0~K-1`で No になり、`K~INT_MAX`で Yes になるような条件があれば、**二分探索**が使える。
  - `f(x) = x以下の条件に当てはまる倍数`を実装し、`f(x) >= K`という条件で二分探索すれば、目当ての値が見つけられる。
- 制約より、探索範囲の上限は`10^8*10^10`でいい。
  - `A <= B` とし、B が`10^8`、K が`10^10`だった場合、`10^8*10^10`までの範囲に K 個以上の条件に当てはまる倍数がし存在するため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc341/d/main.go
:::

# 340

## [C - Divide and Divide](https://atcoder.jp/contests/abc340/tasks/abc340_c) / メモ化再帰

- 2 以上の数字について、「数字分のコストを総コストに加算し、分割する」を再帰的に繰り返すので、**メモ化再帰**が使える。
- **計算量はとりうる状態＝メモの数になる。**
- $2^{63} \approx 10^{19}$ ということを覚えておけば、再帰的に二分割を行ってできる階層は 63 以下になることがわかる。一階層ごとに最大二種類の値が生まれる（奇数を分割する場合）ので、計算量は$O(126)$以下になり間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/c/main.go
:::

## [D - Super Takahashi Bros.](https://atcoder.jp/contests/abc340/tasks/abc340_d) / ダイクストラ法、優先度付きキュー（ヒープ）

- **ダイクストラ法**で解く。以下基本の tips。

  - グラフを作成するときは、`var graph [][][2]int // [node: [[node, weight],  ...], ...]`のような型になる
  - **優先度付きキュー**の要素は、`type item {node, weight int} // weightは始点からの距離`のような型になる。
  - **確定済みノード、各ノードの始点からの距離を別々のマップで管理する必要がある。**

- 類題: [362 D - Shortest Path 3](http://localhost:8000/articles/b1de75b0849b32#d---shortest-path-3-%2F-%E3%83%80%E3%82%A4%E3%82%AF%E3%82%B9%E3%83%88%E3%83%A9%E6%B3%95%E3%80%81%E5%84%AA%E5%85%88%E5%BA%A6%E4%BB%98%E3%81%8D%E3%82%AD%E3%83%A5%E3%83%BC%EF%BC%88%E3%83%92%E3%83%BC%E3%83%97%EF%BC%89)

---

- 通常のダイクストラ法だと最短距離（時間）しか求められないが、距離（時間）を記録するときに prev node を一緒に記録しておくと、最後にそこから辿って経路も求めることができる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/d/main.go
:::

## [E - Mancala 2](https://atcoder.jp/contests/abc340/tasks/abc340_e) / 遅延セグメント木

- 箱を区間にのせる。クエリごとに箱 $B_i$ のボール数を 0 にし、$B_{i+1}~B_{i+ボールの数}$ の区間にプラス 1 をしていけばいい。
  - ボールの数が区間の長さより多い場合は更新の仕方に注意。
- 区間の和の更新は、**遅延セグメント木**を使えば`O(log N)`で高速に行える。区間の和の取得（ノード単体での取得も含む）も`O(log N)`で行える。
- 遅延セグメント木、セグメント木の詳細は、実装や[こちらの記事](https://qiita.com/Kept1994/items/d156a1ac1fe28553bf94)を参照。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc340/e/main.go
:::

# 339

## [B - Langton's Takahashi](https://atcoder.jp/contests/abc339/tasks/abc339_b)

- ドーナツの表面の様な構造をトーラス状の曲面という。
- **グリッドで上に行く場合、h-1 する！下に行く場合 h+1 する！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/b/main.go
:::

## [C - Perfect Bus](https://atcoder.jp/contests/abc339/tasks/abc339_c)

- `minStart := 0`で初期化しクエリを処理する。矛盾が生じたら minStart を辻褄が合う様にインクリメントする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/c/main.go
:::

## [D - Synchronized Players](https://atcoder.jp/contests/abc339/tasks/abc339_d) / BFS（グリッド）

- **最短**操作回数を求めるので、**BFS**。プレイヤー二人の位置の組み合わせより、$O(60^2 * 60^2)$となる。
- 試したプレイヤー二人の位置関係を記録する必要がある。**メモは 60^4 と巨大なので、マップだと遅い。** ４重スライスで管理する。（マップでもあらかじめサイズを最大数で初期化しておくと、ギリギリ TLE しない。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/d/main.go
:::

## [E - Smooth Subsequence](https://atcoder.jp/contests/abc339/tasks/abc339_e) / DP(インライン)、セグメント木

- `dp[どのインデックスまで見たか][最後の数字が何か] = 部分列の最大長`という DP が思いつく。
  - しかしこれの計算量（とりうる状態の数）は $O(N^2)$ なので間に合わない。
  - 空間計算量（テーブルの大きさ）も同様で、メモリが足りない。
- `dp[i][j]`に遷移してこれるのは、`dp[i-1][max(j-D, 0)] ~ dp[i-1][min(j+D, N)]`の範囲であり、その中で最大の値を持ったセルからの遷移が最善。**区間における最大を求めたいので、区間最大のセグメント木が使える**。
- また、**インラインの DP**（一次元配列を使い回す）をすることでテーブルサイズも小さくでき、**DP テーブルそのものをセグメント木にできる。**
  - `dp[j]`に、 `dp[max(j-D, 0)] ~ dp[min(j+D, N)]`
- **詳細は実装参照**。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc339/e/main.go
:::

# 338

## [C - Leftover Recipes](https://atcoder.jp/contests/abc338/tasks/abc338_c) / 資源配分問題

- **料理 A を最大どのくらい作れるのかをとりあえず求める。** 全種類の材料の在庫/必要量の min になる。
- このとき料理 B がどのくらい作れるのかも、全種類の材料の在庫/必要量の min になる。(O(10))
- 料理 A のを最大量~0 作る場合についてこれをやればいいので、$O(10^6 * 10)$ で解くことができる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc338/c/main.go
:::

## [D - Island Tour](https://atcoder.jp/contests/abc338/tasks/abc338_d) / 円環、imos 法

- **サンプルが弱いので、適当な例を考える。**
  ```
  5 4
  1 3 2 5 3
  ```
- **各経路は独立で考えても良い**ので、`(1, 3), (3, 2), (2, 5), (5, 3)`の経路の距離の和について考えればいい。
- また、**経路の始点と終点を入れ替えても距離に影響しない**ので、`(始点 < 終点)`となる様にソートする。
- **円環を切り開いた数直線を書く。**
- 例えば`(2, 3)`の区間に関して、`[2, 3) = [s, t])`の間の辺が封鎖されると距離が 4 になり、それ以外=`[1, 2) = [0, s)]`または`[3, 5) = [t, N)`の間の辺が封鎖されると距離が 1 になることがわかる。
  :::details image
  ![image](/images/ABC/338/d.png)
  :::
- 「ある区間内の辺が封鎖されると、ツアーの総距離にある数字が足される」と解釈できる。これは区間更新なので、**imos 法**で効率化可能。
- 「index i の要素は、`[島i+1, 島i+2)`の辺を封鎖したときのツアーの総距離 (最後の要素は`[島N, 島1]`の辺を削除した時の~)
  」**という長さ N+1 の int スライスを作成することができれば、最小の要素の値が答えになる。**
- 全ての要素を 0 で初期化した N+1 の長さの int スライスを作成する。経路でループし、ある区間が封鎖されるとその経路の距離が X になる（ツアーの総距離に X プラスとなる）という情報を int スライスに **imos 法**で反映していけば、最終的に作りたいスライスの**差分配列**になる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc338/d/main.go
:::

# 337

## [B - Extended ABC](https://atcoder.jp/contests/abc337/tasks/abc337_b)

- **ランレングス圧縮**をし、圧縮後のスライス長が３以下か、文字種の並びが期待する並び（ex, {A, B, C}, {B, C}, {A}, etc..）のいずれかと一致しているかで判定。

- `reflect.DeepEqual()`はスライスの中身の順序も含めて判定してくれる。
- 期待する並びはベタガキで列挙したが、**ビット全探索**でもいける。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/b/main.go
:::

## [C - Lining Up 2](https://atcoder.jp/contests/abc337/tasks/abc337_c) / Linked List、再帰

- `map[前にいる人の番号]自分の番号`を作成しておくと、先頭の人から順に再帰関数を使って辿ることができる。（map から何も見つからない＝自分の後ろに誰もいない場合に終了する。）
- **Linked List**に更新していき、最後にダンプしてもいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/c/main.go
:::

## [D - Cheating Gomoku Narabe](https://atcoder.jp/contests/abc337/tasks/abc337_d) / キュー、累積和

- 各行各列について、K 目が成立するか調べたい。
- 行・列の長さ K の部分区間について、高速に何回で K 目並べられるかを調べたい。
- 行、列ごとに**キュー**を使ってセルの値を格納していき、
  - `o`なら`oCount++`
  - `x`なら`q.Clear()`
  - `.`なら何もしない
  - 長さが K より多いなら`q.Pop()`して要素を減らし、`o`が出てきたら`oCount--`する。
  - その後 K 以上なら`q.Size()-oCount`で答えの更新を試みる。
- あるいは予め行、列ごとに`x, o, .`の数の**累積和**を作成しておき、それを元に書く長さ K の部分区間について高速に計算する手もある。。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/d/main.go
:::

## [E - Bad Juice](https://atcoder.jp/contests/abc337/tasks/abc337_e) / インタラクティブ問題、二進数

- 誰がお腹を壊したかの結果の情報は 2 進数であり、$2^M$ 通りのパターンがある。つまり、 $N <= \log M$ となる最小の M を設定し、結果の 2 進数からどのジュースか特定できればそれが最善。
- `i = 0 ~ N-1` でループし、二進数にしたときの j ビット目(left 0-indexed)が立っていれば、人`M-j`はジュース`i+1`を飲むことにする。これにより、ジュース`i+1`が腐っていた時に`i`の二進数表現と同じように人々がお腹を壊すことになる。
  - 結果は、人 1 の情報が先頭（最左）に来て人 M の情報が末尾（最右）に来ていることに注意。
- あとは結果の文字列を二進数に変換すれば、それが腐ったジュースの答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc337/e/main.go
:::

# 336

## [B - ctz](https://atcoder.jp/contests/abc336/tasks/abc336_b)

- 愚直に後ろからビットポップ判定

## [C - Even Digits](https://atcoder.jp/contests/abc336/tasks/abc336_c) / 整数問題（K 番目のいい数）、N 進数 or 桁 DP（メモ化再帰） + 二分探索

### 5 進法

- いい数は５つの数字を使って表現されるので、5 進法と同じ。
- N 番目の 5 進数の数字は N を５進数に変換したもの、と思いきや N-1 を 5 進数に変換したもの。0 を１番目と数えるので。
  - `strconv.FormatInt(int64(N), 5)`
- 実際は`0~4`ではなく`0,2,4,6,8`を使っているので、その対応をマップで作成しておき、５進数を変換して出力する。
- 類題: [372 B - 3^A](https://zenn.dev/shinonome81/articles/b1de75b0849b32#b---3%5Ea-%2F-%E6%95%B4%E6%95%B0%E5%95%8F%E9%A1%8C%E3%80%81n-%E9%80%B2%E6%95%B0-or-%E8%B2%AA%E6%AC%B2%E6%B3%95)

### 桁 DP（メモ化再帰）+二分探索

- $f(x) = x以下のいい数の個数$ を実装して、`AscIntSearch(0, INT_MAX, func(num int) {return f(num) >= K})`として**二分探索**すればいい。
- 上限以下の条件に合う数の個数の計算は、**桁 DP（メモ化再帰）** で求められる。
  - `var digitDP func (pos, strict int) int // pos: 左から何桁目まで決定済みか、strict: 埋まっている桁が上限のそれと全て一致しているか`を実装すればいい。
  - 一段目の関数呼び出しは`{0, 2, 4, 6, 8}`で行い、一桁目が上限のそれと一致しているときは`strict=true`
- **桁 DP の計算量はとりうる状態と一致する。** $O(pos * strict) = O(19 * 2)$
- **0~INT_MAX（2^63）の二分探索は最大 63 回行われる**ので、$O(19 * 2 *63) = O(2394)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc336/c/main.go
:::

## [D - Pyramid](https://atcoder.jp/contests/abc336/tasks/abc336_d)

- **ピラミッド型は考えづらいので、右側と左側の階段型について考える。**
- ある$A_i$が頂点だとして、左側だけを考慮した時の最大の高さは、$height(A_i) = min(height(A_{i-1})+1, A_i)$
- このように全ての Ai に対して左側だけを考慮した高さを index 0 から出していき、右側だけを考慮した高さを index N から出していく。その後全ての頂点について`min(lHeight, rHeight)`でとりうる高さを出し、最大の高さを記録更新すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc336/d/main.go
:::

# 335

## [B - Tetrahedral Number](https://atcoder.jp/contests/abc335/tasks/abc335_b)

- 0~N の三重ループを回し、それぞれの和が条件に合うかを判定すればマッチする x, y, z の組み合わせを**辞書順**に列挙できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/b/main.go
:::

## [C - Loong Tracking](https://atcoder.jp/contests/abc335/tasks/abc335_c)

- 移動クエリごとに頭の座標が変化し、それ以外の座標が前のパーツの以前の座標にスライドする。
- 尻尾~頭の順で座標をスライスに格納し、移動クエリの際は`sl = appen(sl[1:len(sl)-1], newCoodinate)`とすれば、O(1)で座標を更新できる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/c/main.go
:::

## [D - Loong and Takahashi](https://atcoder.jp/contests/abc335/tasks/abc335_d) / グリッド（応用）

- 出力するパターンを決める。サンプル 1 の渦巻き状にする。
- スタート位置、一片の長さを渡せばグリッド内の四角の四辺を埋めてくれる関数を実装して、再帰呼び出しをすれば問題が解ける。
  - 渦巻きが再帰的な構造になっていることに気づき、**どんな関数を実装すれば処理ができるかを考える。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc335/d/main.go
:::

# 334

## [B - Christmas Trees](https://atcoder.jp/contests/abc334/tasks/abc334_b) / 数直線

- **R, L に-A し、[R, L]の区間の $X \equiv A \mod M$ ではなく $X \equiv 0 \mod M$ となる X の数を数えることにする。**
- R 以下の最も R に近い $K_r*M$ の $K_r$ を求め、L-1 以下の最も L-1 に近い $K_{l-1}*M$ の $k_{l-1}$を求める。
- $K_r - K_{l-1}$が答えとなる。R, L-1 が両方ゼロ以上の場合、R, L-1 が 0 を跨ぐ場合、R, L-1 が両方ゼロ以下の場合を考えると、全てでそうなる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/b/main.go
:::

## [C - Socks 2](https://atcoder.jp/contests/abc334/tasks/abc334_c) / 組み合わせ、累積和

- [数学的な証明](https://atcoder.jp/contests/abc334/editorial/8983)は難しいが、捨てられていない靴下はそのままペアにすることが最善であることが直感的に分かる。
- 片方が捨てられて余っている靴下について、どうペアを組むのが最善かを求める。余りが偶数の場合は、(0, 1), (1, 2), ...をペアにするのが最善。
- 余りが奇数の時に、どの靴下を使わないのが最善かを求める問題になる。奇数インデックスの靴下を削除し、その左右で隣り合う靴下をペアにすることになる。（偶数インデックスだと、削除した靴下を挟んでペアを作らなければいけない組みが１つできてしまい、明らかに最善ではない。）
- 靴下は、直前の靴下あるいは直後の靴下のいずれかとペアになる。index 0 始まりのペア作成と、index 1 始まりのペア作成を考え、それぞれの場合の奇妙さの**累積和**配列を作る。（As を二つ見て prefSum を一つ埋めるというズレがあるのにループの実装では注意。）
- 使わない靴下を挟んで、左側が前者の累積和の値を採用し、右側が後者の累積和の値を採用することになる。実装は以下の通り。
  ```go
  for i := 0; i<prefSumLen; i++; {
    oddity := prefSumZeroStart[i] + prefSumOneStart[prefSumLen-1] - prefSumOneStart[i]
    ans = min(ans, oddity)
  }
  ```
- 類題: [346 D - Gomamayo Sequence](https://zenn.dev/shinonome81/articles/3e1c0c8a9c00fc#d---gomamayo-sequence-%2F-%E7%B4%AF%E7%A9%8D%E5%92%8C)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/c/main.go
:::

## [D - Reindeer and Sleigh](https://atcoder.jp/contests/abc334/tasks/abc334_d) / 貪欲法、累積和、二分探索

- 各クエリに対して、必要なトナカイの少ないソリから**貪欲に**トナカイを割り当てた方がいい。
- 各ソリに必要なトナカイの数を、昇順にソートする。**累積和**の配列にすると、`sort.Search(N+1, func (i int) bool { retunr prefsum[i] > X)`で**二分探索**すると、運べるソリの数が分かる。
  - 累積和の配列は、長さ N+1 であることに注意。（index 0 に 0 が入っているため。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/d/main.go
:::

## [E - Christmas Color Grid 1](https://atcoder.jp/contests/abc334/tasks/abc334_e) / UnionFind、合同式

- **$A / B \mod M = A * B^{-1} \mod M$ である**。（$B^{-1}$ は B の逆元。）
- 総マス目数のサイズの**UnionFind**を作成し、緑のマス目に対して隣接緑マスと連結させる。
  - マス目の番号を `h*W + w`とすると`No 0 ~ N-1`のマス目ができ、UnionFind のインデックスに対応させることができる。
  - 出来上がった UnionFind には赤マスがそれぞれ root として含まれることに注意。
  - $O(4*H*W)$
- `baseConnectedComponents := uf.CountRoots() - redCnt`で初期状態の緑の連結成分数を求める。
- 赤マスでループし、周辺の緑マスのルートノードをマップ`m`に格納する。それらのルートノードが一つに連結されるので、`baseConnectedComponents - len(m) + 1`がそのマスを緑にした後の緑の連結成分数である。
  - 周囲が赤マスしかない赤マスの場合もこれでいい。`len(m) == 0`であり、自身が単一の緑の連結成分になる分+1 される。
  - $O(4*α(H*W)*H*W)$
- 上記をマップに格納し、最後に`ans := Mod(effectSum * InverseElm(len(effectMap), M), M)`すれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc334/e/main.go
:::

# 333

## [B - Pentagon](https://atcoder.jp/contests/abc333/tasks/abc333_b) / 図形、円環

- 各頂点のインデックスのスライスを作る。頂点 1 のインデックスを 0, 頂点 2 のインデックスを 1, ..., 頂点 5 のインデックスを 5 とする。
- 頂点 a, b の距離は、以下のように計算できる。
  ```go
    a, b = sortIntAsc(a, b)
    dist := min(b-a, 5-(b-a))
  ```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/b/main.go
:::

## [C - Repunit Trio](https://atcoder.jp/contests/abc333/tasks/abc333_c) / 整数問題（K 番目のいい数）、全探索（全列挙後にソート）

- 条件に合致する数（Repunit Trio）を**全列挙**することができる。
  - Repunit は桁数毎に一種類なので、INT_MAX が 19 桁なことから 19 種類。19^3 は十分列挙可能。
  - `rep(i=1~max)(j=i~max)(k=j~max)`のループで、**順列**を**辞書順**に列挙できる。
  ```go
  	sl := make([]int, 0, pow(19, 3))
    // 上限は18桁に設定。19桁だと最後のイテレートでオーバーフローでマイナスになって無限ループ
    // 問題の制約より、上限ギリギリの巨大なRepUnitはなくても大丈夫。
    for i := 1; i <= 111111111111111111; i += pow(10, GetDigits(i)) {
  	  for j := i; j <= 111111111111111111; j += pow(10, GetDigits(j)) {
  	  	for k := j; k <= 111111111111111111; k += pow(10, GetDigits(k)) {
  	  		sl = append(sl, i+j+k)
  	  	}
  	  }
    }
  ```
- **順列の辞書順が Repunit Trio の小さい順ではないことに注意。** $1 + 1 + 1111 > 11 + 11 + 111$
- ソート後に、N 番目の数を出力すればいい。
- **サンプル 3 が使うマックスの Repunit の桁数を教えてくれている。制約で N が小さいことのメリットを教えてくれている。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/c/main.go
:::

## [D - Erase Leaves](https://atcoder.jp/contests/abc333/tasks/abc333_d) / 木、dfs（ノードカウント）、累積和

- **問題の言い換え**：葉ノードが削除可能 => 始点ノードを葉にする => 始点に隣接する N 個のノードの「自身を含めた下位ノードの数」を求め、最もその数が多い隣接ノード以外について、下位ノードを全て削除すればいい。
- **dfs**で自身を含む下位ノードの数を記録できる。
- 始点隣接ノードの記録をソートし**累積和**を作成し、`prefsum[len(prefsum)-2]`をとれば答えになる。
- 類題：[368 D - Minimum Steiner Tree](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---minimum-steiner-tree-%2F-%E6%9C%A8%E3%80%81dfs%EF%BC%88%E3%83%8E%E3%83%BC%E3%83%89%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%EF%BC%89)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/d/main.go
:::

## [E - Takahashi Quest](https://atcoder.jp/contests/abc333/tasks/abc333_e) / Stack

- タイプ x のポーションで倒せるモンスターに遭遇する前に、タイプ x のポーションを拾っていなければならない。ポーションはできるだけ直前で拾った方が保持期間が短くすみ、「途中で持っているポーションの個数の最大値」を減らすことができる。
- よって`map[x]Stack[idx]`にポーションが拾える index を詰めていき、クエリ 2 で該当する種類のポーションのスタックからポーションを取り出し、その index では確定で拾うこととする。スタックが空なら破綻。
- `ansMap[idx]0 or 1`にポーションの index ごとの拾う拾わないを記録。キーを取り出し昇順にソートし、そのキーから値を取り出して最後に出力する。
- 「途中で持っているポーションの個数の最大値」は、もう一度 N 個のクエリを ansMap の最適行動を参照しながらなぞり、求める。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc333/e/main.go
:::

# 332

## [C - T-shirts](https://atcoder.jp/contests/abc332/tasks/abc332_c)

- 現在の `RequireAnyT`、`RequireLogoT` を記録、各 `Max` の更新を試みる。洗濯の日は `Require` をリセットする。
- LogoT を着る日に、`RequireAnyT` 及び `MaxRequireAnyT`の方も更新することに注意！

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc332/c/main.go
:::

## [D - Swapping Puzzle](https://atcoder.jp/contests/abc332/tasks/abc332_d) / グリッド（応用）、BFS

- **グリッドの列の入れ替え、行の入れ替えで発生する盤面のパターンは、$行の順列 * 列の順列 = H! * W!$ となる。**
  - $マス目の順列 = (H*W)!$ ではない。
- 今回の場合は $5! * 5! = 120^2$ パターンなので、**全探索**できる。
- **最短手数**を求める問題なので**BFS**。
  - visited map のキーはグリッドを文字列に変換して作る。
  - キューアイテムにはグリッドそのものを持たせる。
  - 行入れ替えまたは列入れ替えをする直前にコピーを作成し、そのコピーから次のキューアイテムを作る。隣接ノードをあらかじめ隣接リストに保持するのではなく、移動を行う直前に作成することを、**グラフを陽にもたない**という。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc332/d/main.go
:::

# 331

## [A - Tomorrow](https://atcoder.jp/contests/abc331/tasks/abc331_a)

- 超過した日月を%演算で丸めたら 1WA になったので、よりミスしにくい大小比較を使った。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/a/main.go
:::

## [B - Buy One Carton of Milk](https://atcoder.jp/contests/abc331/tasks/abc331_b) / 資源配分問題、全探索

- 制約の狭さから全列挙できそう。６, 8, 12 個入りは最大`N/6+1`, `N/8+1`, `N/12+1`個買える。三重ループして、`6*i+8*j+12*k >= N`なら minAns の更新を試みればいい。

- N が 6, 8, 12 のいずれか割り切れる場合は不必要に個数を 1 を足していたり、そもそも N を大幅に超える個数の組み合わせも試しているが、**最小金額を求める問題なので問題ない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/b/main.go
:::

## [C - Sum of Numbers Greater Than Me](https://atcoder.jp/contests/abc331/tasks/abc331_c) / 累積和

- $A_i$ より大きな要素の総和を求めるということで、As をソートして**累積和**を取れば良さそう。
- ただし同じ数字が重複しているときは、$prefsum_{N} - prefsum_{i+1}$ をとっても、自身と同じ数字も加算されてしまっている。
- `map[num]sum`を作り、**累積和をイテレートするときに`num := prefsum[i]-[i-1]`として A を復元**すれば、自身と同じ数を含まない累積和の値でマップの値を上書きできる。
- 最後に As でイテレートして、マップから答えを取得して出力すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/c/main.go
:::

## [D - Tile Pattern](https://atcoder.jp/contests/abc331/tasks/abc331_d) / 二次元累積和、包除原理

- 四角形の面積（含まれる何かの個数などでも可）を考えるときは、**右下一点を指定することで`原点-その点`の四角形の面積をだせる関数を実装し**、以下のような範囲を考えることで**包除原理**で目当ての面積が導き出せる。 （これはグリッドバージョンで、座標平面なら`f(右上)`を実装する。）
  :::details imgae この図を書いて思い出してもいい。
  ![image](/images/ABC/331/331_d_image1.png)
  :::
- `ans := f(C, D) - f(C, B) - f(A, D) + f(A, B)`
  - **引数に渡す前に A, B を 1 づつデクリメントするか、C, D を１つづインクリメントすることが、関数 f の実装を考える上で重要。**
- 関数 f の実装：ある点と原点を含む四角形に、周期（とそのパーツ、その中に含まれる黒マス）がいくつ含まれるのかは、以下の図のように考えられる。**詳細は実装およびコメントを参照。**
  :::details imgae
  ![image](/images/ABC/331/331_d_image2.png)
  ![image](/images/ABC/331/331_d_image3.png)
  :::
- **この手の問題でも実装は綺麗にできることが多いので、こんがらがったらやり方を見直す。**
- 類題：[354 D - AtCoder Wallpaper](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---atcoder-wallpaper-%2F-%E5%BA%A7%E6%A8%99%E5%B9%B3%E9%9D%A2%E3%80%81%E9%9D%A2%E7%A9%8D%E3%80%81%E5%8C%85%E9%99%A4%E5%8E%9F%E7%90%86)、[366 D - Cuboid Sum Query](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---cuboid-sum-query-%2F-%E4%B8%89%E6%AC%A1%E5%85%83%E7%B4%AF%E7%A9%8D%E5%92%8C%E3%80%81%E5%8C%85%E9%99%A4%E5%8E%9F%E7%90%86)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/d/main.go
:::

## [E - Set Meal](https://atcoder.jp/contests/abc331/tasks/abc331_e) / 価値の最大化、優先度付きキュー

- **組み合わせの価値の最大化問題は、優先度付きキューで解けることも多い。**
- Bs を降順ソートし、各`As[i]`と`Bs[0]`を組み合わせたものをキューに積む。Priority は A+B。
  - このキューには、（NG 組み合わせを無視すると）Priority が最大の組み合わせが必ず含まれる。最大の`A`と`B[0]`の組み合わせの Priority が最大だから。
  - キューから取り出した組み合わせが NG なら、(`x+1 < M`なら)`As[i]`と`Bs[x+1]`の組み合わせをキューに積む。
  - **この時、キューには相変わらずその時点で Priority が最大の組み合わせが必ず含まれる。**
    - `As[i]`と`Bs[x+1]`の Priority が最大なら当然そうなる。
    - そうでないなら取り出した組み合わせの次点である組み合わせが最大であり、次点やそれより劣っている他の組み合わせを変化させても次点より優れた組み合わせは作れない。
- NG 組み合わせの判定と B のスライドのために、キューには`qItem{a, b, aIdx, originalBIdx, bIdx}`という状態を積む。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc331/e/main.go
:::

# 330

## [B - Minimize Abs 1](https://atcoder.jp/contests/abc330/tasks/abc330_b)

- **場合分けして考える。**
  - $L <= A_i <= R$
    - `[L, R]`の範囲で、$A_i$ との距離（差分の絶対値）を一番小さくできるの $X_i$ は、$A_i$
  - $A_i < L <= R$
    - ~$X_i$ は、$L$
  - $L <= A_i < R$
    - ~$X_i$ は、$R$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/b/main.go
:::

## [C - Minimize Abs 2](https://atcoder.jp/contests/abc330/tasks/abc330_c) / 整数問題、全列挙、二分探索

- **あり得る x, y の上限が制約より導けそう。**
- D の上限を**式変形**すると、$2 * 10^{12} = (\sqrt 2 * 10^6)^2$。`0 ~ 2*10^6`までの数の二乗は、十分**全列挙**できる（200 万）。
- 平方数のスライスでループする。現在のインデックス以降の平方数から「現在の平方数 + その平方数が、D を超える平方数」を**二分探索する。** minAns の更新を試み、index が 1 以上ならその一つ前の平方数を使った値でも minAns の更新を試みる。
  - $O(200万 * \log 200万)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/c/main.go
:::

## [D - Counting Ls](https://atcoder.jp/contests/abc330/tasks/abc330_d)

- **ある`o`のマスを固定したとき**、同じ列の`o`を一つ、同じ行の`o`を一つ選ぶということ。あらかじめ行と列の`o`の数を記録しておけば、そのような組み合わせがいくつあるかが分かる。あとはマス目でループして足し上げるだけ。
  - 上記の操作をイメージすると、同じ組み合わせを別のマスを起点にしたカウントで重複カウントすることはない。
- **累積和**を使って解くことも可能。しかし上記のやり方の方がずっと簡単なので、立ち止まりたい。
  - 自身より前/下の`o`を一つづつ取る組み合わせを考える。そのために行と列の`o`の数の累積和をあらかじめ作成。
  - L 字の向きが 4 種類なので、4 隅それぞれを起点にマス目のイテレートをする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/d/main.go
:::

## [E - Mex and Update](https://atcoder.jp/contests/abc330/tasks/abc330_e) / Ordered Set

- **長さ N の数列の Mex（数列に登場しない最小の非負整数） は、0~N である。**
  - 要素の重複がなければ 0~N のいずれかの数字が使われていない、重複する場合は言わずもがな。
- 数列の数字ごとのカウントを取る。`var numCnt map[int]int`
- `mexCandidates`を**Ordered Set**で用意し、`0~N`の数字でループし`numCnt[num] == 0`なら set に`Insert()`。
- あとはクエリごとに `numCnt` と `set` を適切に更新し、`set.First().Value()`を出力する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc330/e/main.go
:::

# 329

## [C - Count xxx](https://atcoder.jp/contests/abc329/tasks/abc329_c) / ランレングス圧縮

- **ランレングス圧縮**して、圧縮後のスライスでループ。例えば`3_a`だったら、マップに`1_a`,`2_a`, `3_a`を記録。ループ全体で$O(N)$。最後にマップの長さを数えれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc329/c/main.go
:::

## [D - Election Quick Report](https://atcoder.jp/contests/abc329/tasks/abc329_d)

- クエリが 20 万個なので、各クエリで当選者を高速に求める必要がある。マップに各候補者の各得票数を記録し、最多得票数とその者を別で記録。各クエリでマップを更新するときに、最多得票数、その者と比較すればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc329/d/main.go
:::

# 328

## [C - Consecutive](https://atcoder.jp/contests/abc328/tasks/abc328_c) / 累積和

- クエリが 30 万個なので、クエリごとに**ランレングス圧縮**（$O(N)$）をしていては間に合わない。
- 隣り合う数の個数の**累積和**を作成しておけば、区間[l, r]のそのような数の個数が高速に求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc328/c/main.go
:::

## [D - Take ABC](https://atcoder.jp/contests/abc328/tasks/abc328_d) / Deque or Stack

- 文字列 S を順に**Deque**に突っ込んでおき、最後に入っている三文字が ABC であれば取り除けばいい。（**Stack**でもいい）。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc328/d/main.go
:::

# 327

## [B - A^A](https://atcoder.jp/contests/abc327/tasks/abc327_b)

- 適当に試すと`16^16`が B の上限を超えるので、A の候補を 16 まで**全探索**すればいい。
- あるいは適当な上限 INT_MAX や B を設定し、A^A が B を超えたら break でも可。
- **繰り返し二乗法**を使うと効率いい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc327/b/main.go
:::

## [C - Number Place](https://atcoder.jp/contests/abc327/tasks/abc327_c)

- 愚直（グリッドが極小）

## [D - Good Tuple Problem](https://atcoder.jp/contests/abc327/tasks/abc327_d) / 頂点彩色問題、DFS

- 「Xs について、インデックス i とインデックス j は異なる」という情報が複数渡されて、それらが矛盾しないかどうかという様に問題を言い換えられる。これは、グラフの**頂点彩色問題**である。（N 色を使い、辺で直接繋がったノード同士を違う色で塗り分けられるか。）
- Xs のインデックス番号をノードとし、違うことが確定しているインデックス同士を辺で結ぶ。そのようなグラフを隣接リストで作成する。
- Xs を全要素-1 で初期化し、インデックス番号でループ。`Xs[i]`が-1 なら **DFS** を開始し、未確定のノードに色をつけるか、つけてある色が矛盾しないかをチェックする。**詳細は実装参照。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc327/d/main.go
:::

# 326

## [C - Peak](https://atcoder.jp/contests/abc326/tasks/abc326_c) / 累積和、二分探索

- **入力値がソートされている保証がないので、ソートすること（As）**
- ある x 座標までのプレンゼント総数の**累積和**を作成できることがわかる。 `var psum []struct{x, count int}`
- As でループし、L を`As[i]`で**固定**、psum を x 座標 R 以上で psum を**二分探索**し、「その一つ前にある x 座標の累積和(=`psum[idx].count`)」-「L より一つ前の x 座標の累積和 (=`psum[i].count`)」で minAns の更新を試みる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc326/c/main.go
:::

## [D - ABC Puzzle](https://atcoder.jp/contests/abc326/tasks/abc326_d) / 全探索、DFS

- グリッドが最大 5\*5 なので全探索できそう。
  - 各行について をどのインデックスに置くかで $5*4*3 = 60$。それが５行なので $60^5$。まだ効率化が必要。
    - `A,B,C,.,.`の順列と考えてしまうと二つのドットが区別されてしまうので、間違い。
  - 各行について、１~5 行目はそれぞれどのインデックスに A を置くかを考えると、$5!$通り。A, B, C それぞれについて考え、文字種ごとにインデックスが重複するパターンを一旦許容しても、$120^{3}$となり間に合う。
- 上記のパターンを**全探索**する。ループのみで書こうと思うとループのネストが N によって動的に変化してしまう。**一定程度複雑な全探索は再帰（DFS）で書く。** `dfs(char string, grid [][]string) bool`
- `NextPermutation()`で「１~5 行目はそれぞれどのインデックスに char を置くか」を列挙し、その通りにグリッドを埋め、文字種をインクリメントして次の再帰へ。char が D ならグリッドが R,C の条件を満たすか判定して bool を返す。
- `NextPermutation()`は以下の様に書くと、オリジナルの順列への処理をループ外に別で書かなくて良くなる。

```go
next := true
for next {
  someFunc(sl)
  next = NextPermutation(sl)
}
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc326/d/main.go
:::

# 325

## [B - World Meeting](https://atcoder.jp/contests/abc325/tasks/abc325_b)

- mtg の時間としてあり得るのは標準時刻で 0~1 時、1~2 時、...23~24 時の 24 パターンと少ないので、**全探索**できる。
- mtg の開始・終了時刻を支社の現地時間に直し、それらが両方 9~18 時におさまっている場合、社員数を参加可能人数に足す。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/b/main.go
:::

## [C - Sensors](https://atcoder.jp/contests/abc325/tasks/abc325_c)　/ Union Find、DFS or BFS

- グリッド上で隣接するセンサー同士を**一つのグループにまとめる**というので、**Union Find**が使える。
- Union Find の対象となるのはセンサーのマスなので、一旦それらの座標をスライスに入れる。
- Union Find の内部配列のインデックス = センサースライスのインデックスということにし、マップ（`map[coordinate{i, j}]index`）を作成する。
- あとは各センサーマスを始点に **BFS** や **DFS** をしていき、Union Find を更新すればいい。ただし、それ以前の BFS、DFS で自身以外がルートになっているマス目はスキップ可能。（すでに他の始点からの探索で探索済みの**連結成分**に入っている。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/c/main.go
:::

## [D - Printing Machine](https://atcoder.jp/contests/abc325/tasks/abc325_d) / 区間問題、優先度付きキュー（ヒープ）

### 設計

- 数直線上に各製品の開始時間、終了時間を記録する。
- プリント可能な製品は、現在以前に開始しているもの。
- それらの **どれにプリントすべきかは、最も終了時間が近い製品である**。（すぐプリントできる対象から外れてしまうため。）
- 終了時間を**優先度付きキュー**に入れて、最も喫緊の製品のそれを取り出す方法が良さそう。
- 時刻を 1 づつインクリメントしていると TLE になる && 全く製品が存在しない区間が存在しうる　ので、キューが空になった後に次に見るべき製品が存在する時刻まで飛びたい。**何らかの形でどの製品まで見たかを保持する必要がありそう。**

### 実装

- 製品の開始時間と終了時間の構造体スライスを、ソートしておく。
- 大外の**ループの終了条件は、キューが空になりかつ全ての製品の処理が終わっていること**。
- 現在時刻から開始する製品の終了時間を全てキューに入れる。どの製品の終了時間まで入れたかのインデックスを保持しておく。
- キューから期限切れの終了時間を全て取り出す。
- キューが空でないなら、喫緊の終了時間を取り出し、ans をインクリメントする。
- キューが空でないなら、現在時刻を 1 インクリメントして次のループへ。キューが空なら、次に終了時間をキューに入れる製品の開始時間まで現在時刻を飛ばして、次のループへ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc325/d/main.go
:::

# 324

## [B - 3-smooth Numbers](https://atcoder.jp/contests/abc324/tasks/abc324_b) / 整数問題、全探索、素因数分解

- **素因数分解は $O(\sqrt N)$かかるため、N の制約より間に合わない。**
- 計算すると $\log_2 10^{18} = 59.7$ 、$\log_3 10^{18} = 37.7$ となるため、2 の乗数を 60 まで、3 の乗数を 38 まで**全探索**すればいい。
- **オーバフローしないように**、$2^i * 3^j > N$ となったときに内側の loop を break する。
- 繰り返し二乗法は $O(log_2 N)$なので、$O(60*38* (\log_2 60 + \log_2 38))$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/b/main.go
:::

## [C - Error Correction](https://atcoder.jp/contests/abc324/tasks/abc324_c)

- 文字列が等しいか、いずれかから一文字足す（一文字消す）と同じになるか、一文字のみ違うかを判定する頻出問題。ライブラリを用意する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/c/main.go
:::

## [D - Square Permutation](https://atcoder.jp/contests/abc324/tasks/abc324_d) / 整数問題（いい数の個数）、平方数、組み合わせ

- **`NextPemutation()`で全順列を試すと$13!$かかり間に合わない。** **逆側の**、あり得る平方数を試すことを考える。
- $(10^6)^2 = 10^{12} （13桁）$であるため、10^6 程度までの数が平方根としてあり得るので、平方数の列挙は間に合う。
  - 実際は、S を最も大きくなる様にソートした数の平方根の平方数までを列挙すればいい。
- ある平方数が S から作成可能かを高速に判定する必要がある。**各桁の数のスライスを降順（または昇順）にソートして一致すれば、作成できるということ。**
  - ただし今回は`010`で`10`を表現することも可能なので、平方数の桁数が S の桁数に満たない場合は、同じになるように`0`をアペンドする。
  - $O(10^6 * 13 * 13 \log 13)$ （ソートが$N * log N$。N は最大の桁数 13。）

---

- **M4 Mac の CPU の処理速度はジャッジサーバーの二倍程度だということに注意。**
- **制限時間 4 sec のギリギリをせめる問題は、ローカルで余裕でも注意する。** また、そういう問題はサンプルで上限付近の入力を示してくれていることも多い。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc324/d/main.go
:::

# 323

## [B - Round-Robin Tournament](https://atcoder.jp/contests/abc323/tasks/abc323_b)

- グリッドで勝利数を読み込む。`{勝利数、インデックス}`という**構造体のスライスを作成し、二つの値を使ってソートする。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/b/main.go
:::

## [C - World Tour Finals](https://atcoder.jp/contests/abc323/tasks/abc323_c) / Ordered Multi Set、貪欲法

- 各人の点数、解いていない問題の点数セットを記録しておく。各人でループし、自身を除いた点数の最多を超えるためには、解いていない問題を何問解く必要があるかを求める。（得点の高い順に**貪欲**に解く。）
- 各人の得点の集合、各人の解いていない問題の点数の集合について、**挿入、削除、最多の取得を高速に行う必要**があるので、**Ordered Multi Set**が適していることが分かる。

---

- gostl の`MultiSet`は、`Erase(val)`で val と同じ値全てが消えてしまうため、独自のライブラリを使う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/c/main.go
:::

## [D - Merge Slimes](https://atcoder.jp/contests/abc323/tasks/abc323_d) / 優先度付きキュー（ヒープ）

- スライムは可能な限り同じサイズ同士で合成するのが最善。最終的に同じサイズのスライムが二個以上存在するのはあり得ないため。また、最終的に X 種類のスライムが１体ずつ存在する状態になる。
- サイズの小さなスライムから合成していき、二倍のサイズのスライムがすでにいればその個数に加算、なければ新規に記録。これを繰り返したい。

  - **小さな値から処理する**ということで、サイズの**優先度付きキュー（ヒープ）** が使える。
  - **Ordered Set**も思い浮かぶが、**こちらは取得と削除の両方で`O(log N)`かかるので不利。** 一度処理したサイズはもう処理しなくていいので。

- 実装
  - サイズをヒープに追加し、サイズごとの個数をマップで管理する。
  - ヒープが空になるまでサイズを取り出し、個数を 2 で割った数を二倍のサイズのマップのバリューに加算。
  - 2 で割った余りが 1 ならそのサイズのスライムは最後まで残るので、`ans++`
  - マップにキーが存在していなかった場合のみ二倍のサイズをヒープに追加。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc323/d/main.go
:::

# 322

## [C - Festival](https://atcoder.jp/contests/abc322/tasks/abc322_c) / 二分探索

- 現在の日付以降の直近の花火の日付を**二分探索**。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc322/c/main.go
:::

## [D - Polyomino](https://atcoder.jp/contests/abc322/tasks/abc322_d) / ポリオミノ、DFS（全探索）

- 「ポリオミノをどの順番で配置するか」x「ポリオミノを何回 90 度回転させるか」のパターンを**全探索**する。
  - $O(3! * 4^3)$
  - **複雑な全探索なので、再帰、DFS で書く。**
- **各ポリオミノの座標を、0~3 回 90 度回転させたものを予め用意しておく。**
  - `var partsMap [3][4][]Coodinate // partsNo => rotateNum => cordinates sorted by most left up`
  - **座標は、最も左上に近い順でソートしておく。**
  - **座標は`[2]int`ではなく`Coodinate`型にする。多重配列の可読性をマシにするため。**
- 実装
  - **パーツの順番を`NextPermutation()`でループ、再帰関数の中で回転を列挙して再帰。**
  - 関数の引数に現在の最も左上の空きマスを渡す。空きマスからポリオミノを配置しようとする。
  - 元々のパーツの座標は、最も左上の空きマスとのデルタを加算して使う。
  - 更に再帰する直前に、最も左上の空きマスを更新する。**空きマス発見後に loop break を忘れない。**
  - 再帰関数の戻り値は、パズルが全て解けたかどうかの bool。**再帰呼び出しの際は、戻り値が true だったら true を返し、false なら別の再帰をするために次のループにイテレート。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc322/d/main.go
:::

## [E - Product Development](https://atcoder.jp/contests/abc322/tasks/abc322_e) / DP（メモ化再帰）

- 「何個目のプロジェクトまで見たか」「各パラメータの値」を状態とする**DP**をする。
- P 以上のパラメータを P に丸めれば、状態数は $N*(P+1)^K$ となり、制約より現実的な数字に収まる。
  - パタラメータが目標値以上になっても意味がないので、状態を区別する必要がない。
- Go では`dp[int][[]int]`のようなテーブルが作れないので、メモ化再帰でやる。
  - `var func dp(idx int, currentParams []int, currentCost int) // idx: 何"個"目の project までを見たか。`
- **メモ化再帰　 memo**
  - メモの参照と更新は、関数の一番最初でやる。
  - 次に index が上限を超えていないかをチェックする。
  - **メモのキーは可能な限り整数にする。itoa 変換は定数倍が相当遅い。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc000/e/main.go
:::

# 321

## [A - 321-like Checker](https://atcoder.jp/contests/abc321/tasks/abc321_a)

- string で読み込んで桁に分割して比較。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/a/main.go
:::

## [B - Cutoff](https://atcoder.jp/contests/abc321/tasks/abc321_b)

- ソートして最大と最小を記録、それ以外の合計を記録。足りない点が最小以下か、最大以上かで分岐。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/b/main.go
:::

## [C - 321-like Searcher](https://atcoder.jp/contests/abc321/tasks/abc321_c) / 整数問題（K 番目のいい数）、DFS（全列挙）

- **質問タブの「321-like Number は有限個であることが示せます。」に注目。**
- よく考えると、最大のいい数は`9876543210`であることが自明。いい数の総数も少なそう。何か**全列挙**する方法はないか？
- 自身より少ない数が存在すれば、それを後ろにくっつけるということを**DFS**で再帰的に繰り返せば全列挙できる。
- **0 は正の整数ではないことに注意。（正負どちらでも無い。）**
- やってみると分かるが**桁 DP**+**二分探索**で解くのは相当困難。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/c/main.go
:::

## [D - Set Menu](https://atcoder.jp/contests/abc321/tasks/abc321_d)　/ 二分探索 + 累積和

- As と Bs をソートすれば、`As[i]`に対して`As[i] + Bs[j] >= P`となる B の数を数えられる。
- 更にソート済み Bs に対して**累積和**を作っておけば、P を超えない組み合わせで使う B の総和が高速に求められる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc321/d/main.go
:::

# 320

## [B - Longest Palindrome](https://atcoder.jp/contests/abc320/tasks/abc320_b) / 回文

- `len(S)`文字の部分列チェック、`len(S)-1`文字の部分列チェック、...とすればいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/b/main.go
:::

## [C - Slot Strategy 2 (Easy)](https://atcoder.jp/contests/abc320/tasks/abc320_c) / 全探索

- **最悪のケースは、** S1,S2,S3 の最後の一文字を使わないと揃わないケース。その場合、M-1 秒、2M-1 秒、3M-1 秒にボタンを押す必要がある。よって、0~3M-1 秒の間のいずれかの 3 点でボタンを押すパターンを**全探索**すればいい。
  - ボタンを押すパターン：$300^3$
  - `i < j < k`となるように三重ループして、どのインデックスがどのリールに対応するかの 6 通りを試してもいい。（この 6 通りの検証は簡単なので、計算量には影響出ない。）
  - あるいは、`i, j, k`いずれも 0~3M-1 秒の範囲でイテレートし、一つでも被っていたら continue する。各インデックスはリール 1、2、3 に固定で対応させる。という方法でもいい。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/c/main.go
:::

## [D - Relative Position](https://atcoder.jp/contests/abc320/tasks/abc320_d) / キュー

- 人 1 の座標から、関連する人達の座標を求める。さらに座標が判明した人達の情報から、関連する人達の座標を求める。ということを繰り返したい。**キューに座標の判明している人の番号を突っ込んでいけばできそう。**
- 座標の関係性を**隣接リスト**に格納しておく。**その際に、`A => B, +X, +Y`という情報があったら、逆の`B => A, -X, -Y`という情報も記録する。**
- キューから座標の判明している人の番号を取り出し、隣接リストから関連する人の情報を取り出す。それらの人の座標がすでにわかっているなら continue。そうでないならその人の座標を確定し、その人の番号をキューに積む。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/d/main.go
:::

## [E - Somen Nagashi](https://atcoder.jp/contests/abc320/tasks/abc320_e)　/ 優先度付きキュー、Ordered Set

- 列に並んでいる人を**Ordered Set**に入れる。（最も番号の小さい人を取り出せるように。）
- 列から抜けている人を、復帰時刻による**優先度付きキュー**に入れる。`qItem{no, returnTime int}`
- クエリの処理の前に、キューから復帰時刻が現在時刻を過ぎている要素を取り出して、セットに番号を追加する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc320/e/main.go
:::

# 319

## [B - Measure](https://atcoder.jp/contests/abc319/tasks/abc319_b)

- 愚直に各インデックスに対して 1~9 が約数かを判定する。全探索。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/b/main.go
:::

## [C - False Hope](https://atcoder.jp/contests/abc319/tasks/abc319_c) / ビンゴ、全探索

- マス目が判明する順番は $9! = 362880$ 通りなので**全探索**可能。
- マス目に 1~9 の番号をつけ、番号とグリッドの座標のマップを作成する。
- 判明順を`NextPermutation()`で全探索する。判明していく座標を行スライス、列スライス、クロススライスで管理し、”がっかり”したらそれをカウントする。最後までしなかったらそれをカウントする。最後に割合から確率を出す。
- **グリッドのマス目の座標がクロスの位置にあるかどうかの判定方法は、以下の類題を参照。**
- 類題：[355 C - Bingo 2](https://zenn.dev/shinonome81/articles/b1de75b0849b32#c---bingo-2-%2F-%E3%83%93%E3%83%B3%E3%82%B4)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/c/main.go
:::

## [D - Minimum Width](https://atcoder.jp/contests/abc319/tasks/abc319_d) / 二分探索（応用）、貪欲法

- ウィンドウ幅が大きくなるほど、必要な行数が減る（**単調性**）。M 行に収まるようなウィンドウ幅を**二分探索**できる。
  - min は、最も長い単語のサイズ。max は、単語のサイズの総和+`(N-1)*1`のスペース。
  - **$\log (max-min)$ が二分探索の計算コスト**
- ウィンドウ幅に対する必要行数はどのように判定できる？前から**貪欲に**単語サイズ+スペースを足していき、ウィンドウ幅を超えたら改行する。$O(N)$
- $O(log (10^9*N) * N) = O(47 * 2*10^5)$ なので現実的。
- **`AscIntSearch()`と`DescIntSearch()`はどちらを使うかよく考える。（答えが見つからない場合を除き）戻り値がそのまま求める値にならないケースは、何かがおかしい。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc319/d/main.go
:::

# 318

## [B - Overlapping sheets](https://atcoder.jp/contests/abc318/tasks/abc318_b) / 座標平面（面積）

- 一つづつ面積を出し加算し、他との重なりを判定してその部分をどうこうする方法は難しすぎる。
- 範囲が`(0~100, 0~100)`に限定されていることから`100*100` のグリッドだと考え、長方形の範囲を塗りつぶし、最後に塗りつぶしをカウントする方法でやる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/b/main.go
:::

## [C - Blue Spring](https://atcoder.jp/contests/abc318/tasks/abc318_c) / 貪欲法、累積和

- 運賃 Fs をソートし後ろから D 日づつ見ていき、その和が P 円より高ければ周遊パスを**貪欲に**セット購入していく。ある区間の和を高速に求めたいので、**累積和**を作成しておく。
- D 日未満しか残っていなくても周遊パスをセット購入した方が得な場合があるので、その条件分岐が必要なことに注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/c/main.go
:::

## [D - General Weighted Max Matching](https://atcoder.jp/contests/abc318/tasks/abc318_d) / グループ分け、DFS

- **無向辺グラフの辺の重みを記録するときは、`from => to, to => from`の両方にとりあえず必ず入れる。**
- **偶数である N 個の要素を 2 個づつの区別のない N/2 グループに分割するパターン数は、N-1 の二重階乗通りである。**
  - $(N-1)!! = (N-1) * (N-3) * (N-5) * ... * 1$
  - 先頭の要素について、ペアリング先が残りの N-1 通り。残った N-2 個の要素についても、先頭の要素について、ペアリング先が N-3 通り。...。となるため。
  - **先頭から後ろの要素をペアリング先に選ぶことで、重複数え上げ（グループの区別）を排除できている。**
- **奇数である N 個の要素を 2 個づつの区別のない N/2 グループに分割するパターン数は、N の二重階乗通りである。**
  - $N!! = N * (N-2)!!$
  - `どの要素を使わないのか * N-1個の偶数個をグループ分けする場合の数`になるため。
- 上記より $O(15!!) = O(2,027,025)$ であるため**全探索**が可能。複雑な全探索なので**DFS**で書く。
- 先頭から後ろの要素をペアリングさせる。使用済み要素をマップで管理し、ペアリング元、先が使用済みなら continue する。**詳細は実装参照。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/d/main.go
:::

## [E - Sandwiches](https://atcoder.jp/contests/abc318/tasks/abc318_e) / 3 つ組、連続部分列

- **条件を満たす 3 つ組を考えるときは、真ん中に着目する。**
- 各数字の index をとり、$idx_i$ と $idx_{i+1}$ の間にいくつ数が存在するかを取る。
- 各数字でいくつサンドイッチを作れるかは、「間にいくつ数が存在するか」を数列にした時の、全ての**連続部分列の総和の総和**になる。
  - 左端と右端を選んだ場合、真ん中はその連続部分列の和の分だけ選べる。それを全ての左端と右端の組み合わせ（=全ての連続部分列）について行える。
  - :::details image
    ![image](/images/ABC/318/318_e.png)
    :::
- **連続部分列の総和の総和は、$\sum_{i=1}^{N} A_i * i * (N-i+1)$ で $O(N)$ で取れる。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc318/e/main.go
:::

# 317

## [C - Remembering the Days](https://atcoder.jp/contests/abc317/tasks/abc317_c) / DFS（グラフ）

- 今回の計算量：$O(N! * N) = O(完全グラフの全経路数 * 探索一回ごとの訪問済みノードの判定)$
- 今回の全経路数は $10! = 3628800$。この回数訪問済みノードの読み取り、更新を行うわけだが、マップだと処理全体が 1000ms、スライスだと 200ms だった。**マップの読み取り、更新は $O(1)$ だが、スライスと比べて処理の定数時間が 4, 5 倍程度遅い。**

### DFS memo

- $N(N-1)/2 = \binom{N}{2}$ であり、グラフが完全グラフである場合の辺数。
- 「DFS の計算量は $O(V + E)$ （V: vertexes, E: edges）」と言われるが、これは**始点を固定した**、**バックトラックなしの**、DFS の計算量である。
  - バックトラックとは跡を引き返すということで、再帰呼び出しの直後に訪問済みノードを解除し、別の経路で訪問できるようにすることである。
  - バックトラックなしの DFS は連結成分内の全てのノードに訪問することを目的とし、このような解除は行わない。
  - バックトラックありの DFS の計算量は問題設定による。今回のような全経路を探索する場合は $N!$ となる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/c/main.go
:::

## [D - President](https://atcoder.jp/contests/abc317/tasks/abc317_d) / ナップサック問題、DP（テーブル）

- 限られたコストで価値を最大化したり、ある価値に到達するための最小コストを求める問題を **ナップサック問題**といい、**DP（テーブル）** で解く。
- 各選挙区について、P 人鞍替えさせると（コスト）、Q 票獲得出来る（価値）。過半数票を獲得するための最小コストは？
  - 負けている選挙区は、`(X-Y+1)/2`のコストで勝てる。
  - 勝っている選挙区は、コストゼロでその票数を取れると考えると楽。（選挙区リストから取り除き、勝敗ラインを過半数から調整する必要がなくなる。）
- DP テーブル `var dp [][]int` の設計
  - 行: 何個目の選挙区まで処理したか。**大抵の DP で同様。**
  - 列: 各得票数。
  - セル: その状況における最小コスト。
  - **セルに求めたい答えと同様の値を入れる。求めたい答えの状況を列で表現する。**
    - 今回は最小コスト、特に過半数以上の票を獲得している状況のそれを求めたい。
  - ゼロ個目の選挙区まで処理した場合、ゼロ票の場合も格納したいので、行・列の長さは 1 を足しておく。
  - 各セルは初期値で埋めておく。**今回は最小を求めたい（=min をとる処理があるはず）ので、十分に大きな数 INF で埋める。** （最大を求める問題なら逆。）
    - **INT_MAX や INT_MIN だとオーバーフローの危険がある。**
  - $O(N * (10^5/2+1))$ （セルの数）
- テーブルを埋めるループは一つ前の行（選挙区）の全列（票数）から、次の行の遷移先（あり得る票数）の列に値を埋めていく。
  - 遷移先はすでに別の遷移で埋まっている可能性があるので、そのセルの値と今埋めようとしている値の min を採用する。
  - 値の入っていない（INF である）セルも処理してしまうが、**min をとっている関係で上手くいく。** そこからどこへ遷移しようと、遷移先は元から入っている有効な値か、INF のままになる。
- 過半数以上取る様な遷移をしようとして、DP テーブルの範囲外アクセスになってしまう可能性がある。**過半数票の列 (最後列)だけそれ以上以上の票を獲得している状態と定義しても問題の設定上問題ない。DP でよくあるテクニック。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/d/main.go
:::

## [E - Avoid Eye Contact](https://atcoder.jp/contests/abc317/tasks/abc317_e) / BFS

- 侵入できない領域を事前に塗りつぶす。各マスは上下左右 4 方向の 4 人からしか見られないので、塗りつぶしは $O(4*H*W)$ となり間に合う。その後 BFS。
  - 塗りつぶしは`#`ではなく`!`でする。視線を遮る壁と区別しないと塗りつぶしに支障が出るため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc317/e/main.go
:::

# 315

## [B - The Middle Day](https://atcoder.jp/contests/abc315/tasks/abc315_b)

- 目標の日数から各月の日数を順に引いていく。マイナスになったら「その月」の「終わりからマイナス分を引いた日付」が答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/b/main.go
:::

## [C - Flavors](https://atcoder.jp/contests/abc315/tasks/abc315_c)

- 異なる味同士の美味しさの和の最大は、各味の中の最大の美味しさを昇順に並べた後ろ二つの和。
- 同じ味同士の美味しさの和の最大は、各味の中の美味しさを昇順に並べた後ろ二つの和。
- 上記を求めて maxAns を更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/c/main.go
:::

## [D - Magical Cookies](https://atcoder.jp/contests/abc315/tasks/abc315_d) / グリッド（応用）

- 行、列ごとに`map[color][]col(row)_indexes`を作成し、削除できる行、列があった場合は、インデックスをもとに逆側のマップから削除する、というやり方が思いつく。これだと各マスの h, w 座標がそれぞれ一箇所に入りそれらが最大一回ずつ削除されるので $O(2*2000^2)$ になる。**しかし 400 万回以上ものマップの操作は 2 sec では TLE になるので、マップを使わないやり方を考える。**
- **色の種類がアルファベットの種類 26 個しかないことに着目する。** 行、列ごとの色の数を `make([]int, 0, 26)` のスライスで保持することを考える。行、列の削除できるかどうかの判定は $O(26)$ で可能。
- 行の削除の影響を列の色分布に反映する方法を考える。ある回である行が削除されたら、`i:=0~W-1`の列インデックスでループを回す。`color := grid[rowIdx][i]`でその列から削除された色がわかるので、その色を列の色分布からマイナスすればいい。
  - $O(26(H + W) * (H + W))$ // (最初の行、列が削除できるかのチェック) \* (削除された行、列に対する列、行の処理)
- 最後にマス目でループし、その行も列も削除されていないものを数えれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/d/main.go
:::

## [E - Prerequisites](https://atcoder.jp/contests/abc315/tasks/abc315_e) / トポロジカルソート

- タスクの依存関係は有向グラフとして表現でき、サイクルがないことが制約で保証されている。**有向非巡回グラフ**のことを**DAG**といい、DAG は**トポロジカルソート**が可能。
- トポロジカルソートとは、頂点の配列であって、全ての有向辺`u->v`について配列内で`v`が`u`の前に来るものを作成するということである。
  - DFS で連結成分を探索し、呼び出しもとに帰る前に引数の頂点を ans スライスに追加することで実装可能。
- トポロジカルソートした頂点配列（から頂点ゼロを削除したもの）の順に本を読むと、依存関係をクリアしている。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc315/e/main.go
:::

# 314

## [B - Roulette](https://atcoder.jp/contests/abc314/tasks/abc314_b)

- 制約より**全探索**できそう。各人のベット先を Map（as Set）で保持。X にベットしていた人を、ベット種類数と一緒にスライスに突っ込んでいく。最後に種類数と人の番号でソートして、minCount を超えるまで出力すれば答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/b/main.go
:::

## [C - Rotate Colored Subsequence](https://atcoder.jp/contests/abc314/tasks/abc314_c)

- M（クエリ回数）が最大 20 万なので、スワップ操作を高速にやる方法を考える。色ごとのインデックスのスライスを作りソートする。色ごとに一旦`var toUpdate []struct{idx int, char string}`を作って、それを元に更新する。（末尾のインデックスの文字が先頭のインデックスに移ることにだけ注意。）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/c/main.go
:::

## [D - LOWER](https://atcoder.jp/contests/abc314/tasks/abc314_d)

- 最終的には、文字は最後の変換が大文字なら大文字、小文字なら小文字になる。ただし最後の変換の後に変更された文字は別。よって最後の変換がどちらか、それ以降に変更されたインデックスはどこかをスライスで保持する。

- あとは文字の変更操作だけを順にやり、その後除外インデックス以外を順に大文字変換または小文字変換すればいいだけ。

- **`if`ブロックとは違い、ループ内の`switch`ブロック内で break してもその switch を抜けるだけであることに注意。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc314/d/main.go
:::

# 313

## [A - To Be Saikyo](https://atcoder.jp/contests/abc313/tasks/abc313_a)

- 愚直。As が一人だけなら、その人は最強であることに注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/a/main.go
:::

## [B - Who is Saikyo?](https://atcoder.jp/contests/abc313/tasks/abc313_b) / DFS、有向グラフ

- 強い人から弱い人に辺が伸びる**有向グラフ**として表現可能。

- あとは各人から始まる`DFS`を行い、何人の弱い人を訪問できたかをカウントすればいい。関数は node を受け取り、そこから訪問できた node 数を返す。

- 一度の DFS で同じ人に二度訪問しないために、`visited`を管理する。経路はどうでもよく**連結成分**を全て訪問できればいいため、呼び出しもとに帰る前に自身の訪問済みを解除するバックトラックはやらない。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/b/main.go
:::

## [C - Approximate Equalization 2](https://atcoder.jp/contests/abc313/tasks/abc313_c)

- 「数列の最大値と最小値の差が１以下」の場合、数列の要素は 1 種類か 2 種類しかないことになる。`sum%N == 0`なら`sum/N`、そうでないなら`sum/N, sum/N+1`になる。（**問題の言い換え**）

- 後者の場合、`sum/N`は`N-(sum%N)`個、sum/N+1 は`sum%N`個あることになる。（前者でも結局は同じ式になる。）

- As をソートして、`sum/N`の個数に達していなければ、`sum/N`との diff、達していれば`sum/N+1`との diff をとる。

  - 小さい数字を小さい値に変更させる方が効率がいいことは自明。
  - diff は正負どちらにでもなり得ることに注意。
  - diff の正負に応じて positiveCost, negativeCost に加算し、最後にそれらが一致していることを一応アサートし、一方の値を出力すれば答え。

- 「As をソートして Deque に突っ込み最小と最大を取って平均にならすことを繰り返す」等が思いつきサンプルも通るが、**やり方に正当性が無いのでこういう当てずっぽうをしない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/c/main.go
:::

## [D - Odd or Even](https://atcoder.jp/contests/abc313/tasks/abc313_d) / インタラクティブ問題、合同式、XOR

- **数字の和が偶数なら 0、奇数なら 1 ということは、数字の和を mod 2 しているということになる。**

- 0, 1 しか数字が存在しないので、**XOR** を取っていけば同じことができる。

```go
a := 0
b := 1

// 0 + 1 ≡ 1 mod 2
ans1 := (a+b)%2 // 1
ans2 := a^b     // 1
```

- **部分問題から考える。** N=4, K=3 の時。
  - K+1 までの数字について、1 つを抜かした K 個のクエリを投げるとする。
  - K 個のクエリの答えの和の mod 2 を取ることで、1~K+1 の数字の和の mod 2 が分かる。
  - 上記をもとに 1~K+1 文字目の 0, 1 が判明する。（**連立方程式**の様に考えられる。）
  - N がもっと多かったとしても同じ要領で、「確定している K-1 個の数字の番号」＋「判明していない数字の番号」でクエリを投げていき、残りの番号の数字も求めていけばいい。

```
  a b c d
  1 0 0 1
  -------
  o o o x ≡ 1 mod 2 // ①
  o o x o ≡ 0 mod 2 // ②
  o x o o ≡ 0 mod 2 // ③
+ x o o o ≡ 1 mod 2 // ④
--------------------
3a + 3b + 3c + 3d ≡ 0 mod 2
    a + b + c + d ≡ 0 mod 2 // ⑤

⑤に例えば④を足すと、以下が求められaの値がわかる。
 a + 2b + 2c + 2d ≡ 1 mod 2
                a ≡ 1 mod 2
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc313/d/main.go
:::

# 312

## [B - TaK Code](https://atcoder.jp/contests/abc312/tasks/abc312_b)

- グリッドサイズが小さいので左上を固定した全探索。$O(100^2 * 9^9)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/b/main.go
:::

## [C - Invisible Hand](https://atcoder.jp/contests/abc312/tasks/abc312_c) / 二分探索

- 昇順ソートした売り手の価格を順に見て、価格をもとに昇順ソートの買い手の希望価格で何人買うか見つける。売り手の人数 >= 買い手の人数なら現在の価格が答え。としたくなるが、これでは以下のケースに対応できていない。

```
2 3
10 10
11 11 22
=> expexted: 12. 売り手：2人、買い手：1人になる。
```

- **単純な二分探索（`AscIntSearch()`, `DescIntSearch()`）ができないかをまず考える。**

- 最小の価格を求めたい。価格を**増やして行った時に単調に変化するものは何かあるか？**

  - => 価格が上がるほど売り手の人数が増え、買い手の人数が減る。**二分探索**可能。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/c/main.go
:::

## [D - Count Bracket Sequences](https://atcoder.jp/contests/abc312/tasks/abc312_d) / DP（メモ化再帰）

- 考慮するパターンを相当減らす必要があるので**DP**が濃厚。

- ”括弧列”を**言い換える**と「文字列内の括弧は全て閉じていなければならない」ということ。つまり、`(`が一つ出現すると後で`)`をいつか必ず付けなければならない。

- 上記をもとに、「何文字目まで処理済みか」「あと何個`)`を付けなくてはならないか」という状態と、その時のパターン数を考える**メモ化再帰**で解ける。

- 「あと何個`)`を付けなくてはならないか」が残りの文字数を超えてしまう場合は場合は**枝刈り**する。

- 必要以上に（前に十分な数の`(`が無いのに）`)`を付けてしまうケースもハンドリングする。

- 類題：[359 D - Avoid K Palindrome](https://zenn.dev/shinonome81/articles/b1de75b0849b32#d---avoid-k-palindrome-%2F-dp%EF%BC%88%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%EF%BC%89%E3%80%81dfs%E3%80%81%E5%9B%9E%E6%96%87)

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc312/d/main.go
:::

# 311

## [B - Vacation Together](https://atcoder.jp/contests/abc311/tasks/abc311_b) / 論理積

- 予定文字列をビットに変換して**論理積**（両方 true の時だけ true）を取れば良さそうに見えるが、文字列が 100 桁まであり、整数が 64 ビットまでしか扱えないことから、**オーバーフローする。**

- 文字列は文字列スライスにして、if 文で自分で論理積を撮って更新する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/b/main.go
:::

## [C - Find it!](https://atcoder.jp/contests/abc311/tasks/abc311_c) / Functional Graph、DFS（グラフ）

- 各ノードが一つだけ辺を持つ有向グラフのことを、**Functional Graph**という。`f(node) = next_node`の関数の様な構造をしているため。

  - Functional Graph は、一つの連結成分内に必ず一つの**閉路**を持つ。（全てのノードは必ず別のノードに行けるので、連結成分を探索すればいつか必ず同じノードを通る。）
  - 一つの閉路と、そこから木が伸びたような構造をしている。
  - `var graph []int // node => next_node`の構造に格納できる。

- 上記の法則を知っていれば、順番に適当なノードから探索を始め訪問したノードをスライスに格納し、同じノードを通ったら探索を終了すればいい。

---

- 通常の**DFS**でも解ける。ただしノードの数が 20 万と多いため、$O(N)$ でも定数倍が重いと TLE する。
  - 訪問ノードを順番に記録する際に、1 つのスライスを使い回す。**再帰呼び出しが帰ってきた時に末尾に追加したものを削除する。** **再帰呼び出しごとにスライスを複製する方法は遅すぎる。**
  - 文字列で訪問ノードの順番を記録する方法も考えたが、**文字列結合も実はかなり遅い。** 文字列は immutable なため、毎回新しいメモリを用意してコピーするため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/c/main.go
:::

## [D - Grid Ice Floor](https://atcoder.jp/contests/abc311/tasks/abc311_d) / DFS（グリッド）

- **連結成分の個数を求めたい**ので、**DFS**。

- 通常すでに訪れたマスは再訪する必要はないが、滑って通過したマスは、そのマスで停止できるなら再訪の価値あり。

  - よって、visited を`0, 1, 2 // NEVER, PASSED, STOPPED `で記録する。優先度の高いものの数字を大きくすると更新処理で便利。（STOPPED を PASSED で上書きしない様に注意。）

- 関数で現在の座標、どの方向の移動で訪れたのかを引数で受け取る。PASSED を記録しながら別の方向への移動を試し、別の座標に止まったら、そこが STOPPED 済みでなければ再帰呼び出し。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc311/d/main.go
:::

# 310

## [B - Strictly Superior](https://atcoder.jp/contests/abc310/tasks/abc310_b)

- まずは**愚直に全探索**する方法を考える。$O(商品二つの全組み合わせの比較 * 全機能の比較) = O(\binom{100}{2} * 100)$

- データ列 A がデータ列 B に内包されているかどうかは、両者を map にして mapA の key が全て mapB に存在するか試せばいい。さらに mapB の方が長ければ、"完全上位互換"。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc310/b/main.go
:::

## [C - Reversible](https://atcoder.jp/contests/abc310/tasks/abc310_c)

- `map[string]struct`に、文字列と、文字列を反転させたもののうち辞書順の早い方を格納する。同一と見做されるの文字列の種類数は、map の長さ。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc310/c/main.go
:::

## [D - Peaceful Teams](https://atcoder.jp/contests/abc310/tasks/abc310_d) / グループ分け、DFS

- n 人を丁度 k 個の区別のないグループに分ける場合の数 = **スターリング数**。制約より、最大の数は $S(10, 5) = 42525$

- 現在の人をグループに追加するたびに、グループに NG メンバーが含まれていないかを確認する必要がある。計算量の見積りは難しいが、提出してみて時間にかなり余裕があるので良しとする。

- グループ分けは**DFS**で行い、最後の人まで処理した時にグループ数が T でなければ ans に加算しない。グループ数が T に達しているときは新規グループの作成はやらない。

- **DFS で既存グループに追加する際は index でループする。** range 文を使ってループ変数`g`にアペンドすると`groupos[i]`に反映されない。
  - `g`は`groups[i]`と同じ既定配列を参照するが、そちらにアペンドしても`groups[i]`の length が更新されず、そちらからは追加の要素が見えない。

```go
// OK
for i := 0; i < len(groups); i++ {
  groups[i] = append(groups[i], idx)
  dfs(idx + 1)
  groups[i] = groups[i][:len(groups[i])-1]
}

// NG
for _, g := range groups; i++ {
  g = append(g, idx)
  dfs(idx + 1)
  g = g[:len(g)-1]
}
```

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc310/d/main.go
:::

# 309

## [B - Rotate](https://atcoder.jp/contests/abc309/tasks/abc309_b)

- 愚直。**グリッドのループの際は、イテレーターを i, j ではなく h, w でやると混乱しない。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc309/b/main.go
:::

## [C - Medicine](https://atcoder.jp/contests/abc309/tasks/abc309_c) / 二分探索

- 日にちが経つほど、毎日の薬の数は減る。**単調性**を満たすので日付で**二分探索**。

- $O(\log 10^9 * 3 * 10^5) = O(30 * 3 *10^5)$ なので、二分探索で値を検証するたびに N 個の入力データをさらってその日付の薬の合計数を調べることが十分現実的。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc309/c/main.go
:::

## [D - Add One Edge](https://atcoder.jp/contests/abc309/tasks/abc309_d) / BFS

- 連結成分 1 から頂点 1 と最も遠いノード、連結成分 2 から頂点 N1+N2 と最も遠いノードを選んで繋ぎ、`dist1 + dist2 + 1`をすれば答え。
- 連結成分内の各ノードの始点ノードとの（最短）距離を求めるのは、**BFS**で可能。
- 頂点 1 と頂点 N1+N2 から開始する BFS は、それらを最初に同時にキューに載せてしまっても構わない。互いに非連結なので、`visited`を通じて互いに影響を与えてしまうことはない。（**多始点 BFS**）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc309/d/main.go
:::

## [E - Family and Insurance](https://atcoder.jp/contests/abc309/tasks/abc309_e) / DP（ボトムアップ）

- `人i`の親は`人0~i-1`のいずれかであることに着目する。**制約をちゃんと読む。**
- 人を左から順に見て、`max(自身の契約, 自身の親の契約-1)`を自身以下の世代のどこまで保証されているかの値として確定できる。
  - 自身の親も、その親やさらにその親の値を見て最大化された値を持っているため。
- `dp[i]`に自身を第一世代とし、何世代目まで保証しているかの値を格納していく。最初は入力を入れ、その後上記で更新する。最後に`dp[i] > 0`をカウントする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc000/e/main.go
:::

# 308

## [C - Standings](https://atcoder.jp/contests/abc308/tasks/abc308_c) / 小数

- 成功率は小数。**「少数は必ず整数にして扱うべき」** くらいで考えた方がいいかも。float64 で扱うと WA。
- $A_i / (A_i + B_i)$ と $A_j / (A_j + B_j)$ の大小を比較するために通分する。
- ソート関数のコールバックの中で$A_i * (A_j + B_j)$ と $A_j * (A_i + B_i)$ の形にして比較する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc308/c/main.go
:::

## [D - Snuke Maze](https://atcoder.jp/contests/abc308/tasks/abc308_d) / BFS or DFS

- BFS または DFS すれば解ける。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc308/d/main.go
:::

## [E - MEX](https://atcoder.jp/contests/abc308/tasks/abc308_e) / 累積和

- $A_i, A_j, A_k$ の組み合わせは 27 通りしかない。**真ん中を固定すれば**9 通り。
- `S[i] == E`の i について、9 通りのパターンについて、いくつ作れるのかを**累積和**で高速に求める。
  - `As[i]`が 0, 1, 2 であり`Ss[i]`が`M`であるものの個数の累積和を予め作成しておく。`psumM[][]int`。X も同様。
  - `0~2`の二重ループで左右の数字を決める。そのような M、X の数を求め、その数の掛け合わせがパターン数。
  - `ans += getMex(left, As[i], right) * mCnt * xCnt`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc308/e/main.go
:::

# 307

## [B - racecar](https://atcoder.jp/contests/abc307/tasks/abc307_b)

- `for i:=0; i<N; i++ { for j:=i+1; j<N; j++ }`でループして、`Ss[i]+Ss[j]`と`Ss[j]+Ss[i]`の両方のパターンの回文判定をする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc307/b/main.go
:::

## [C - Ideal Sheet](https://atcoder.jp/contests/abc307/tasks/abc307_c)

- シート X の範囲を**固定**し、そこにどうシート A、B を重ねるかという様に考える。
- シート A、B それぞれについて黒マス存在する範囲から `(minH, minW), (maxH, maxW)` を出し、この範囲がシート X に必ず重なっていないといけない。
- 実装 **（詳細はコード参照）**
  - gridA, gridB の`(minH, minW)`を gridX 内のどこに置くのかでループする。
  - gridX の座標を gridA、B の座標に変換するために、ずれのデルタを出す。
  - デルタをもとにそれぞれの`(maxH, maxW)`を grridX の座標に変換し、それが gridX の範囲外なら continue。
  - その後 gridX のセルでループし、セルの値が黒なら gridA, gridB どちらかが重なっていて`#`であることを確認。`.`ならどちらも重なっていないか、重なっていても`.`であることを確認。
- $O(Aの最小範囲の左上の位置 * Bの最小範囲の左上の位置 * 答えと一致しているか確認) = O(10^2 * 10^2 * 10^2)$
  - 実際に空のグリッドを用意して塗りつぶし、後で検証とすると効率が悪い。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc307/c/main.go
:::

## [D - Mismatched Parentheses](https://atcoder.jp/contests/abc307/tasks/abc307_d) / Ordered Set

- 一番後ろにある`"("`から、それ以降の最も近い`")"`までを削除する。これを繰り返せば最終結果まで行ける。
- `"("`の座標、`")"`の座標を管理し、`"("`を後ろからイテレート、相方の`")"`の座標を**二分探索**で見つけたい。
- ただし、一度使った`")"`は使えないことから、`")"`の座標の管理には二分探索（条件に当てはまる最小要素の特定のみ）と要素の消去が高速に行える**Ordered Set**を使う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc307/d/main.go
:::

# 306

## [B - Base 2](https://atcoder.jp/contests/abc306/tasks/abc306_b) / 多倍長整数

- 明らかに int64 で**オーバーフロー**するので、**多倍長整数**を使う。
- 最大の数は $1*2^63$ で 63 桁。雑に計算量を見積もってこの桁の数の足し算を N-1 回するとすると、$O(63 * (63-1))$ となり間に合う。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc306/b/main.go
:::

## [C - Centers](https://atcoder.jp/contests/abc306/tasks/abc306_c)

- 1~N の num の indexes のマップを作る。その後`struct {Num, MidIdx ind}`のスライスを作って MidIdx でソート、その後 A を順に出力。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc306/c/main.go
:::

## [D - Poisonous Full-Course](https://atcoder.jp/contests/abc306/tasks/abc306_d) / DP（テーブル）

- 典型的な**DP（テーブル）**。ある行は前の行の値からしか遷移しないタイプ。詳細は実装参照。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc306/d/main.go
:::

## [E - Best Performances](https://atcoder.jp/contests/abc306/tasks/abc306_e) / Ordered Multi Set

- topK の要素を保持、更新し、topK の合計を更新していけば良さそう。値によるアクセス、最大値の取得が必要で、値の重複も含むので**Ordered Multi Set**を使う。

- idx 指定で値の更新が行われるので、現在の値を保持する`idxValMap`も用意する。

- topK の要素が変更された時に、Y または残りの数の最大が topK に入る。なので rest も Ordered Multi Set で用意する。

- prevVal が rest に含まれるなら rest から(1)、そうでないなら topK から削除。(2)（両方に存在するときは rest から削除して良い。）

  - (1) Y が`topK.Worst`より大きいなら`topK.Insert(Y); topK.Erace(Worst)`。そうでないなら`rest.Insert(Y)`
  - (2) Y が`rest.Best`より大きいなら`topK.Insert(Y)`。そうでないなら`topK.Insert(Best); rest.Erace(Best); rest.Insert(Y)`

- **set の Iterator を取得した後に set の要素が削除された場合、Iterator が nil になっている場合があるので注意。**

  - 無効になっていない場合、`It.Prev(), It.Next()`は更新後のセットの状態を元に正常に動作する。（挿入後の場合も。）

- gostl ベースの Go の MultiSet の実装では、**Iterator を動かすと（重複を含んだ）次の値ではなく、次の種類の値に移動する**ことに注意。
  - **c++の multiset の Iterator と同様の挙動を必要としない実装方針を考える。**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc306/e/main.go
:::

# 305

## [B - ABCDEFG](https://atcoder.jp/contests/abc305/tasks/abc305_b)

- 累積和

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc305/b/main.go
:::

## [C - Snuke the Cookie Picker](https://atcoder.jp/contests/abc305/tasks/abc305_c)

- グリッドが小さいので**全探索**。
- 最も上、下、左、右にある`#`の座標を見つける。その範囲でループして、中に`.`があればそれが答え。
- 「左上の左」「左上の上」「右下の右」「右下の下」が欠けている場合もあるので、そこも確認。
  - **そのマスが存在するのかの範囲外チェック（c.IsValid(H, W)）も忘れない！**

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc305/c/main.go
:::

## [D - Sleep Log](https://atcoder.jp/contests/abc305/tasks/abc305_d) / 累積和、二分探索

- `countSleepTimeSum(time int) int`を実装して`f(r) - f(l)`すればいい。

- `[]Log{起床時刻、睡眠時間の累積和}`があれば、**二分探索**で指定の時刻`time`以上の起床時刻の`Log`を見つけ、`diff := 起床時刻-time; ans := 累積和-diff`してログの起床時刻が 時刻 `time` より超過している分の時間を**累積和**からマイナスすれば良さそう。
  - ただし、diff が`Log`以前の直近の睡眠時間以上の場合（=`time`が 一つ前の`Log` の起床時刻に対応する就寝時刻より前の場合）、diff ではなく直近の睡眠時間をマイナスする必要がある。よって、`Log{起床時刻、睡眠時間の累積和、直近の睡眠時間}`とする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc305/d/main.go
:::

## [E - Art Gallery on Graph](https://atcoder.jp/contests/abc305/tasks/abc305_e) / ダイクストラ法（もどき）

- `var guarded []int`に、頂点 Idx に警備員が残り体力いくつで訪問したかを記録し、**BFS**していく方法が思いつく。別の始点（別の警備員がいる頂点）からの BFS では、より大きな残り体力で到達済みのノードをスキップすればいい。

  - しかし BFS の計算量は $O(N*M)$ であり、上記の効率化をもってしても最悪計算量は $O(K*M*N)$ になり厳しい。（体力の多い警備員から順に BFS しても TLE した。）

- 実は**ダイクストラ法**と同様の手順で求められる。-1 で初期化した`var fixedGuarded []int`と、`{node, remainHealth}`を入れる**優先度付きキュー（ヒープ）** を用意し、ヒープの中にある最大体力のノードを取り出し確定、隣接ノードの`{node, remainHealth}`をキューに追加すればいい。
  - **ダイクストラが成り立つ理由**と同じ。最大体力を持つノードを確定させた後に、それより大きい最大体力でそのノードに到達することが起き得るとする。その場合、確定させたノードの体力より大きい体力を持つ別のノードから到達しているはずであり、体力の大きいノードから処理するという前提と矛盾するため。
  - **ダイクストラの計算量は $O((V + E)* \log V)$**
    - 各辺ごとに 1 つの頂点がヒープに追加される => $O(E \log V)$
    - 各頂点が 1 回以上（最大 E 回ではある）ヒープから取り出される（確定済みの場合はその後無視される） => $O(V * \log V)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc305/e/main.go
:::

# 304

## [A - First Player](https://atcoder.jp/contests/abc304/tasks/abc304_a)

- minA, minAIdx を見つけて、`ans := append(As[minAIdx:N], As[0:minAIdx])`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc304/a/main.go
:::

## [B - Subscribers](https://atcoder.jp/contests/abc304/tasks/abc304_b)

- 愚直。予め桁数がわかっていれば、下 N 桁の切り捨ては一旦文字に変換した上でこうできる：`str := str[:2] + "00" // 4221 => 4200`

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc304/b/main.go
:::

## [C - Virus](https://atcoder.jp/contests/abc304/tasks/abc304_c)

- N の小ささから、各座標間の距離を全探索可能。
- グラフを作る。距離の二乗が D の二乗以下の 2 点を隣接リストに記録していく。
- 最後に頂点 1 からの**DFS**で、visited(=infected)を記録していく。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc304/c/main.go
:::

## [D - A Piece of Cake](https://atcoder.jp/contests/abc304/tasks/abc304_d) / 二分探索

- $W,H≤10^9$の制約から、X、Y 座標ごとの処理は間に合わない。また、最大の苺を持つ X と Y の交差するマスが最大数の苺を含んでいる保証は全くない。**逆側の**、苺の座標（$N≤2×10^5$）から考える。

- 苺の X 座標、Y 座標から、それを超える A、B を**二分探索**すれば、何列目、何行目のマスかが分かる。（右側の X 座標、上側の Y 座標がマスを代表していると考える。）それを`map["A_B"]count`に記録し、最後に最も少ないカウント、大きいカウントを取ればいい。

- ただし、`len(m)`がマス数、(A+1)\*(B+1)より少ない場合苺ゼロのマスが存在するので注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc304/d/main.go
:::

## [E - Good Graph](https://atcoder.jp/contests/abc304/tasks/abc304_e) / Union Find

- グラフの連結成分を管理する必要があるので、グラフを**Union Find**として格納する。

- $x_i, y_i$ は連結してはならない => x と y のルートは連結してはならないと**言い換えられる**。

  - これらを`ngMap[int]map[int]struct`で管理する。
  - 常に若い番号の node が第一キーになる様に x と y を昇順スワップすると、メモリ効率がいい。

- クエリを処理するときに、（昇順スワップした）u と v のルートを求め、それが `ngMap` に存在する組み合わせかどうかで辺で連結させても良いかどうか判定する。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc304/e/main.go
:::

# 303

## [B - Discord](https://atcoder.jp/contests/abc303/tasks/abc303_b)

- 全ての組み合わせのパターン数を求める。その後不仲ではないことが確定している組み合わせをマップに格納する。（**マップのキーは昇順ソートした番号から生成する。**）前者から後者を引いたものが答え。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc303/b/main.go
:::

## [C - Dash](https://atcoder.jp/contests/abc303/tasks/abc303_c)

- アイテムの座標をマップに格納。現在の体力を記録更新しながら移動クエリを順に処理。アイテムを使う場合はマップから削除。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc303/c/main.go
:::

## [D - Shift vs. CapsLock](https://atcoder.jp/contests/abc303/tasks/abc303_d) / DP（テーブル）

- `dp[i][j] // i: i"番目"の文字まで処理した. j: j=0: CapsLock OFF, j=1: CapsLock ON. val: 最短秒数.`
- 以下の遷移の仕方の min を取ってテーブルを更新。
  - CapsLock が反対の状態から、
    - CapsLock を反転して通常入力（or シフト入力）
    - シフト入力（or 通常入力）して CapsLock を反転
  - CapsLock が同じ状態から、
    - CapsLock を反転して通常入力（or シフト入力）、その後 CapsLock を反転
    - 通常入力（or シフト入力）

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc303/d/main.go
:::

## [E - A Gift From the Stars](https://atcoder.jp/contests/abc303/tasks/abc303_e) / キュー

- 与えられるグラフは**木**であり葉が必ず存在する。適当な葉を見つける。その葉は星の葉であり、そこから遷移できるノードは必ず星の始点である。
- その星の頂点から遷移できるノードは全て星の葉である。その星の葉から遷移できるノードは全て別の星の葉である。
- 星の葉を**キュー**に積み、星の視点を見つけ記録し、見つかった別の星の葉をキューに積む。その過程で`別の星の葉 - 今見ている星の葉`の辺をグラフから切る。
  - 高速に辺を切るために、グラフの隣接リストの要素は Map で用意しておく。
  - $O(N)$ // 全ての星の葉が一度づつキューに積まれる。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc303/e/main.go
:::

# 302

## [B - Find snuke](https://atcoder.jp/contests/abc302/tasks/abc302_b)

- 愚直に全探索。snuke, ekuns のどちらの順番で並んでいてもいいことに注意。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc302/b/main.go
:::

## [C - Almost Equal](https://atcoder.jp/contests/abc302/tasks/abc302_c)

- **問題をよく読む**。$T_1, ...T_N$ は、$S_1, ... S_N$ の順列。各文字列 $S_i$ 自体を並び替えたりはしない。
- `NextPemutation()`で全順列を試し、$T_i, T_{i+1}$ が丁度一文字違いかをチェックする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc302/c/main.go
:::

## [D - Impartial Gift](https://atcoder.jp/contests/abc302/tasks/abc302_d) / 二分探索

- **`A >= B`, `A <= B`の二パターンに分けて考える。** 前者の場合で話を進める。
- 各 $A_i$ に対して、降順ソートした Bs から**二分探索**で最大の $B_j$ を見つける。
- $A_i$ に対する最善の相方は、$A_i - B_j <= D$ ならばその $B_j$ であり、そうでないなら存在しない。なぜならそれより B を小さくしても $A_i - B_{j'}$ が**条件を満たしやすくなることはなく**、価値の総和も減少するため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc302/d/main.go
:::

## [E - Isolation](https://atcoder.jp/contests/abc302/tasks/abc302_e)

- **連結成分を切る操作があるので、UnionFind は使えない**。
- `var graph []map[int]struct{}`でグラフを作成し、現在の孤立ノードの数`ans`を記録しておく。
- 二頂点を辺で繋げる場合は、それぞれが孤立ノードかどうかを隣接ノードマップの長さから判定し、`ans`を必要であれば減らす。
- 頂点を孤立させる場合は、その頂点が孤立ノードでないなら`ans++`し、隣接ノードからも該当頂点を削除する。隣接ノードの隣接ノードマップの長さが 1 なら更に`ans++`する。
- 計算量：
  - クエリ 1 は $O(1)$ で、クエリ 2 は $O(削除する辺の本数)$
  - 削除する辺は事前にクエリ 1 で追加されていなければならず、その最大数は高々 Q-1 本。
  - 最悪計算量になるケースは、「1 から Q-1 回目のクエリで、ある頂点 A に対して他の頂点を繋げ、Q 回目のクエリで頂点 A に対する辺を全て削除するケース」。
  - よって $O(Q)$ 。グラフの初期化を含めると $O(N+Q)$

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc302/e/main.go
:::

# 301

## [C - AtCoder Cards](https://atcoder.jp/contests/abc301/tasks/abc301_c)

- T と S で使われる文字を`map[str]cnt`に入れる。T には S と比べて何がどれだけ足りないのかを調べる。`@`はスキップする。
- T に足らない文字の総数が`tMap["@"]`以下であり、足りない文字の種類が`atcoder`のいずれかであれば OK。
- S 側でも同様のチェックをする。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc301/c/main.go
:::

## [D - Bitmask](https://atcoder.jp/contests/abc301/tasks/abc301_d) / DFS

- 上から順に桁を見て、**DFS** する。DFS は`current`を受け取る。`next_current` が N を超えたら false を返し、最後の桁まで到達したら true を返す。
  - N の二進数表現より左にある桁では、ビットが立っていたら即 false。`?`なら`0`にして次の桁へ。
  - `?`の場合、先にビットを立てる場合の再帰呼び出しをし、**結果が true の時のみそこで return。** その後`0`にする再帰呼び出しをする。
    - 常に N を超えない範囲での最大値の処理を進めて、答えが見つかったら全ての処理を打ち切るうため。

:::details code
https://github.com/Tomoki108/go-algo/blob/main/ABC/abc301/e/main.go
:::
